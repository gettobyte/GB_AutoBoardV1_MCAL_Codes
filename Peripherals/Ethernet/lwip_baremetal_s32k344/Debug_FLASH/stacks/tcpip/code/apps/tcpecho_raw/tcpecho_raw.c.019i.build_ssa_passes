tcpecho_raw_init ()
{
  err_t err;

  <bb 2> :
  _1 = tcp_new_ip_type (46);
  tcpecho_raw_pcb = _1;
  tcpecho_raw_pcb.0_2 = tcpecho_raw_pcb;
  if (tcpecho_raw_pcb.0_2 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  tcpecho_raw_pcb.1_3 = tcpecho_raw_pcb;
  err = tcp_bind (tcpecho_raw_pcb.1_3, &ip_addr_any_type, 7);
  if (err == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tcpecho_raw_pcb.2_4 = tcpecho_raw_pcb;
  _5 = tcp_listen_with_backlog (tcpecho_raw_pcb.2_4, 255);
  tcpecho_raw_pcb = _5;
  tcpecho_raw_pcb.3_6 = tcpecho_raw_pcb;
  tcp_accept (tcpecho_raw_pcb.3_6, tcpecho_raw_accept);

  <bb 5> :
  return;

}


tcpecho_raw_accept (void * arg, struct tcp_pcb * newpcb, err_t err)
{
  struct tcpecho_raw_state * es;
  err_t ret_err;
  err_t D.7557;

  <bb 2> :
  if (err != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (newpcb == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.7557 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 5> :
  tcp_setprio (newpcb, 1);
  es = mem_malloc (12);
  if (es != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  es->state = 1;
  es->pcb = newpcb;
  es->retries = 0;
  es->p = 0B;
  tcp_arg (newpcb, es);
  tcp_recv (newpcb, tcpecho_raw_recv);
  tcp_err (newpcb, tcpecho_raw_error);
  tcp_poll (newpcb, tcpecho_raw_poll, 0);
  tcp_sent (newpcb, tcpecho_raw_sent);
  ret_err = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  ret_err = -1;

  <bb 8> :
  D.7557 = ret_err;

  <bb 9> :
<L6>:
  return D.7557;

}


tcpecho_raw_recv (void * arg, struct tcp_pcb * tpcb, struct pbuf * p, err_t err)
{
  struct pbuf * ptr;
  err_t ret_err;
  struct tcpecho_raw_state * es;
  err_t D.7552;

  <bb 2> :
  if (arg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  es = arg;
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  es->state = 3;
  _1 = es->p;
  if (_1 == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tcpecho_raw_close (tpcb, es);
  goto <bb 8>; [INV]

  <bb 7> :
  tcpecho_raw_send (tpcb, es);

  <bb 8> :
  ret_err = 0;
  goto <bb 21>; [INV]

  <bb 9> :
  if (err != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (p != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  pbuf_free (p);

  <bb 12> :
  ret_err = err;
  goto <bb 21>; [INV]

  <bb 13> :
  _2 = es->state;
  if (_2 == 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  es->state = 2;
  es->p = p;
  tcpecho_raw_send (tpcb, es);
  ret_err = 0;
  goto <bb 21>; [INV]

  <bb 15> :
  _3 = es->state;
  if (_3 == 2)
    goto <bb 16>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 16> :
  _4 = es->p;
  if (_4 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  es->p = p;
  tcpecho_raw_send (tpcb, es);
  goto <bb 19>; [INV]

  <bb 18> :
  ptr = es->p;
  pbuf_cat (ptr, p);

  <bb 19> :
  ret_err = 0;
  goto <bb 21>; [INV]

  <bb 20> :
  _5 = p->tot_len;
  tcp_recved (tpcb, _5);
  pbuf_free (p);
  ret_err = 0;

  <bb 21> :
  D.7552 = ret_err;

  <bb 22> :
<L23>:
  return D.7552;

}


tcpecho_raw_sent (void * arg, struct tcp_pcb * tpcb, u16_t len)
{
  struct tcpecho_raw_state * es;
  err_t D.7528;

  <bb 2> :
  es = arg;
  es->retries = 0;
  _1 = es->p;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  tcp_sent (tpcb, tcpecho_raw_sent);
  tcpecho_raw_send (tpcb, es);
  goto <bb 6>; [INV]

  <bb 4> :
  _2 = es->state;
  if (_2 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  tcpecho_raw_close (tpcb, es);

  <bb 6> :
  D.7528 = 0;

  <bb 7> :
<L5>:
  return D.7528;

}


tcpecho_raw_poll (void * arg, struct tcp_pcb * tpcb)
{
  struct tcpecho_raw_state * es;
  err_t ret_err;
  err_t D.7521;

  <bb 2> :
  es = arg;
  if (es != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  _1 = es->p;
  if (_1 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tcpecho_raw_send (tpcb, es);
  goto <bb 7>; [INV]

  <bb 5> :
  _2 = es->state;
  if (_2 == 3)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tcpecho_raw_close (tpcb, es);

  <bb 7> :
  ret_err = 0;
  goto <bb 9>; [INV]

  <bb 8> :
  tcp_abort (tpcb);
  ret_err = -13;

  <bb 9> :
  D.7521 = ret_err;

  <bb 10> :
<L8>:
  return D.7521;

}


tcpecho_raw_error (void * arg, err_t err)
{
  struct tcpecho_raw_state * es;

  <bb 2> :
  es = arg;
  tcpecho_raw_free (es);
  return;

}


tcpecho_raw_send (struct tcp_pcb * tpcb, struct tcpecho_raw_state * es)
{
  u16_t plen;
  err_t wr_err;
  struct pbuf * ptr;

  <bb 2> :
  wr_err = 0;
  goto <bb 9>; [INV]

  <bb 3> :
  ptr = es->p;
  _1 = ptr->payload;
  _2 = ptr->len;
  wr_err = tcp_write (tpcb, _1, _2, 1);
  if (wr_err == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  plen = ptr->len;
  _3 = ptr->next;
  es->p = _3;
  _4 = es->p;
  if (_4 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _5 = es->p;
  pbuf_ref (_5);

  <bb 6> :
  pbuf_free (ptr);
  tcp_recved (tpcb, plen);
  goto <bb 9>; [INV]

  <bb 7> :
  if (wr_err == -1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  es->p = ptr;

  <bb 9> :
  if (wr_err == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _6 = es->p;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = es->p;
  _8 = _7->len;
  _9 = tpcb->snd_buf;
  if (_8 <= _9)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  return;

}


tcpecho_raw_close (struct tcp_pcb * tpcb, struct tcpecho_raw_state * es)
{
  <bb 2> :
  tcp_arg (tpcb, 0B);
  tcp_sent (tpcb, 0B);
  tcp_recv (tpcb, 0B);
  tcp_err (tpcb, 0B);
  tcp_poll (tpcb, 0B, 0);
  tcpecho_raw_free (es);
  tcp_close (tpcb);
  return;

}


tcpecho_raw_free (struct tcpecho_raw_state * es)
{
  <bb 2> :
  if (es != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _1 = es->p;
  if (_1 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _2 = es->p;
  pbuf_free (_2);

  <bb 5> :
  mem_free (es);

  <bb 6> :
  return;

}


