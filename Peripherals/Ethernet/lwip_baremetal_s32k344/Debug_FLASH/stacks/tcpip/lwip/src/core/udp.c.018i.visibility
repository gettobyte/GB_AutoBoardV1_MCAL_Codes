
Marking local functions:


Marking externally visible functions: udp_netif_ip_addr_changed/20 udp_new_ip_type/19 udp_new/18 udp_remove/17 udp_recv/16 udp_disconnect/15 udp_connect/14 udp_bind_netif/13 udp_bind/12 udp_sendto_if_src/11 udp_sendto_if/10 udp_sendto/9 udp_send/8 udp_input/7 udp_init/3


Marking externally visible variables: udp_pcbs/2


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

memset/47 (memset) @06ec8ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_new/18 
  Calls: 
memp_malloc/46 (memp_malloc) @06ec8e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_new/18 
  Calls: 
memp_free/45 (memp_free) @06ec8c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_remove/17 
  Calls: 
ip_addr_any_type/44 (ip_addr_any_type) @06eef048
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: udp_disconnect/15 (read) udp_disconnect/15 (read) udp_disconnect/15 (read) udp_disconnect/15 (read) udp_disconnect/15 (read) udp_disconnect/15 (read) udp_disconnect/15 (read) udp_disconnect/15 (read) 
  Availability: not_available
  Varpool flags: read-only
ip_addr_any/43 (ip_addr_any) @06edc5a0
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: udp_bind/12 (addr) 
  Availability: not_available
  Varpool flags: read-only
ip4_output_if_src/42 (ip4_output_if_src) @06ec80e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 
  Calls: 
ip6_output_if_src/41 (ip6_output_if_src) @06ec8000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 
  Calls: 
pbuf_chain/40 (pbuf_chain) @06eaaee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 
  Calls: 
pbuf_alloc/39 (pbuf_alloc) @06eaae00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 
  Calls: 
pbuf_add_header/38 (pbuf_add_header) @06eaad20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 
  Calls: 
ip6_select_source_address/37 (ip6_select_source_address) @06eaac40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if/10 
  Calls: 
ip6_route/36 (ip6_route) @06eaa8c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_connect/14 udp_bind/12 udp_sendto/9 
  Calls: 
ip4_route/35 (ip4_route) @06eaa7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto/9 udp_sendto/9 
  Calls: 
ip_addr_broadcast/34 (ip_addr_broadcast) @06eb0750
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: udp_sendto/9 (read) 
  Availability: not_available
  Varpool flags: read-only
netif_get_by_index/33 (netif_get_by_index) @06eaa700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto/9 udp_sendto/9 
  Calls: 
icmp_dest_unreach/32 (icmp_dest_unreach) @06eaa2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_input/7 
  Calls: 
icmp6_dest_unreach/31 (icmp6_dest_unreach) @06eaa1c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_input/7 
  Calls: 
pbuf_header_force/30 (pbuf_header_force) @06eaa0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_input/7 
  Calls: 
pbuf_remove_header/29 (pbuf_remove_header) @06eaa000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_input/7 
  Calls: 
ip_chksum_pseudo/28 (ip_chksum_pseudo) @06e42a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 udp_input/7 
  Calls: 
ip_chksum_pseudo_partial/27 (ip_chksum_pseudo_partial) @06e42ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 udp_input/7 
  Calls: 
netif_get_ip6_addr_match/26 (netif_get_ip6_addr_match) @06e42e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if/10 udp_input/7 
  Calls: 
lwip_htons/25 (lwip_htons) @06e42d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 udp_sendto_if_src/11 udp_sendto_if_src/11 udp_sendto_if_src/11 udp_input/7 udp_input/7 udp_input/7 
  Calls: 
ip4_addr_isbroadcast_u32/24 (ip4_addr_isbroadcast_u32) @06e42c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_input/7 
  Calls: 
pbuf_free/23 (pbuf_free) @06e42b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_sendto_if_src/11 udp_input/7 udp_input/7 udp_input/7 udp_input/7 udp_input/7 
  Calls: 
lwip_stats/22 (lwip_stats) @06ea52d0
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_input/7 (read) udp_input/7 (write) udp_sendto/9 (read) udp_sendto/9 (write) udp_sendto_if_src/11 (read) udp_sendto_if_src/11 (write) udp_sendto_if_src/11 (read) udp_sendto_if_src/11 (write) 
  Availability: not_available
  Varpool flags:
rand/21 (rand) @06e42700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: udp_init/3 
  Calls: 
udp_netif_ip_addr_changed/20 (udp_netif_ip_addr_changed) @06e422a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: udp_pcbs/2 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
udp_new_ip_type/19 (udp_new_ip_type) @06e0a540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: udp_new/18 
udp_new/18 (udp_new) @06e0a0e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_new_ip_type/19 
  Calls: memset/47 memp_malloc/46 
udp_remove/17 (udp_remove) @06e03b60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: udp_pcbs/2 (read) udp_pcbs/2 (read) udp_pcbs/2 (write) udp_pcbs/2 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: memp_free/45 
udp_recv/16 (udp_recv) @06e03d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
udp_disconnect/15 (udp_disconnect) @06e03a80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) ip_addr_any_type/44 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
udp_connect/14 (udp_connect) @06defa80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: udp_pcbs/2 (read) udp_pcbs/2 (read) udp_pcbs/2 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: ip6_route/36 udp_bind/12 
udp_bind_netif/13 (udp_bind_netif) @06ddf9a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
udp_bind/12 (udp_bind) @06ddf700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ip_addr_any/43 (addr) udp_pcbs/2 (read) udp_pcbs/2 (read) udp_pcbs/2 (read) udp_pcbs/2 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_connect/14 udp_sendto_if_src/11 
  Calls: udp_new_port/4 ip6_route/36 
udp_sendto_if_src/11 (udp_sendto_if_src) @06da6460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_sendto_if/10 
  Calls: pbuf_free/23 ip4_output_if_src/42 ip6_output_if_src/41 ip_chksum_pseudo/28 lwip_htons/25 ip_chksum_pseudo_partial/27 lwip_htons/25 lwip_htons/25 lwip_htons/25 pbuf_chain/40 pbuf_alloc/39 pbuf_add_header/38 udp_bind/12 
udp_sendto_if/10 (udp_sendto_if) @06d7cc40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_sendto/9 
  Calls: udp_sendto_if_src/11 netif_get_ip6_addr_match/26 ip6_select_source_address/37 
udp_sendto/9 (udp_sendto) @06d5e000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ip_addr_broadcast/34 (read) lwip_stats/22 (read) lwip_stats/22 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_send/8 
  Calls: udp_sendto_if/10 ip4_route/35 ip6_route/36 ip4_route/35 netif_get_by_index/33 netif_get_by_index/33 
udp_send/8 (udp_send) @06d2ae00
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: udp_sendto/9 
udp_input/7 (udp_input) @06d2ad20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) udp_pcbs/2 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) udp_pcbs/2 (read) udp_pcbs/2 (write) lwip_stats/22 (read) lwip_stats/22 (write) ip_data/6 (read) ip_data/6 (addr) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (addr) ip_data/6 (addr) ip_data/6 (addr) ip_data/6 (addr) lwip_stats/22 (read) lwip_stats/22 (write) ip_data/6 (addr) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) lwip_stats/22 (read) lwip_stats/22 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: pbuf_free/23 pbuf_free/23 pbuf_free/23 icmp_dest_unreach/32 icmp6_dest_unreach/31 pbuf_header_force/30 pbuf_free/23 pbuf_remove_header/29 ip_chksum_pseudo/28 ip_chksum_pseudo_partial/27 lwip_htons/25 netif_get_ip6_addr_match/26 udp_input_local_match/5 lwip_htons/25 lwip_htons/25 ip4_addr_isbroadcast_u32/24 pbuf_free/23 
   Indirect call Num speculative call targets: 0
ip_data/6 (ip_data) @06cefaf8
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input_local_match/5 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (addr) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (addr) udp_input/7 (addr) udp_input/7 (addr) udp_input/7 (addr) udp_input/7 (addr) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (read) 
  Availability: not_available
  Varpool flags:
udp_input_local_match/5 (udp_input_local_match) @06cfd700
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) ip_data/6 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_input/7 
  Calls: 
udp_new_port/4 (udp_new_port) @06cf1460
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: udp_port/1 (read) udp_port/1 (write) udp_port/1 (write) udp_pcbs/2 (read) udp_port/1 (read) udp_port/1 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: udp_bind/12 
  Calls: 
udp_init/3 (udp_init) @06cf11c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: udp_port/1 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: rand/21 
udp_pcbs/2 (udp_pcbs) @06cef5a0
  Type: variable definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: udp_new_port/4 (read) udp_input/7 (read) udp_input/7 (read) udp_input/7 (write) udp_bind/12 (read) udp_bind/12 (read) udp_bind/12 (read) udp_bind/12 (write) udp_connect/14 (read) udp_connect/14 (read) udp_connect/14 (write) udp_remove/17 (read) udp_remove/17 (read) udp_remove/17 (write) udp_remove/17 (read) udp_netif_ip_addr_changed/20 (read) 
  Availability: available
  Varpool flags:
udp_port/1 (udp_port) @06cef558
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: udp_init/3 (write) udp_new_port/4 (read) udp_new_port/4 (write) udp_new_port/4 (write) udp_new_port/4 (read) udp_new_port/4 (read) 
  Availability: available
  Varpool flags: initialized
udp_netif_ip_addr_changed (const struct ip_addr_t * old_addr, const struct ip_addr_t * new_addr)
{
  struct udp_pcb * upcb;
  int iftmp.51;
  _Bool iftmp.50;
  _Bool iftmp.49;
  int iftmp.48;
  int iftmp.47;
  _Bool iftmp.46;
  _Bool iftmp.45;
  int iftmp.44;
  int iftmp.43;
  _Bool iftmp.42;
  _Bool iftmp.41;

  <bb 2> :
  if (old_addr != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 3> :
  if (old_addr != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 4> :
  _1 = old_addr->type;
  if (_1 == 6)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  _2 = &old_addr->u_addr.ip6;
  if (_2 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  _3 = old_addr->u_addr.ip6.addr[0];
  if (_3 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _4 = old_addr->u_addr.ip6.addr[1];
  if (_4 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _5 = old_addr->u_addr.ip6.addr[2];
  if (_5 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _6 = old_addr->u_addr.ip6.addr[3];
  if (_6 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  iftmp.43 = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  iftmp.43 = 0;

  <bb 12> :
  iftmp.42 = (_Bool) iftmp.43;
  goto <bb 18>; [INV]

  <bb 13> :
  _7 = &old_addr->u_addr.ip4;
  if (_7 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _8 = old_addr->u_addr.ip4.addr;
  if (_8 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  iftmp.44 = 1;
  goto <bb 17>; [INV]

  <bb 16> :
  iftmp.44 = 0;

  <bb 17> :
  iftmp.42 = (_Bool) iftmp.44;

  <bb 18> :
  iftmp.41 = iftmp.42;
  goto <bb 20>; [INV]

  <bb 19> :
  iftmp.41 = 0;

  <bb 20> :
  if (iftmp.41 != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 21> :
  if (new_addr != 0B)
    goto <bb 22>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 22> :
  if (new_addr != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 23> :
  _9 = new_addr->type;
  if (_9 == 6)
    goto <bb 24>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 24> :
  _10 = &new_addr->u_addr.ip6;
  if (_10 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 25> :
  _11 = new_addr->u_addr.ip6.addr[0];
  if (_11 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  _12 = new_addr->u_addr.ip6.addr[1];
  if (_12 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  _13 = new_addr->u_addr.ip6.addr[2];
  if (_13 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  _14 = new_addr->u_addr.ip6.addr[3];
  if (_14 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  iftmp.47 = 1;
  goto <bb 31>; [INV]

  <bb 30> :
  iftmp.47 = 0;

  <bb 31> :
  iftmp.46 = (_Bool) iftmp.47;
  goto <bb 37>; [INV]

  <bb 32> :
  _15 = &new_addr->u_addr.ip4;
  if (_15 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  _16 = new_addr->u_addr.ip4.addr;
  if (_16 != 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  iftmp.48 = 1;
  goto <bb 36>; [INV]

  <bb 35> :
  iftmp.48 = 0;

  <bb 36> :
  iftmp.46 = (_Bool) iftmp.48;

  <bb 37> :
  iftmp.45 = iftmp.46;
  goto <bb 39>; [INV]

  <bb 38> :
  iftmp.45 = 0;

  <bb 39> :
  if (iftmp.45 != 0)
    goto <bb 40>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 40> :
  upcb = udp_pcbs;
  goto <bb 59>; [INV]

  <bb 41> :
  _17 = upcb->local_ip.type;
  _18 = old_addr->type;
  if (_17 == _18)
    goto <bb 42>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 42> :
  _19 = upcb->local_ip.type;
  if (_19 == 6)
    goto <bb 43>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 43> :
  _20 = upcb->local_ip.u_addr.ip6.addr[0];
  _21 = old_addr->u_addr.ip6.addr[0];
  if (_20 == _21)
    goto <bb 44>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 44> :
  _22 = upcb->local_ip.u_addr.ip6.addr[1];
  _23 = old_addr->u_addr.ip6.addr[1];
  if (_22 == _23)
    goto <bb 45>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 45> :
  _24 = upcb->local_ip.u_addr.ip6.addr[2];
  _25 = old_addr->u_addr.ip6.addr[2];
  if (_24 == _25)
    goto <bb 46>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 46> :
  _26 = upcb->local_ip.u_addr.ip6.addr[3];
  _27 = old_addr->u_addr.ip6.addr[3];
  if (_26 == _27)
    goto <bb 47>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 47> :
  _28 = upcb->local_ip.u_addr.ip6.zone;
  _29 = old_addr->u_addr.ip6.zone;
  if (_28 == _29)
    goto <bb 48>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 48> :
  iftmp.51 = 1;
  goto <bb 50>; [INV]

  <bb 49> :
  iftmp.51 = 0;

  <bb 50> :
  iftmp.50 = (_Bool) iftmp.51;
  goto <bb 52>; [INV]

  <bb 51> :
  _30 = upcb->local_ip.u_addr.ip4.addr;
  _31 = old_addr->u_addr.ip4.addr;
  iftmp.50 = _30 == _31;

  <bb 52> :
  iftmp.49 = iftmp.50;
  goto <bb 54>; [INV]

  <bb 53> :
  iftmp.49 = 0;

  <bb 54> :
  if (iftmp.49 != 0)
    goto <bb 55>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 55> :
  _32 = new_addr->type;
  upcb->local_ip.type = _32;
  _33 = new_addr->type;
  if (_33 == 6)
    goto <bb 56>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 56> :
  _34 = new_addr->u_addr.ip6.addr[0];
  upcb->local_ip.u_addr.ip6.addr[0] = _34;
  _35 = new_addr->u_addr.ip6.addr[1];
  upcb->local_ip.u_addr.ip6.addr[1] = _35;
  _36 = new_addr->u_addr.ip6.addr[2];
  upcb->local_ip.u_addr.ip6.addr[2] = _36;
  _37 = new_addr->u_addr.ip6.addr[3];
  upcb->local_ip.u_addr.ip6.addr[3] = _37;
  _38 = new_addr->u_addr.ip6.zone;
  upcb->local_ip.u_addr.ip6.zone = _38;
  goto <bb 58>; [INV]

  <bb 57> :
  _39 = new_addr->u_addr.ip4.addr;
  upcb->local_ip.u_addr.ip4.addr = _39;
  upcb->local_ip.u_addr.ip6.addr[3] = 0;
  _40 = upcb->local_ip.u_addr.ip6.addr[3];
  upcb->local_ip.u_addr.ip6.addr[2] = _40;
  _41 = upcb->local_ip.u_addr.ip6.addr[2];
  upcb->local_ip.u_addr.ip6.addr[1] = _41;
  upcb->local_ip.u_addr.ip6.zone = 0;

  <bb 58> :
  upcb = upcb->next;

  <bb 59> :
  if (upcb != 0B)
    goto <bb 41>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 60> :
  return;

}


udp_new_ip_type (u8_t type)
{
  struct udp_pcb * pcb;
  struct udp_pcb * D.8219;

  <bb 2> :
  pcb = udp_new ();
  if (pcb != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  pcb->local_ip.type = type;
  pcb->remote_ip.type = type;

  <bb 4> :
  D.8219 = pcb;

  <bb 5> :
<L2>:
  return D.8219;

}


udp_new ()
{
  struct udp_pcb * pcb;
  struct udp_pcb * D.8215;

  <bb 2> :
  pcb = memp_malloc (1);
  if (pcb != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  memset (pcb, 0, 84);
  pcb->ttl = 255;
  pcb->mcast_ttl = 255;

  <bb 4> :
  D.8215 = pcb;

  <bb 5> :
<L2>:
  return D.8215;

}


udp_remove (struct udp_pcb * pcb)
{
  struct udp_pcb * pcb2;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 4> :
  udp_pcbs.39_1 = udp_pcbs;
  if (pcb == udp_pcbs.39_1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  udp_pcbs.40_2 = udp_pcbs;
  _3 = udp_pcbs.40_2->next;
  udp_pcbs = _3;
  goto <bb 12>; [INV]

  <bb 6> :
  pcb2 = udp_pcbs;
  goto <bb 11>; [INV]

  <bb 7> :
  _4 = pcb2->next;
  if (_4 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _5 = pcb2->next;
  if (pcb == _5)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = pcb->next;
  pcb2->next = _6;
  goto <bb 12>; [INV]

  <bb 10> :
  pcb2 = pcb2->next;

  <bb 11> :
  if (pcb2 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  memp_free (1, pcb);

  <bb 13> :
<L12>:
  return;

}


udp_recv (struct udp_pcb * pcb, void (*udp_recv_fn) (void *, struct udp_pcb *, struct pbuf *, const struct ip_addr_t *, u16_t) recv, void * recv_arg)
{
  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  pcb->recv = recv;
  pcb->recv_arg = recv_arg;

  <bb 5> :
<L2>:
  return;

}


udp_disconnect (struct udp_pcb * pcb)
{
  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 4> :
  _1 = pcb->local_ip.type;
  if (_1 == 46)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _2 = ip_addr_any_type.type;
  pcb->remote_ip.type = _2;
  _3 = ip_addr_any_type.type;
  if (_3 == 6)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _4 = ip_addr_any_type.u_addr.ip6.addr[0];
  pcb->remote_ip.u_addr.ip6.addr[0] = _4;
  _5 = ip_addr_any_type.u_addr.ip6.addr[1];
  pcb->remote_ip.u_addr.ip6.addr[1] = _5;
  _6 = ip_addr_any_type.u_addr.ip6.addr[2];
  pcb->remote_ip.u_addr.ip6.addr[2] = _6;
  _7 = ip_addr_any_type.u_addr.ip6.addr[3];
  pcb->remote_ip.u_addr.ip6.addr[3] = _7;
  _8 = ip_addr_any_type.u_addr.ip6.zone;
  pcb->remote_ip.u_addr.ip6.zone = _8;
  goto <bb 14>; [INV]

  <bb 7> :
  _9 = ip_addr_any_type.u_addr.ip4.addr;
  pcb->remote_ip.u_addr.ip4.addr = _9;
  pcb->remote_ip.u_addr.ip6.addr[3] = 0;
  _10 = pcb->remote_ip.u_addr.ip6.addr[3];
  pcb->remote_ip.u_addr.ip6.addr[2] = _10;
  _11 = pcb->remote_ip.u_addr.ip6.addr[2];
  pcb->remote_ip.u_addr.ip6.addr[1] = _11;
  pcb->remote_ip.u_addr.ip6.zone = 0;
  goto <bb 14>; [INV]

  <bb 8> :
  _12 = pcb->remote_ip.type;
  if (_12 == 6)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  pcb->remote_ip.u_addr.ip6.addr[0] = 0;
  pcb->remote_ip.u_addr.ip6.addr[1] = 0;
  pcb->remote_ip.u_addr.ip6.addr[2] = 0;
  pcb->remote_ip.u_addr.ip6.addr[3] = 0;
  pcb->remote_ip.u_addr.ip6.zone = 0;
  _13 = &pcb->remote_ip;
  if (_13 != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 10> :
  pcb->remote_ip.type = 6;
  goto <bb 14>; [INV]

  <bb 11> :
  pcb->remote_ip.u_addr.ip4.addr = 0;
  _14 = &pcb->remote_ip;
  if (_14 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  pcb->remote_ip.type = 0;

  <bb 13> :
  pcb->remote_ip.u_addr.ip6.addr[3] = 0;
  _15 = pcb->remote_ip.u_addr.ip6.addr[3];
  pcb->remote_ip.u_addr.ip6.addr[2] = _15;
  _16 = pcb->remote_ip.u_addr.ip6.addr[2];
  pcb->remote_ip.u_addr.ip6.addr[1] = _16;
  pcb->remote_ip.u_addr.ip6.zone = 0;

  <bb 14> :
  pcb->remote_port = 0;
  pcb->netif_idx = 0;
  _17 = pcb->flags;
  _18 = _17 & 251;
  pcb->flags = _18;

  <bb 15> :
<L15>:
  return;

}


udp_connect (struct udp_pcb * pcb, const struct ip_addr_t * ipaddr, u16_t port)
{
  struct netif * selected_netif;
  err_t err;
  struct udp_pcb * ipcb;
  u8_t iftmp.37;
  const long unsigned int iftmp.36;
  u8_t iftmp.35;
  const long unsigned int iftmp.34;
  const long unsigned int iftmp.33;
  const long unsigned int iftmp.32;
  const long unsigned int iftmp.31;
  err_t D.8123;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.8123 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 53>; [INV]

  <bb 4> :
  if (ipaddr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8123 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 53>; [INV]

  <bb 6> :
  _1 = pcb->local_port;
  if (_1 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _2 = &pcb->local_ip;
  _3 = pcb->local_port;
  err = udp_bind (pcb, _2, _3);
  if (err != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.8123 = err;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 53>; [INV]

  <bb 9> :
  _4 = &pcb->remote_ip;
  if (_4 != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _5 = ipaddr->type;
  pcb->remote_ip.type = _5;

  <bb 11> :
  if (ipaddr != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 12> :
  _6 = ipaddr->type;
  if (_6 == 6)
    goto <bb 13>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 13> :
  _7 = &ipaddr->u_addr.ip6;
  if (_7 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  iftmp.31 = ipaddr->u_addr.ip6.addr[0];
  goto <bb 16>; [INV]

  <bb 15> :
  iftmp.31 = 0;

  <bb 16> :
  pcb->remote_ip.u_addr.ip6.addr[0] = iftmp.31;
  _8 = &ipaddr->u_addr.ip6;
  if (_8 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  iftmp.32 = ipaddr->u_addr.ip6.addr[1];
  goto <bb 19>; [INV]

  <bb 18> :
  iftmp.32 = 0;

  <bb 19> :
  pcb->remote_ip.u_addr.ip6.addr[1] = iftmp.32;
  _9 = &ipaddr->u_addr.ip6;
  if (_9 != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  iftmp.33 = ipaddr->u_addr.ip6.addr[2];
  goto <bb 22>; [INV]

  <bb 21> :
  iftmp.33 = 0;

  <bb 22> :
  pcb->remote_ip.u_addr.ip6.addr[2] = iftmp.33;
  _10 = &ipaddr->u_addr.ip6;
  if (_10 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  iftmp.34 = ipaddr->u_addr.ip6.addr[3];
  goto <bb 25>; [INV]

  <bb 24> :
  iftmp.34 = 0;

  <bb 25> :
  pcb->remote_ip.u_addr.ip6.addr[3] = iftmp.34;
  _11 = &ipaddr->u_addr.ip6;
  if (_11 != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  iftmp.35 = ipaddr->u_addr.ip6.zone;
  goto <bb 28>; [INV]

  <bb 27> :
  iftmp.35 = 0;

  <bb 28> :
  pcb->remote_ip.u_addr.ip6.zone = iftmp.35;
  goto <bb 33>; [INV]

  <bb 29> :
  _12 = &ipaddr->u_addr.ip4;
  if (_12 != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  iftmp.36 = ipaddr->u_addr.ip4.addr;
  goto <bb 32>; [INV]

  <bb 31> :
  iftmp.36 = 0;

  <bb 32> :
  pcb->remote_ip.u_addr.ip4.addr = iftmp.36;
  pcb->remote_ip.u_addr.ip6.addr[3] = 0;
  _13 = pcb->remote_ip.u_addr.ip6.addr[3];
  pcb->remote_ip.u_addr.ip6.addr[2] = _13;
  _14 = pcb->remote_ip.u_addr.ip6.addr[2];
  pcb->remote_ip.u_addr.ip6.addr[1] = _14;
  pcb->remote_ip.u_addr.ip6.zone = 0;

  <bb 33> :
  _15 = &pcb->remote_ip;
  if (_15 != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 34> :
  _16 = pcb->remote_ip.type;
  if (_16 == 6)
    goto <bb 35>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 35> :
  _17 = pcb->remote_ip.u_addr.ip6.zone;
  if (_17 == 0)
    goto <bb 36>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 36> :
  _18 = pcb->remote_ip.u_addr.ip6.addr[0];
  _19 = _18 & 49407;
  if (_19 == 33022)
    goto <bb 39>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 37> :
  _20 = pcb->remote_ip.u_addr.ip6.addr[0];
  _21 = _20 & 36863;
  if (_21 == 511)
    goto <bb 39>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  _22 = pcb->remote_ip.u_addr.ip6.addr[0];
  _23 = _22 & 36863;
  if (_23 == 767)
    goto <bb 39>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 39> :
  _24 = &pcb->local_ip.u_addr.ip6;
  _25 = &pcb->remote_ip.u_addr.ip6;
  selected_netif = ip6_route (_24, _25);
  if (selected_netif != 0B)
    goto <bb 40>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 40> :
  _26 = pcb->remote_ip.u_addr.ip6.addr[0];
  _27 = _26 & 49407;
  if (_27 == 33022)
    goto <bb 43>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 41> :
  _28 = pcb->remote_ip.u_addr.ip6.addr[0];
  _29 = _28 & 36863;
  if (_29 == 511)
    goto <bb 43>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 42> :
  _30 = pcb->remote_ip.u_addr.ip6.addr[0];
  _31 = _30 & 36863;
  if (_31 == 767)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  _32 = selected_netif->num;
  iftmp.37 = _32 + 1;
  goto <bb 45>; [INV]

  <bb 44> :
  iftmp.37 = 0;

  <bb 45> :
  pcb->remote_ip.u_addr.ip6.zone = iftmp.37;

  <bb 46> :
  pcb->remote_port = port;
  _33 = pcb->flags;
  _34 = _33 | 4;
  pcb->flags = _34;
  _35 = pcb->remote_ip.type;

  <bb 47> :
  ipcb = udp_pcbs;
  goto <bb 51>; [INV]

  <bb 48> :
  if (pcb == ipcb)
    goto <bb 49>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 49> :
  D.8123 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 53>; [INV]

  <bb 50> :
  ipcb = ipcb->next;

  <bb 51> :
  if (ipcb != 0B)
    goto <bb 48>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  udp_pcbs.38_36 = udp_pcbs;
  pcb->next = udp_pcbs.38_36;
  udp_pcbs = pcb;
  D.8123 = 0;

  <bb 53> :
<L57>:
  return D.8123;

}


udp_bind_netif (struct udp_pcb * pcb, const struct netif * netif)
{
  <bb 2> :
  if (netif != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = netif->num;
  _2 = _1 + 1;
  pcb->netif_idx = _2;
  goto <bb 5>; [INV]

  <bb 4> :
  pcb->netif_idx = 0;

  <bb 5> :
  return;

}


udp_bind (struct udp_pcb * pcb, const struct ip_addr_t * ipaddr, u16_t port)
{
  struct netif * selected_netif;
  struct ip_addr_t zoned_ipaddr;
  u8_t rebind;
  struct udp_pcb * ipcb;
  const long unsigned int iftmp.29;
  u8_t iftmp.28;
  const long unsigned int iftmp.27;
  const long unsigned int iftmp.26;
  const long unsigned int iftmp.25;
  const long unsigned int iftmp.24;
  int iftmp.23;
  int iftmp.22;
  int iftmp.21;
  int iftmp.20;
  int iftmp.19;
  u8_t iftmp.18;
  err_t D.7980;

  <bb 2> :
  if (ipaddr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ipaddr = &ip_addr_any;

  <bb 4> :
  if (pcb == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7980 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 115>; [INV]

  <bb 6> :
  if (ipaddr != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _1 = ipaddr->type;

  <bb 8> :
  rebind = 0;
  ipcb = udp_pcbs;
  goto <bb 12>; [INV]

  <bb 9> :
  if (pcb == ipcb)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  rebind = 1;
  goto <bb 13>; [INV]

  <bb 11> :
  ipcb = ipcb->next;

  <bb 12> :
  if (ipcb != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  if (ipaddr != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 14> :
  _2 = ipaddr->type;
  if (_2 == 6)
    goto <bb 15>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 15> :
  _3 = ipaddr->u_addr.ip6.zone;
  if (_3 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 16> :
  _4 = ipaddr->u_addr.ip6.addr[0];
  _5 = _4 & 49407;
  if (_5 == 33022)
    goto <bb 19>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  _6 = ipaddr->u_addr.ip6.addr[0];
  _7 = _6 & 36863;
  if (_7 == 511)
    goto <bb 19>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  _8 = ipaddr->u_addr.ip6.addr[0];
  _9 = _8 & 36863;
  if (_9 == 767)
    goto <bb 19>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 19> :
  _10 = ipaddr->type;
  zoned_ipaddr.type = _10;
  _11 = ipaddr->type;
  if (_11 == 6)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _12 = ipaddr->u_addr.ip6.addr[0];
  zoned_ipaddr.u_addr.ip6.addr[0] = _12;
  _13 = ipaddr->u_addr.ip6.addr[1];
  zoned_ipaddr.u_addr.ip6.addr[1] = _13;
  _14 = ipaddr->u_addr.ip6.addr[2];
  zoned_ipaddr.u_addr.ip6.addr[2] = _14;
  _15 = ipaddr->u_addr.ip6.addr[3];
  zoned_ipaddr.u_addr.ip6.addr[3] = _15;
  _16 = ipaddr->u_addr.ip6.zone;
  zoned_ipaddr.u_addr.ip6.zone = _16;
  goto <bb 22>; [INV]

  <bb 21> :
  _17 = ipaddr->u_addr.ip4.addr;
  zoned_ipaddr.u_addr.ip4.addr = _17;
  zoned_ipaddr.u_addr.ip6.addr[3] = 0;
  _18 = zoned_ipaddr.u_addr.ip6.addr[3];
  zoned_ipaddr.u_addr.ip6.addr[2] = _18;
  _19 = zoned_ipaddr.u_addr.ip6.addr[2];
  zoned_ipaddr.u_addr.ip6.addr[1] = _19;
  zoned_ipaddr.u_addr.ip6.zone = 0;

  <bb 22> :
  selected_netif = ip6_route (&zoned_ipaddr.u_addr.ip6, &zoned_ipaddr.u_addr.ip6);
  if (selected_netif != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 23> :
  _20 = zoned_ipaddr.u_addr.ip6.addr[0];
  _21 = _20 & 49407;
  if (_21 == 33022)
    goto <bb 26>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  _22 = zoned_ipaddr.u_addr.ip6.addr[0];
  _23 = _22 & 36863;
  if (_23 == 511)
    goto <bb 26>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  _24 = zoned_ipaddr.u_addr.ip6.addr[0];
  _25 = _24 & 36863;
  if (_25 == 767)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _26 = selected_netif->num;
  iftmp.18 = _26 + 1;
  goto <bb 28>; [INV]

  <bb 27> :
  iftmp.18 = 0;

  <bb 28> :
  zoned_ipaddr.u_addr.ip6.zone = iftmp.18;

  <bb 29> :
  ipaddr = &zoned_ipaddr;

  <bb 30> :
  if (port == 0)
    goto <bb 31>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 31> :
  port = udp_new_port ();
  if (port == 0)
    goto <bb 32>; [INV]
  else
    goto <bb 87>; [INV]

  <bb 32> :
  D.7980 = -8;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 115>; [INV]

  <bb 33> :
  ipcb = udp_pcbs;
  goto <bb 86>; [INV]

  <bb 34> :
  if (pcb != ipcb)
    goto <bb 35>; [INV]
  else
    goto <bb 85>; [INV]

  <bb 35> :
  _27 = ipcb->local_port;
  if (port == _27)
    goto <bb 36>; [INV]
  else
    goto <bb 85>; [INV]

  <bb 36> :
  _28 = ipcb->local_ip.type;
  _29 = ipaddr->type;
  if (_28 == _29)
    goto <bb 37>; [INV]
  else
    goto <bb 82>; [INV]

  <bb 37> :
  _30 = ipcb->local_ip.type;
  _31 = ipaddr->type;
  if (_30 == _31)
    goto <bb 38>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 38> :
  _32 = ipcb->local_ip.type;
  if (_32 == 6)
    goto <bb 39>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 39> :
  _33 = ipcb->local_ip.u_addr.ip6.addr[0];
  _34 = ipaddr->u_addr.ip6.addr[0];
  if (_33 == _34)
    goto <bb 40>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 40> :
  _35 = ipcb->local_ip.u_addr.ip6.addr[1];
  _36 = ipaddr->u_addr.ip6.addr[1];
  if (_35 == _36)
    goto <bb 41>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 41> :
  _37 = ipcb->local_ip.u_addr.ip6.addr[2];
  _38 = ipaddr->u_addr.ip6.addr[2];
  if (_37 == _38)
    goto <bb 42>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 42> :
  _39 = ipcb->local_ip.u_addr.ip6.addr[3];
  _40 = ipaddr->u_addr.ip6.addr[3];
  if (_39 == _40)
    goto <bb 43>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 43> :
  _41 = ipcb->local_ip.u_addr.ip6.zone;
  _42 = ipaddr->u_addr.ip6.zone;
  if (_41 == _42)
    goto <bb 44>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 44> :
  iftmp.19 = 1;
  goto <bb 46>; [INV]

  <bb 45> :
  iftmp.19 = 0;

  <bb 46> :
  _43 = (_Bool) iftmp.19;
  if (_43 != 0)
    goto <bb 84>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 47> :
  _44 = ipcb->local_ip.u_addr.ip4.addr;
  _45 = ipaddr->u_addr.ip4.addr;
  if (_44 == _45)
    goto <bb 84>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 48> :
  if (ipaddr != 0B)
    goto <bb 49>; [INV]
  else
    goto <bb 84>; [INV]

  <bb 49> :
  if (ipaddr != 0B)
    goto <bb 50>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 50> :
  _46 = ipaddr->type;
  if (_46 == 6)
    goto <bb 51>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 51> :
  _47 = &ipaddr->u_addr.ip6;
  if (_47 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _48 = ipaddr->u_addr.ip6.addr[0];
  if (_48 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 53> :
  _49 = ipaddr->u_addr.ip6.addr[1];
  if (_49 == 0)
    goto <bb 54>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 54> :
  _50 = ipaddr->u_addr.ip6.addr[2];
  if (_50 == 0)
    goto <bb 55>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 55> :
  _51 = ipaddr->u_addr.ip6.addr[3];
  if (_51 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 56> :
  iftmp.20 = 1;
  goto <bb 58>; [INV]

  <bb 57> :
  iftmp.20 = 0;

  <bb 58> :
  _52 = (_Bool) iftmp.20;
  if (_52 != 0)
    goto <bb 84>; [INV]
  else
    goto <bb 59>; [INV]

  <bb 59> :
  goto <bb 65>; [INV]

  <bb 60> :
  _53 = &ipaddr->u_addr.ip4;
  if (_53 == 0B)
    goto <bb 62>; [INV]
  else
    goto <bb 61>; [INV]

  <bb 61> :
  _54 = ipaddr->u_addr.ip4.addr;
  if (_54 == 0)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  iftmp.21 = 1;
  goto <bb 64>; [INV]

  <bb 63> :
  iftmp.21 = 0;

  <bb 64> :
  _55 = (_Bool) iftmp.21;
  if (_55 != 0)
    goto <bb 84>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 65> :

  <bb 66> :
  _56 = &ipcb->local_ip;
  if (_56 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 84>; [INV]

  <bb 67> :
  _57 = &ipcb->local_ip;
  if (_57 != 0B)
    goto <bb 68>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 68> :
  _58 = ipcb->local_ip.type;
  if (_58 == 6)
    goto <bb 69>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 69> :
  _59 = &ipcb->local_ip.u_addr.ip6;
  if (_59 == 0B)
    goto <bb 74>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 70> :
  _60 = ipcb->local_ip.u_addr.ip6.addr[0];
  if (_60 == 0)
    goto <bb 71>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 71> :
  _61 = ipcb->local_ip.u_addr.ip6.addr[1];
  if (_61 == 0)
    goto <bb 72>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 72> :
  _62 = ipcb->local_ip.u_addr.ip6.addr[2];
  if (_62 == 0)
    goto <bb 73>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 73> :
  _63 = ipcb->local_ip.u_addr.ip6.addr[3];
  if (_63 == 0)
    goto <bb 74>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 74> :
  iftmp.22 = 1;
  goto <bb 76>; [INV]

  <bb 75> :
  iftmp.22 = 0;

  <bb 76> :
  _64 = (_Bool) iftmp.22;
  if (_64 != 0)
    goto <bb 84>; [INV]
  else
    goto <bb 82>; [INV]

  <bb 77> :
  _65 = &ipcb->local_ip.u_addr.ip4;
  if (_65 == 0B)
    goto <bb 79>; [INV]
  else
    goto <bb 78>; [INV]

  <bb 78> :
  _66 = ipcb->local_ip.u_addr.ip4.addr;
  if (_66 == 0)
    goto <bb 79>; [INV]
  else
    goto <bb 80>; [INV]

  <bb 79> :
  iftmp.23 = 1;
  goto <bb 81>; [INV]

  <bb 80> :
  iftmp.23 = 0;

  <bb 81> :
  _67 = (_Bool) iftmp.23;
  if (_67 != 0)
    goto <bb 84>; [INV]
  else
    goto <bb 82>; [INV]

  <bb 82> :
  _68 = ipcb->local_ip.type;
  if (_68 == 46)
    goto <bb 84>; [INV]
  else
    goto <bb 83>; [INV]

  <bb 83> :
  _69 = ipaddr->type;
  if (_69 == 46)
    goto <bb 84>; [INV]
  else
    goto <bb 85>; [INV]

  <bb 84> :
  D.7980 = -8;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 115>; [INV]

  <bb 85> :
  ipcb = ipcb->next;

  <bb 86> :
  if (ipcb != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 87>; [INV]

  <bb 87> :
  _70 = &pcb->local_ip;
  if (_70 != 0B)
    goto <bb 88>; [INV]
  else
    goto <bb 89>; [INV]

  <bb 88> :
  _71 = ipaddr->type;
  pcb->local_ip.type = _71;

  <bb 89> :
  if (ipaddr != 0B)
    goto <bb 90>; [INV]
  else
    goto <bb 107>; [INV]

  <bb 90> :
  _72 = ipaddr->type;
  if (_72 == 6)
    goto <bb 91>; [INV]
  else
    goto <bb 107>; [INV]

  <bb 91> :
  _73 = &ipaddr->u_addr.ip6;
  if (_73 != 0B)
    goto <bb 92>; [INV]
  else
    goto <bb 93>; [INV]

  <bb 92> :
  iftmp.24 = ipaddr->u_addr.ip6.addr[0];
  goto <bb 94>; [INV]

  <bb 93> :
  iftmp.24 = 0;

  <bb 94> :
  pcb->local_ip.u_addr.ip6.addr[0] = iftmp.24;
  _74 = &ipaddr->u_addr.ip6;
  if (_74 != 0B)
    goto <bb 95>; [INV]
  else
    goto <bb 96>; [INV]

  <bb 95> :
  iftmp.25 = ipaddr->u_addr.ip6.addr[1];
  goto <bb 97>; [INV]

  <bb 96> :
  iftmp.25 = 0;

  <bb 97> :
  pcb->local_ip.u_addr.ip6.addr[1] = iftmp.25;
  _75 = &ipaddr->u_addr.ip6;
  if (_75 != 0B)
    goto <bb 98>; [INV]
  else
    goto <bb 99>; [INV]

  <bb 98> :
  iftmp.26 = ipaddr->u_addr.ip6.addr[2];
  goto <bb 100>; [INV]

  <bb 99> :
  iftmp.26 = 0;

  <bb 100> :
  pcb->local_ip.u_addr.ip6.addr[2] = iftmp.26;
  _76 = &ipaddr->u_addr.ip6;
  if (_76 != 0B)
    goto <bb 101>; [INV]
  else
    goto <bb 102>; [INV]

  <bb 101> :
  iftmp.27 = ipaddr->u_addr.ip6.addr[3];
  goto <bb 103>; [INV]

  <bb 102> :
  iftmp.27 = 0;

  <bb 103> :
  pcb->local_ip.u_addr.ip6.addr[3] = iftmp.27;
  _77 = &ipaddr->u_addr.ip6;
  if (_77 != 0B)
    goto <bb 104>; [INV]
  else
    goto <bb 105>; [INV]

  <bb 104> :
  iftmp.28 = ipaddr->u_addr.ip6.zone;
  goto <bb 106>; [INV]

  <bb 105> :
  iftmp.28 = 0;

  <bb 106> :
  pcb->local_ip.u_addr.ip6.zone = iftmp.28;
  goto <bb 111>; [INV]

  <bb 107> :
  _78 = &ipaddr->u_addr.ip4;
  if (_78 != 0B)
    goto <bb 108>; [INV]
  else
    goto <bb 109>; [INV]

  <bb 108> :
  iftmp.29 = ipaddr->u_addr.ip4.addr;
  goto <bb 110>; [INV]

  <bb 109> :
  iftmp.29 = 0;

  <bb 110> :
  pcb->local_ip.u_addr.ip4.addr = iftmp.29;
  pcb->local_ip.u_addr.ip6.addr[3] = 0;
  _79 = pcb->local_ip.u_addr.ip6.addr[3];
  pcb->local_ip.u_addr.ip6.addr[2] = _79;
  _80 = pcb->local_ip.u_addr.ip6.addr[2];
  pcb->local_ip.u_addr.ip6.addr[1] = _80;
  pcb->local_ip.u_addr.ip6.zone = 0;

  <bb 111> :
  pcb->local_port = port;
  if (rebind == 0)
    goto <bb 112>; [INV]
  else
    goto <bb 113>; [INV]

  <bb 112> :
  udp_pcbs.30_81 = udp_pcbs;
  pcb->next = udp_pcbs.30_81;
  udp_pcbs = pcb;

  <bb 113> :
  _82 = pcb->local_ip.type;

  <bb 114> :
  D.7980 = 0;

  <bb 115> :
  zoned_ipaddr = {CLOBBER};

  <bb 116> :
<L134>:
  return D.7980;

}


udp_sendto_if_src (struct udp_pcb * pcb, struct pbuf * p, const struct ip_addr_t * dst_ip, u16_t dst_port, struct netif * netif, const struct ip_addr_t * src_ip)
{
  u16_t udpchksum;
  u16_t chklen_hdr;
  u16_t chklen;
  u8_t ttl;
  u8_t ip_proto;
  struct pbuf * q;
  err_t err;
  struct udp_hdr * udphdr;
  err_t iftmp.17;
  _Bool iftmp.16;
  u8_t iftmp.15;
  _Bool iftmp.14;
  err_t D.7905;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7905 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 4> :
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7905 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 6> :
  if (dst_ip == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.7905 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 8> :
  if (src_ip == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.7905 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 10> :
  if (netif == 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  D.7905 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 12> :
  _1 = pcb->local_ip.type;
  if (_1 != 46)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _2 = pcb->local_ip.type;
  _3 = src_ip->type;
  if (_2 != _3)
    goto <bb 16>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _4 = pcb->local_ip.type;
  if (_4 != 46)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  _5 = pcb->local_ip.type;
  _6 = dst_ip->type;
  if (_5 != _6)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  D.7905 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 17> :
  _7 = pcb->local_port;
  if (_7 == 0)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  _8 = &pcb->local_ip;
  _9 = pcb->local_port;
  err = udp_bind (pcb, _8, _9);
  if (err != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  D.7905 = err;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 20> :
  _10 = p->tot_len;
  if (_10 > 65527)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  D.7905 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 22> :
  _11 = pbuf_add_header (p, 8);
  if (_11 != 0)
    goto <bb 23>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 23> :
  q = pbuf_alloc (54, 8, 640);
  if (q == 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  D.7905 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 65>; [INV]

  <bb 25> :
  _12 = p->tot_len;
  if (_12 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  pbuf_chain (q, p);
  goto <bb 28>; [INV]

  <bb 27> :
  q = p;

  <bb 28> :
  _13 = q->len;
  if (_13 <= 7)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 29>; [INV]

  <bb 30> :
  udphdr = q->payload;
  _14 = pcb->local_port;
  _15 = lwip_htons (_14);
  udphdr->src = _15;
  _16 = lwip_htons (dst_port);
  udphdr->dest = _16;
  udphdr->chksum = 0;
  _17 = pcb->flags;
  _18 = (unsigned int) _17;
  _19 = _18 & 8;
  if (_19 != 0)
    goto <bb 31>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 31> :
  if (dst_ip != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 32> :
  _20 = dst_ip->type;
  if (_20 == 6)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _21 = dst_ip->u_addr.ip6.addr[0];
  _22 = _21 & 255;
  iftmp.14 = _22 == 255;
  goto <bb 35>; [INV]

  <bb 34> :
  _23 = dst_ip->u_addr.ip4.addr;
  _24 = _23 & 240;
  iftmp.14 = _24 == 224;

  <bb 35> :
  if (iftmp.14 != 0)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _25 = q->flags;
  _26 = _25 | 4;
  q->flags = _26;

  <bb 37> :
  _27 = pcb->flags;
  _28 = (unsigned int) _27;
  _29 = _28 & 2;
  if (_29 != 0)
    goto <bb 38>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 38> :
  chklen = pcb->chksum_len_tx;
  chklen_hdr = chklen;
  if (chklen <= 7)
    goto <bb 40>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 39> :
  _30 = q->tot_len;
  if (chklen > _30)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  chklen_hdr = 0;
  chklen = q->tot_len;

  <bb 41> :
  _31 = lwip_htons (chklen_hdr);
  udphdr->len = _31;
  _32 = q->tot_len;
  _33 = ip_chksum_pseudo_partial (q, 136, _32, chklen, src_ip, dst_ip);
  udphdr->chksum = _33;
  _34 = udphdr->chksum;
  if (_34 == 0)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  udphdr->chksum = 65535;

  <bb 43> :
  ip_proto = 136;
  goto <bb 51>; [INV]

  <bb 44> :
  _35 = q->tot_len;
  _36 = lwip_htons (_35);
  udphdr->len = _36;
  if (dst_ip != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _37 = dst_ip->type;
  if (_37 == 6)
    goto <bb 47>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _38 = pcb->flags;
  _39 = (unsigned int) _38;
  _40 = _39 & 1;
  if (_40 == 0)
    goto <bb 47>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 47> :
  _41 = q->tot_len;
  udpchksum = ip_chksum_pseudo (q, 17, _41, src_ip, dst_ip);
  if (udpchksum == 0)
    goto <bb 48>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 48> :
  udpchksum = 65535;

  <bb 49> :
  udphdr->chksum = udpchksum;

  <bb 50> :
  ip_proto = 17;

  <bb 51> :
  if (dst_ip != 0B)
    goto <bb 52>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 52> :
  _42 = dst_ip->type;
  if (_42 == 6)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  _43 = dst_ip->u_addr.ip6.addr[0];
  _44 = _43 & 255;
  iftmp.16 = _44 == 255;
  goto <bb 55>; [INV]

  <bb 54> :
  _45 = dst_ip->u_addr.ip4.addr;
  _46 = _45 & 240;
  iftmp.16 = _46 == 224;

  <bb 55> :
  if (iftmp.16 != 0)
    goto <bb 56>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 56> :
  iftmp.15 = pcb->mcast_ttl;
  goto <bb 58>; [INV]

  <bb 57> :
  iftmp.15 = pcb->ttl;

  <bb 58> :
  ttl = iftmp.15;
  if (dst_ip != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 61>; [INV]

  <bb 59> :
  _47 = dst_ip->type;
  if (_47 == 6)
    goto <bb 60>; [INV]
  else
    goto <bb 61>; [INV]

  <bb 60> :
  _48 = &src_ip->u_addr.ip6;
  _49 = &dst_ip->u_addr.ip6;
  _50 = pcb->tos;
  iftmp.17 = ip6_output_if_src (q, _48, _49, ttl, _50, ip_proto, netif);
  goto <bb 62>; [INV]

  <bb 61> :
  _51 = &src_ip->u_addr.ip4;
  _52 = &dst_ip->u_addr.ip4;
  _53 = pcb->tos;
  iftmp.17 = ip4_output_if_src (q, _51, _52, ttl, _53, ip_proto, netif);

  <bb 62> :
  err = iftmp.17;
  _54 = lwip_stats.mib2.udpoutdatagrams;
  _55 = _54 + 1;
  lwip_stats.mib2.udpoutdatagrams = _55;
  if (q != p)
    goto <bb 63>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 63> :
  pbuf_free (q);
  q = 0B;

  <bb 64> :
  _56 = lwip_stats.udp.xmit;
  _57 = _56 + 1;
  lwip_stats.udp.xmit = _57;
  D.7905 = err;

  <bb 65> :
<L68>:
  return D.7905;

}


udp_sendto_if (struct udp_pcb * pcb, struct pbuf * p, const struct ip_addr_t * dst_ip, u16_t dst_port, struct netif * netif)
{
  const struct ip_addr_t * src_ip;
  err_t D.7868;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7868 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 4> :
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7868 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 6> :
  if (dst_ip == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.7868 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 8> :
  if (netif == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.7868 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 10> :
  _1 = pcb->local_ip.type;
  if (_1 != 46)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 11> :
  _2 = pcb->local_ip.type;
  _3 = dst_ip->type;
  if (_2 != _3)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  D.7868 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 13> :
  if (dst_ip != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 14> :
  _4 = dst_ip->type;
  if (_4 == 6)
    goto <bb 15>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 15> :
  _5 = &pcb->local_ip.u_addr.ip6;
  if (_5 == 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _6 = pcb->local_ip.u_addr.ip6.addr[0];
  if (_6 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 17> :
  _7 = pcb->local_ip.u_addr.ip6.addr[1];
  if (_7 == 0)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  _8 = pcb->local_ip.u_addr.ip6.addr[2];
  if (_8 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _9 = pcb->local_ip.u_addr.ip6.addr[3];
  if (_9 == 0)
    goto <bb 21>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  _10 = pcb->local_ip.u_addr.ip6.addr[0];
  _11 = _10 & 255;
  if (_11 == 255)
    goto <bb 21>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 21> :
  _12 = &dst_ip->u_addr.ip6;
  src_ip = ip6_select_source_address (netif, _12);
  if (src_ip == 0B)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  D.7868 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 23> :
  goto <bb 27>; [INV]

  <bb 24> :
  _13 = &pcb->local_ip.u_addr.ip6;
  _14 = netif_get_ip6_addr_match (netif, _13);
  if (_14 < 0)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  D.7868 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 26> :
  src_ip = &pcb->local_ip;

  <bb 27> :
  goto <bb 35>; [INV]

  <bb 28> :
  _15 = &pcb->local_ip.u_addr.ip4;
  if (_15 == 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 29> :
  _16 = pcb->local_ip.u_addr.ip4.addr;
  if (_16 == 0)
    goto <bb 31>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 30> :
  _17 = pcb->local_ip.u_addr.ip4.addr;
  _18 = _17 & 240;
  if (_18 == 224)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  src_ip = &netif->ip_addr;
  goto <bb 35>; [INV]

  <bb 32> :
  _19 = pcb->local_ip.u_addr.ip4.addr;
  _20 = &netif->ip_addr.u_addr.ip4;
  _21 = MEM[(const struct ip4_addr_t *)_20].addr;
  if (_19 != _21)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  D.7868 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 34> :
  src_ip = &pcb->local_ip;

  <bb 35> :
  D.7868 = udp_sendto_if_src (pcb, p, dst_ip, dst_port, netif, src_ip);

  <bb 36> :
<L35>:
  return D.7868;

}


udp_sendto (struct udp_pcb * pcb, struct pbuf * p, const struct ip_addr_t * dst_ip, u16_t dst_port)
{
  struct netif * netif;
  struct netif * iftmp.13;
  _Bool iftmp.12;
  err_t D.7822;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7822 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 4> :
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7822 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 6> :
  if (dst_ip == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.7822 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 8> :
  _1 = pcb->local_ip.type;
  if (_1 != 46)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _2 = pcb->local_ip.type;
  _3 = dst_ip->type;
  if (_2 != _3)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.7822 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 11> :
  _4 = pcb->netif_idx;
  if (_4 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _5 = pcb->netif_idx;
  netif = netif_get_by_index (_5);
  goto <bb 31>; [INV]

  <bb 13> :
  netif = 0B;
  if (dst_ip != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _6 = dst_ip->type;
  if (_6 == 6)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _7 = dst_ip->u_addr.ip6.addr[0];
  _8 = _7 & 255;
  iftmp.12 = _8 == 255;
  goto <bb 17>; [INV]

  <bb 16> :
  _9 = dst_ip->u_addr.ip4.addr;
  _10 = _9 & 240;
  iftmp.12 = _10 == 224;

  <bb 17> :
  if (iftmp.12 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 18> :
  _11 = pcb->mcast_ifindex;
  if (_11 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _12 = pcb->mcast_ifindex;
  netif = netif_get_by_index (_12);
  goto <bb 25>; [INV]

  <bb 20> :
  if (dst_ip == 0B)
    goto <bb 22>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  _13 = dst_ip->type;
  if (_13 == 0)
    goto <bb 22>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 22> :
  _14 = pcb->mcast_ip4.addr;
  if (_14 != 0)
    goto <bb 23>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 23> :
  _15 = pcb->mcast_ip4.addr;
  _16 = ip_addr_broadcast.u_addr.ip4.addr;
  if (_15 != _16)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _17 = &pcb->mcast_ip4;
  netif = ip4_route (_17);

  <bb 25> :
  if (netif == 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 26> :
  if (dst_ip != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 27> :
  _18 = dst_ip->type;
  if (_18 == 6)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  _19 = &pcb->local_ip.u_addr.ip6;
  _20 = &dst_ip->u_addr.ip6;
  iftmp.13 = ip6_route (_19, _20);
  goto <bb 30>; [INV]

  <bb 29> :
  _21 = &dst_ip->u_addr.ip4;
  iftmp.13 = ip4_route (_21);

  <bb 30> :
  netif = iftmp.13;

  <bb 31> :
  if (netif == 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  if (dst_ip != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _22 = dst_ip->type;

  <bb 34> :
  _23 = lwip_stats.udp.rterr;
  _24 = _23 + 1;
  lwip_stats.udp.rterr = _24;
  D.7822 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 35> :
  D.7822 = udp_sendto_if (pcb, p, dst_ip, dst_port, netif);

  <bb 36> :
<L42>:
  return D.7822;

}


udp_send (struct udp_pcb * pcb, struct pbuf * p)
{
  err_t D.7814;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7814 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7814 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  _1 = pcb->remote_ip.type;
  if (_1 == 46)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.7814 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  _2 = &pcb->remote_ip;
  _3 = pcb->remote_port;
  D.7814 = udp_sendto (pcb, p, _2, _3);

  <bb 9> :
<L6>:
  return D.7814;

}


udp_input (struct pbuf * p, struct netif * inp)
{
  u16_t chklen;
  u8_t for_us;
  u8_t broadcast;
  u16_t dest;
  u16_t src;
  struct udp_pcb * uncon_pcb;
  struct udp_pcb * prev;
  struct udp_pcb * pcb;
  struct udp_hdr * udphdr;
  _Bool iftmp.11;
  _Bool iftmp.10;
  int iftmp.8;
  int iftmp.7;
  u8_t iftmp.6;

  <bb 2> :
  for_us = 0;
  if (p == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (inp == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = lwip_stats.udp.recv;
  _2 = _1 + 1;
  lwip_stats.udp.recv = _2;
  _3 = p->len;
  if (_3 <= 7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _4 = lwip_stats.udp.lenerr;
  _5 = _4 + 1;
  lwip_stats.udp.lenerr = _5;
  _6 = lwip_stats.udp.drop;
  _7 = _6 + 1;
  lwip_stats.udp.drop = _7;
  _8 = lwip_stats.mib2.udpinerrors;
  _9 = _8 + 1;
  lwip_stats.mib2.udpinerrors = _9;
  pbuf_free (p);
  // predicted unlikely by goto predictor.
  goto <bb 93>; [INV]

  <bb 8> :
  udphdr = p->payload;
  _10 = ip_data.current_iphdr_dest.type;
  if (_10 != 6)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _11 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  _12 = ip_data.current_netif;
  iftmp.6 = ip4_addr_isbroadcast_u32 (_11, _12);
  goto <bb 11>; [INV]

  <bb 10> :
  iftmp.6 = 0;

  <bb 11> :
  broadcast = iftmp.6;
  _13 = udphdr->src;
  src = lwip_htons (_13);
  _14 = udphdr->dest;
  dest = lwip_htons (_14);
  _15 = ip_data.current_iphdr_dest.type;

  <bb 12> :
  _16 = ip_data.current_iphdr_src.type;

  <bb 13> :
  pcb = 0B;
  prev = 0B;
  uncon_pcb = 0B;
  pcb = udp_pcbs;
  goto <bb 54>; [INV]

  <bb 14> :
  _17 = pcb->local_ip.type;

  <bb 15> :
  _18 = pcb->remote_ip.type;

  <bb 16> :
  _19 = pcb->local_port;
  if (dest == _19)
    goto <bb 17>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 17> :
  _20 = udp_input_local_match (pcb, inp, broadcast);
  if (_20 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 18> :
  _21 = pcb->flags;
  _22 = (unsigned int) _21;
  _23 = _22 & 4;
  if (_23 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 19> :
  if (uncon_pcb == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  uncon_pcb = pcb;
  goto <bb 28>; [INV]

  <bb 21> :
  if (broadcast != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 22> :
  _24 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  if (_24 == 4294967295)
    goto <bb 23>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 23> :
  _25 = uncon_pcb->local_ip.type;
  if (_25 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  _26 = uncon_pcb->local_ip.u_addr.ip4.addr;
  _27 = &inp->ip_addr.u_addr.ip4;
  _28 = MEM[(const struct ip4_addr_t *)_27].addr;
  if (_26 != _28)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _29 = pcb->local_ip.type;
  if (_29 == 0)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  _30 = pcb->local_ip.u_addr.ip4.addr;
  _31 = &inp->ip_addr.u_addr.ip4;
  _32 = MEM[(const struct ip4_addr_t *)_31].addr;
  if (_30 == _32)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  uncon_pcb = pcb;

  <bb 28> :
  _33 = pcb->remote_port;
  if (src == _33)
    goto <bb 29>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 29> :
  _34 = pcb->remote_ip.type;
  if (_34 == 6)
    goto <bb 30>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 30> :
  _35 = pcb->remote_ip.u_addr.ip6.addr[0];
  if (_35 == 0)
    goto <bb 31>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 31> :
  _36 = pcb->remote_ip.u_addr.ip6.addr[1];
  if (_36 == 0)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _37 = pcb->remote_ip.u_addr.ip6.addr[2];
  if (_37 == 0)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  _38 = pcb->remote_ip.u_addr.ip6.addr[3];
  if (_38 == 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  iftmp.7 = 1;
  goto <bb 36>; [INV]

  <bb 35> :
  iftmp.7 = 0;

  <bb 36> :
  _39 = (_Bool) iftmp.7;
  if (_39 != 0)
    goto <bb 49>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _40 = pcb->remote_ip.u_addr.ip4.addr;
  if (_40 == 0)
    goto <bb 49>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  _41 = pcb->remote_ip.type;
  _42 = ip_data.current_iphdr_src.type;
  if (_41 == _42)
    goto <bb 39>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 39> :
  _43 = pcb->remote_ip.type;
  if (_43 == 6)
    goto <bb 40>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 40> :
  _44 = pcb->remote_ip.u_addr.ip6.addr[0];
  _45 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  if (_44 == _45)
    goto <bb 41>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 41> :
  _46 = pcb->remote_ip.u_addr.ip6.addr[1];
  _47 = ip_data.current_iphdr_src.u_addr.ip6.addr[1];
  if (_46 == _47)
    goto <bb 42>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 42> :
  _48 = pcb->remote_ip.u_addr.ip6.addr[2];
  _49 = ip_data.current_iphdr_src.u_addr.ip6.addr[2];
  if (_48 == _49)
    goto <bb 43>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 43> :
  _50 = pcb->remote_ip.u_addr.ip6.addr[3];
  _51 = ip_data.current_iphdr_src.u_addr.ip6.addr[3];
  if (_50 == _51)
    goto <bb 44>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 44> :
  _52 = pcb->remote_ip.u_addr.ip6.zone;
  _53 = ip_data.current_iphdr_src.u_addr.ip6.zone;
  if (_52 == _53)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  iftmp.8 = 1;
  goto <bb 47>; [INV]

  <bb 46> :
  iftmp.8 = 0;

  <bb 47> :
  _54 = (_Bool) iftmp.8;
  if (_54 != 0)
    goto <bb 49>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 48> :
  _55 = pcb->remote_ip.u_addr.ip4.addr;
  _56 = ip_data.current_iphdr_src.u_addr.ip4.addr;
  if (_55 == _56)
    goto <bb 49>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 49> :
  if (prev != 0B)
    goto <bb 50>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 50> :
  _57 = pcb->next;
  prev->next = _57;
  udp_pcbs.9_58 = udp_pcbs;
  pcb->next = udp_pcbs.9_58;
  udp_pcbs = pcb;
  goto <bb 52>; [INV]

  <bb 51> :
  _59 = lwip_stats.udp.cachehit;
  _60 = _59 + 1;
  lwip_stats.udp.cachehit = _60;

  <bb 52> :
  goto <bb 55>; [INV]

  <bb 53> :
  prev = pcb;
  pcb = pcb->next;

  <bb 54> :
  if (pcb != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  if (pcb == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 56> :
  pcb = uncon_pcb;

  <bb 57> :
  if (pcb != 0B)
    goto <bb 58>; [INV]
  else
    goto <bb 59>; [INV]

  <bb 58> :
  for_us = 1;
  goto <bb 63>; [INV]

  <bb 59> :
  _61 = ip_data.current_ip6_header;
  if (_61 != 0B)
    goto <bb 60>; [INV]
  else
    goto <bb 61>; [INV]

  <bb 60> :
  _62 = netif_get_ip6_addr_match (inp, &ip_data.current_iphdr_dest.u_addr.ip6);
  _63 = _62 >= 0;
  for_us = (u8_t) _63;

  <bb 61> :
  _64 = ip_data.current_ip6_header;
  if (_64 == 0B)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _65 = &inp->ip_addr.u_addr.ip4;
  _66 = MEM[(const struct ip4_addr_t *)_65].addr;
  _67 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  _68 = _66 == _67;
  for_us = (u8_t) _68;

  <bb 63> :
  if (for_us != 0)
    goto <bb 64>; [INV]
  else
    goto <bb 92>; [INV]

  <bb 64> :
  _69 = ip_data.current_ip6_header;
  if (_69 != 0B)
    goto <bb 65>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 65> :
  _70 = ip_data.current_ip6_header;
  _71 = MEM[(const struct ip6_hdr *)_70]._nexth;
  iftmp.10 = _71 == 136;
  goto <bb 67>; [INV]

  <bb 66> :
  _72 = ip_data.current_ip4_header;
  _73 = _72->_proto;
  iftmp.10 = _73 == 136;

  <bb 67> :
  if (iftmp.10 != 0)
    goto <bb 68>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 68> :
  _74 = udphdr->len;
  chklen = lwip_htons (_74);
  if (chklen <= 7)
    goto <bb 69>; [INV]
  else
    goto <bb 72>; [INV]

  <bb 69> :
  if (chklen == 0)
    goto <bb 70>; [INV]
  else
    goto <bb 71>; [INV]

  <bb 70> :
  chklen = p->tot_len;
  goto <bb 72>; [INV]

  <bb 71> :
  // predicted unlikely by goto predictor.
  goto <bb 94>; [INV]

  <bb 72> :
  _75 = p->tot_len;
  _76 = ip_chksum_pseudo_partial (p, 136, _75, chklen, &ip_data.current_iphdr_src, &ip_data.current_iphdr_dest);
  if (_76 != 0)
    goto <bb 73>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 73> :
  // predicted unlikely by goto predictor.
  goto <bb 94>; [INV]

  <bb 74> :
  _77 = udphdr->chksum;
  if (_77 != 0)
    goto <bb 75>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 75> :
  _78 = p->tot_len;
  _79 = ip_chksum_pseudo (p, 17, _78, &ip_data.current_iphdr_src, &ip_data.current_iphdr_dest);
  if (_79 != 0)
    goto <bb 76>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 76> :
  // predicted unlikely by goto predictor.
  goto <bb 94>; [INV]

  <bb 77> :
  _80 = pbuf_remove_header (p, 8);
  if (_80 != 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 78>; [INV]

  <bb 79> :
  if (pcb != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 83>; [INV]

  <bb 80> :
  _85 = lwip_stats.mib2.udpindatagrams;
  _86 = _85 + 1;
  lwip_stats.mib2.udpindatagrams = _86;
  _87 = pcb->recv;
  if (_87 != 0B)
    goto <bb 81>; [INV]
  else
    goto <bb 82>; [INV]

  <bb 81> :
  _88 = pcb->recv;
  _89 = pcb->recv_arg;
  _88 (_89, pcb, p, &ip_data.current_iphdr_src, src);
  goto <bb 93>; [INV]

  <bb 82> :
  pbuf_free (p);
  // predicted unlikely by goto predictor.
  goto <bb 93>; [INV]

  <bb 83> :
  if (broadcast == 0)
    goto <bb 84>; [INV]
  else
    goto <bb 91>; [INV]

  <bb 84> :
  _90 = ip_data.current_iphdr_dest.type;
  if (_90 == 6)
    goto <bb 85>; [INV]
  else
    goto <bb 86>; [INV]

  <bb 85> :
  _91 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _92 = _91 & 255;
  iftmp.11 = _92 != 255;
  goto <bb 87>; [INV]

  <bb 86> :
  _93 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  _94 = _93 & 240;
  iftmp.11 = _94 != 224;

  <bb 87> :
  if (iftmp.11 != 0)
    goto <bb 88>; [INV]
  else
    goto <bb 91>; [INV]

  <bb 88> :
  _95 = ip_data.current_ip_header_tot_len;
  _96 = _95 + 8;
  _97 = (short int) _96;
  pbuf_header_force (p, _97);
  _98 = ip_data.current_ip6_header;
  if (_98 != 0B)
    goto <bb 89>; [INV]
  else
    goto <bb 90>; [INV]

  <bb 89> :
  icmp6_dest_unreach (p, 4);
  goto <bb 91>; [INV]

  <bb 90> :
  icmp_dest_unreach (p, 3);

  <bb 91> :
  _99 = lwip_stats.udp.proterr;
  _100 = _99 + 1;
  lwip_stats.udp.proterr = _100;
  _101 = lwip_stats.udp.drop;
  _102 = _101 + 1;
  lwip_stats.udp.drop = _102;
  _103 = lwip_stats.mib2.udpnoports;
  _104 = _103 + 1;
  lwip_stats.mib2.udpnoports = _104;
  pbuf_free (p);
  goto <bb 93>; [INV]

  <bb 92> :
  pbuf_free (p);

  <bb 93> :
end:
  goto <bb 95>; [INV]

  <bb 94> :
chkerr:
  _105 = lwip_stats.udp.chkerr;
  _106 = _105 + 1;
  lwip_stats.udp.chkerr = _106;
  _107 = lwip_stats.udp.drop;
  _108 = _107 + 1;
  lwip_stats.udp.drop = _108;
  _109 = lwip_stats.mib2.udpinerrors;
  _110 = _109 + 1;
  lwip_stats.mib2.udpinerrors = _110;
  pbuf_free (p);

  <bb 95> :
<L127>:
  return;

}


udp_input_local_match (struct udp_pcb * pcb, struct netif * inp, u8_t broadcast)
{
  int iftmp.5;
  int iftmp.4;
  int iftmp.3;
  u8_t D.7636;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (inp == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = pcb->netif_idx;
  if (_1 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _2 = pcb->netif_idx;
  _3 = ip_data.current_input_netif;
  _4 = _3->num;
  _5 = _4 + 1;
  if (_2 != _5)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.7636 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 49>; [INV]

  <bb 9> :
  _6 = pcb->local_ip.type;
  if (_6 == 46)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.7636 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 49>; [INV]

  <bb 11> :
  _7 = pcb->local_ip.type;
  _8 = ip_data.current_iphdr_dest.type;
  if (_7 == _8)
    goto <bb 12>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 12> :
  if (broadcast != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 13> :
  _9 = &pcb->local_ip.u_addr.ip4;
  if (_9 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _10 = pcb->local_ip.u_addr.ip4.addr;
  if (_10 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  _11 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  if (_11 == 4294967295)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _12 = pcb->local_ip.u_addr.ip4.addr;
  _13 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  _14 = _12 ^ _13;
  _15 = &inp->netmask.u_addr.ip4;
  _16 = MEM[(const struct ip4_addr_t *)_15].addr;
  _17 = _14 & _16;
  if (_17 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 17> :
  D.7636 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 49>; [INV]

  <bb 18> :
  _18 = &pcb->local_ip;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 19> :
  _19 = &pcb->local_ip;
  if (_19 != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  _20 = pcb->local_ip.type;
  if (_20 == 6)
    goto <bb 21>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 21> :
  _21 = &pcb->local_ip.u_addr.ip6;
  if (_21 == 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 22> :
  _22 = pcb->local_ip.u_addr.ip6.addr[0];
  if (_22 == 0)
    goto <bb 23>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 23> :
  _23 = pcb->local_ip.u_addr.ip6.addr[1];
  if (_23 == 0)
    goto <bb 24>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 24> :
  _24 = pcb->local_ip.u_addr.ip6.addr[2];
  if (_24 == 0)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _25 = pcb->local_ip.u_addr.ip6.addr[3];
  if (_25 == 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  iftmp.3 = 1;
  goto <bb 28>; [INV]

  <bb 27> :
  iftmp.3 = 0;

  <bb 28> :
  _26 = (_Bool) iftmp.3;
  if (_26 != 0)
    goto <bb 47>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 29> :
  goto <bb 35>; [INV]

  <bb 30> :
  _27 = &pcb->local_ip.u_addr.ip4;
  if (_27 == 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 31> :
  _28 = pcb->local_ip.u_addr.ip4.addr;
  if (_28 == 0)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  iftmp.4 = 1;
  goto <bb 34>; [INV]

  <bb 33> :
  iftmp.4 = 0;

  <bb 34> :
  _29 = (_Bool) iftmp.4;
  if (_29 != 0)
    goto <bb 47>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 35> :

  <bb 36> :
  _30 = pcb->local_ip.type;
  _31 = ip_data.current_iphdr_dest.type;
  if (_30 == _31)
    goto <bb 37>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 37> :
  _32 = pcb->local_ip.type;
  if (_32 == 6)
    goto <bb 38>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 38> :
  _33 = pcb->local_ip.u_addr.ip6.addr[0];
  _34 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  if (_33 == _34)
    goto <bb 39>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 39> :
  _35 = pcb->local_ip.u_addr.ip6.addr[1];
  _36 = ip_data.current_iphdr_dest.u_addr.ip6.addr[1];
  if (_35 == _36)
    goto <bb 40>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 40> :
  _37 = pcb->local_ip.u_addr.ip6.addr[2];
  _38 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  if (_37 == _38)
    goto <bb 41>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 41> :
  _39 = pcb->local_ip.u_addr.ip6.addr[3];
  _40 = ip_data.current_iphdr_dest.u_addr.ip6.addr[3];
  if (_39 == _40)
    goto <bb 42>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 42> :
  _41 = pcb->local_ip.u_addr.ip6.zone;
  _42 = ip_data.current_iphdr_dest.u_addr.ip6.zone;
  if (_41 == _42)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  iftmp.5 = 1;
  goto <bb 45>; [INV]

  <bb 44> :
  iftmp.5 = 0;

  <bb 45> :
  _43 = (_Bool) iftmp.5;
  if (_43 != 0)
    goto <bb 47>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 46> :
  _44 = pcb->local_ip.u_addr.ip4.addr;
  _45 = ip_data.current_iphdr_dest.u_addr.ip4.addr;
  if (_44 == _45)
    goto <bb 47>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 47> :
  D.7636 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 49>; [INV]

  <bb 48> :
  D.7636 = 0;

  <bb 49> :
<L56>:
  return D.7636;

}


udp_new_port ()
{
  struct udp_pcb * pcb;
  u16_t n;
  u16_t D.7626;

  <bb 2> :
  n = 0;

  <bb 3> :
again:
  udp_port.0_1 = udp_port;
  udp_port.1_2 = udp_port.0_1;
  _3 = udp_port.1_2 + 1;
  udp_port = _3;
  if (udp_port.1_2 == 65535)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  udp_port = 49152;

  <bb 5> :
  pcb = udp_pcbs;
  goto <bb 11>; [INV]

  <bb 6> :
  _4 = pcb->local_port;
  udp_port.2_5 = udp_port;
  if (_4 == udp_port.2_5)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  n = n + 1;
  if (n > 16383)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.7626 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 9> :
  // predicted unlikely by goto predictor.
  goto <bb 3>; [INV]

  <bb 10> :
  pcb = pcb->next;

  <bb 11> :
  if (pcb != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  D.7626 = udp_port;

  <bb 13> :
<L10>:
  return D.7626;

}


udp_init ()
{
  <bb 2> :
  _1 = rand ();
  _2 = (short unsigned int) _1;
  _3 = _2 & 16383;
  _4 = _3 + 49152;
  udp_port = _4;
  return;

}


