sntp_getserver (u8_t idx)
{
  const struct ip_addr_t * D.7573;

  <bb 2> :
  if (idx == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = (int) idx;
  D.7573 = &sntp_servers[_1].addr;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.7573 = &ip_addr_any;

  <bb 5> :
<L2>:
  return D.7573;

}


sntp_setserver (u8_t idx, const struct ip_addr_t * server)
{
  <bb 2> :
  if (idx == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  if (server != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _1 = (int) idx;
  sntp_servers[_1].addr = *server;
  goto <bb 7>; [INV]

  <bb 5> :
  _2 = (int) idx;
  sntp_servers[_2].addr.u_addr.ip6.addr[0] = 0;
  _3 = (int) idx;
  sntp_servers[_3].addr.u_addr.ip6.addr[1] = 0;
  _4 = (int) idx;
  sntp_servers[_4].addr.u_addr.ip6.addr[2] = 0;
  _5 = (int) idx;
  sntp_servers[_5].addr.u_addr.ip6.addr[3] = 0;
  _6 = (int) idx;
  sntp_servers[_6].addr.u_addr.ip6.zone = 0;

  <bb 6> :
  _7 = (int) idx;
  sntp_servers[_7].addr.type = 0;

  <bb 7> :
  return;

}


sntp_getreachability (u8_t idx)
{
  u8_t D.7562;

  <bb 2> :
  if (idx == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = (int) idx;
  D.7562 = sntp_servers[_1].reachability;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.7562 = 0;

  <bb 5> :
<L2>:
  return D.7562;

}


sntp_getoperatingmode ()
{
  u8_t D.7558;

  <bb 2> :
  D.7558 = sntp_opmode;

  <bb 3> :
<L0>:
  return D.7558;

}


sntp_setoperatingmode (u8_t operating_mode)
{
  <bb 2> :
  if (operating_mode > 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  sntp_pcb.25_1 = sntp_pcb;
  if (sntp_pcb.25_1 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  sntp_opmode = operating_mode;
  return;

}


sntp_enabled ()
{
  u8_t D.7552;

  <bb 2> :
  sntp_pcb.24_1 = sntp_pcb;
  _2 = sntp_pcb.24_1 != 0B;
  D.7552 = (u8_t) _2;

  <bb 3> :
<L0>:
  return D.7552;

}


sntp_stop ()
{
  u8_t i;

  <bb 2> :
  sntp_pcb.21_1 = sntp_pcb;
  if (sntp_pcb.21_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  i = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  _2 = (int) i;
  sntp_servers[_2].reachability = 0;
  i.22_3 = i;
  i = i.22_3 + 1;

  <bb 5> :
  if (i == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  sys_untimeout (sntp_request, 0B);
  sys_untimeout (sntp_retry, 0B);
  sntp_pcb.23_4 = sntp_pcb;
  udp_remove (sntp_pcb.23_4);
  sntp_pcb = 0B;

  <bb 7> :
  return;

}


sntp_init ()
{
  <bb 2> :
  sntp_pcb.12_1 = sntp_pcb;
  if (sntp_pcb.12_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 3> :
  _2 = udp_new_ip_type (46);
  sntp_pcb = _2;
  sntp_pcb.13_3 = sntp_pcb;
  if (sntp_pcb.13_3 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 4>; [INV]

  <bb 5> :
  sntp_pcb.14_4 = sntp_pcb;
  if (sntp_pcb.14_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  sntp_pcb.15_5 = sntp_pcb;
  udp_recv (sntp_pcb.15_5, sntp_recv, 0B);
  sntp_opmode.16_6 = sntp_opmode;
  if (sntp_opmode.16_6 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  sntp_retry_timeout = 15000;
  _7 = rand ();
  _8 = (long unsigned int) _7;
  _9 = _8 % 5000;
  sys_timeout (_9, sntp_request, 0B);
  goto <bb 10>; [INV]

  <bb 8> :
  sntp_opmode.17_10 = sntp_opmode;
  if (sntp_opmode.17_10 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  sntp_pcb.18_11 = sntp_pcb;
  _12 = sntp_pcb.18_11->so_options;
  sntp_pcb.19_13 = sntp_pcb;
  _14 = _12 | 32;
  sntp_pcb.19_13->so_options = _14;
  sntp_pcb.20_15 = sntp_pcb;
  udp_bind (sntp_pcb.20_15, &ip_addr_any_type, 123);

  <bb 10> :
  return;

}


sntp_request (void * arg)
{
  err_t err;
  struct ip_addr_t sntp_server_address;
  int iftmp.11;
  _Bool iftmp.10;
  err_t iftmp.9;

  <bb 2> :
  sntp_server_address = sntp_servers[0].addr;
  _1 = sntp_server_address.type;
  if (_1 == 6)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 3> :
  _2 = sntp_server_address.u_addr.ip6.addr[0];
  if (_2 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _3 = sntp_server_address.u_addr.ip6.addr[1];
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _4 = sntp_server_address.u_addr.ip6.addr[2];
  if (_4 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _5 = sntp_server_address.u_addr.ip6.addr[3];
  if (_5 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  iftmp.11 = 1;
  goto <bb 9>; [INV]

  <bb 8> :
  iftmp.11 = 0;

  <bb 9> :
  iftmp.10 = (_Bool) iftmp.11;
  goto <bb 11>; [INV]

  <bb 10> :
  _6 = sntp_server_address.u_addr.ip4.addr;
  iftmp.10 = _6 == 0;

  <bb 11> :
  if (iftmp.10 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  iftmp.9 = -16;
  goto <bb 14>; [INV]

  <bb 13> :
  iftmp.9 = 0;

  <bb 14> :
  err = iftmp.9;
  if (err == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  sntp_send_request (&sntp_server_address);
  goto <bb 17>; [INV]

  <bb 16> :
  sys_untimeout (sntp_retry, 0B);
  sys_timeout (15000, sntp_retry, 0B);

  <bb 17> :
  sntp_server_address = {CLOBBER};
  return;

}


sntp_send_request (const struct ip_addr_t * server_addr)
{
  struct sntp_msg * sntpmsg;
  struct pbuf * p;

  <bb 2> :
  if (server_addr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  p = pbuf_alloc (74, 48, 640);
  if (p != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  sntpmsg = p->payload;
  sntp_initialize_request (sntpmsg);
  sntp_pcb.8_1 = sntp_pcb;
  udp_sendto (sntp_pcb.8_1, p, server_addr, 123);
  pbuf_free (p);
  _2 = sntp_servers[0].reachability;
  _3 = _2 << 1;
  sntp_servers[0].reachability = _3;
  sys_untimeout (sntp_retry, 0B);
  sys_timeout (15000, sntp_retry, 0B);
  goto <bb 7>; [INV]

  <bb 6> :
  sys_untimeout (sntp_request, 0B);
  sys_timeout (15000, sntp_request, 0B);

  <bb 7> :
  return;

}


sntp_recv (void * arg, struct udp_pcb * pcb, struct pbuf * p, const struct ip_addr_t * addr, u16_t port)
{
  u32_t sntp_update_delay;
  err_t err;
  u8_t stratum;
  u8_t mode;
  struct sntp_timestamps timestamps;

  <bb 2> :
  err = -16;
  _1 = p->tot_len;
  if (_1 == 48)
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 3> :
  _2 = pbuf_get_at (p, 0);
  mode = _2 & 7;
  sntp_opmode.4_3 = sntp_opmode;
  if (sntp_opmode.4_3 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  if (mode == 4)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  sntp_opmode.5_4 = sntp_opmode;
  if (sntp_opmode.5_4 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  if (mode == 5)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  stratum = pbuf_get_at (p, 1);
  if (stratum == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  err = 1;
  goto <bb 10>; [INV]

  <bb 9> :
  pbuf_copy_partial (p, &timestamps, 8, 40);
  err = 0;

  <bb 10> :
  goto <bb 12>; [INV]

  <bb 11> :
  err = -3;

  <bb 12> :

  <bb 13> :
  pbuf_free (p);
  if (err == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  sntp_process (&timestamps);
  _5 = sntp_servers[0].reachability;
  _6 = _5 | 1;
  sntp_servers[0].reachability = _6;
  sntp_opmode.6_7 = sntp_opmode;
  if (sntp_opmode.6_7 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 15> :
  sys_untimeout (sntp_retry, 0B);
  sys_untimeout (sntp_request, 0B);
  sntp_retry_timeout = 15000;
  sntp_update_delay = 3600000;
  sys_timeout (sntp_update_delay, sntp_request, 0B);
  goto <bb 19>; [INV]

  <bb 16> :
  if (err == 1)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 17> :
  sntp_opmode.7_8 = sntp_opmode;
  if (sntp_opmode.7_8 == 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  sntp_retry (0B);

  <bb 19> :
  timestamps = {CLOBBER};
  return;

}


sntp_retry (void * arg)
{
  u32_t new_retry_timeout;

  <bb 2> :
  sys_untimeout (sntp_request, 0B);
  sntp_retry_timeout.1_1 = sntp_retry_timeout;
  sys_timeout (sntp_retry_timeout.1_1, sntp_request, 0B);
  sntp_retry_timeout.2_2 = sntp_retry_timeout;
  new_retry_timeout = sntp_retry_timeout.2_2 << 1;
  if (new_retry_timeout <= 150000)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  sntp_retry_timeout.3_3 = sntp_retry_timeout;
  if (new_retry_timeout > sntp_retry_timeout.3_3)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  sntp_retry_timeout = new_retry_timeout;
  goto <bb 6>; [INV]

  <bb 5> :
  sntp_retry_timeout = 150000;

  <bb 6> :
  return;

}


sntp_initialize_request (struct sntp_msg * req)
{
  <bb 2> :
  memset (req, 0, 48);
  req->li_vn_mode = 35;
  return;

}


sntp_process (const struct sntp_timestamps * timestamps)
{
  u32_t frac;
  s32_t sec;

  <bb 2> :
  _1 = timestamps->xmit.sec;
  _2 = lwip_htonl (_1);
  sec = (s32_t) _2;
  _3 = timestamps->xmit.frac;
  frac = lwip_htonl (_3);
  sec.0_4 = (long unsigned int) sec;
  return;

}


