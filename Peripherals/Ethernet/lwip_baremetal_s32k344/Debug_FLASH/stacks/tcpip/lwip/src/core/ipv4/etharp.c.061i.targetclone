etharp_request (struct netif * netif, const struct ip4_addr_t * ipaddr)
{
  err_t D.7729;
  err_t _5;

  <bb 2> :
  _5 = etharp_request_dst (netif_2(D), ipaddr_3(D), &ethbroadcast);

  <bb 3> :
<L0>:
  return _5;

}


etharp_request_dst (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct eth_addr * hw_dst_addr)
{
  err_t D.7727;
  u8_t[6] * _1;
  u8_t[6] * _2;
  struct ip4_addr_t * _3;
  err_t _9;

  <bb 2> :
  _1 = &netif_4(D)->hwaddr;
  _2 = &netif_4(D)->hwaddr;
  _3 = &netif_4(D)->ip_addr.u_addr.ip4;
  _9 = etharp_raw (netif_4(D), _1, hw_dst_addr_6(D), _2, _3, &ethzero, ipaddr_7(D), 1);

  <bb 3> :
<L0>:
  return _9;

}


etharp_raw (struct netif * netif, const struct eth_addr * ethsrc_addr, const struct eth_addr * ethdst_addr, const struct eth_addr * hwsrc_addr, const struct ip4_addr_t * ipsrc_addr, const struct eth_addr * hwdst_addr, const struct ip4_addr_t * ipdst_addr, const u16_t opcode)
{
  unsigned int D.7726;
  unsigned int D.7725;
  struct etharp_hdr * hdr;
  err_t result;
  struct pbuf * p;
  err_t D.7719;
  short unsigned int _1;
  short unsigned int _2;
  short unsigned int _3;
  short unsigned int _4;
  unsigned char _5;
  struct eth_addr * _6;
  struct eth_addr * _7;
  struct ip4_addr_wordaligned * _8;
  struct ip4_addr_wordaligned * _9;
  short unsigned int _10;
  short unsigned int _11;
  err_t _12;
  unsigned int _31;
  unsigned int _34;
  err_t _46;
  err_t _50;

  <bb 2> :
  result_17 = 0;
  if (netif_18(D) == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  p_21 = pbuf_alloc (14, 28, 640);
  if (p_21 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = lwip_stats.etharp.memerr;
  _2 = _1 + 1;
  lwip_stats.etharp.memerr = _2;
  _50 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 6> :
  _3 = p_21->len;
  if (_3 <= 27)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  hdr_22 = p_21->payload;
  _4 = lwip_htons (opcode_23(D));
  hdr_22->opcode = _4;
  _5 = netif_18(D)->hwaddr_len;
  if (_5 != 6)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  _6 = &hdr_22->shwaddr;
  memcpy (_6, hwsrc_addr_26(D), 6);
  _7 = &hdr_22->dhwaddr;
  memcpy (_7, hwdst_addr_28(D), 6);
  _8 = &hdr_22->sipaddr;
  _31 = MEM <unsigned int> [(char * {ref-all})ipsrc_addr_30(D)];
  MEM <unsigned int> [(char * {ref-all})_8] = _31;
  _9 = &hdr_22->dipaddr;
  _34 = MEM <unsigned int> [(char * {ref-all})ipdst_addr_33(D)];
  MEM <unsigned int> [(char * {ref-all})_9] = _34;
  hdr_22->hwtype = 256;
  hdr_22->proto = 8;
  hdr_22->hwlen = 6;
  hdr_22->protolen = 4;
  ethernet_output (netif_18(D), p_21, ethsrc_addr_40(D), ethdst_addr_41(D), 2054);
  _10 = lwip_stats.etharp.xmit;
  _11 = _10 + 1;
  lwip_stats.etharp.xmit = _11;
  pbuf_free (p_21);
  p_45 = 0B;
  _46 = result_17;

  <bb 11> :
  # _12 = PHI <_50(5), _46(10)>
<L11>:
  return _12;

}


etharp_query (struct netif * netif, const struct ip4_addr_t * ipaddr, struct pbuf * q)
{
  struct etharp_q_entry * old;
  struct etharp_q_entry * r;
  unsigned int qlen;
  struct etharp_q_entry * new_entry;
  int copy_needed;
  struct pbuf * p;
  netif_addr_idx_t i;
  s16_t i_err;
  int is_new_entry;
  err_t result;
  struct eth_addr * srcaddr;
  err_t D.7662;
  long unsigned int _1;
  unsigned char _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  short unsigned int _6;
  short unsigned int _7;
  short unsigned int i_err.7_8;
  int _9;
  unsigned char _10;
  int _11;
  int _12;
  int _13;
  unsigned char _14;
  int _15;
  unsigned char _16;
  int _17;
  unsigned char _18;
  int _19;
  int _20;
  unsigned char _21;
  int _22;
  struct eth_addr * _23;
  int _24;
  unsigned char _25;
  short unsigned int _26;
  short unsigned int _27;
  struct pbuf * _28;
  unsigned char _29;
  int _30;
  int _31;
  int _32;
  struct etharp_q_entry * _33;
  int _34;
  struct etharp_q_entry * _35;
  int _36;
  int _37;
  int _38;
  struct etharp_q_entry * _39;
  int _40;
  struct etharp_q_entry * _41;
  struct pbuf * _42;
  short unsigned int _43;
  short unsigned int _44;
  err_t _54;
  err_t _86;
  err_t _119;
  err_t _123;
  err_t _124;

  <bb 2> :
  srcaddr_69 = &netif_68(D)->hwaddr;
  result_70 = -1;
  is_new_entry_71 = 0;
  _1 = ipaddr_73(D)->addr;
  _2 = ip4_addr_isbroadcast_u32 (_1, netif_68(D));
  if (_2 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _3 = ipaddr_73(D)->addr;
  _4 = _3 & 240;
  if (_4 == 224)
    goto <bb 6>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  if (ipaddr_73(D) == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _5 = ipaddr_73(D)->addr;
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _124 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 56>; [INV]

  <bb 7> :
  i_err_76 = etharp_find_entry (ipaddr_73(D), 1, netif_68(D));
  if (i_err_76 < 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  if (q_82(D) != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = lwip_stats.etharp.memerr;
  _7 = _6 + 1;
  lwip_stats.etharp.memerr = _7;

  <bb 10> :
  _123 = (err_t) i_err_76;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 56>; [INV]

  <bb 11> :
  i_err.7_8 = (short unsigned int) i_err_76;
  if (i_err.7_8 > 126)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 12>; [INV]

  <bb 13> :
  i_77 = (netif_addr_idx_t) i_err_76;
  _9 = (int) i_77;
  _10 = arp_table[_9].state;
  if (_10 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  is_new_entry_78 = 1;
  _11 = (int) i_77;
  arp_table[_11].state = 1;
  _12 = (int) i_77;
  arp_table[_12].netif = netif_68(D);

  <bb 15> :
  # is_new_entry_47 = PHI <is_new_entry_71(13), is_new_entry_78(14)>
  _13 = (int) i_77;
  _14 = arp_table[_13].state;
  if (_14 != 1)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _15 = (int) i_77;
  _16 = arp_table[_15].state;
  if (_16 <= 1)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 17>; [INV]

  <bb 18> :
  if (is_new_entry_47 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  if (q_82(D) == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 20> :
  result_84 = etharp_request (netif_68(D), ipaddr_73(D));
  if (result_84 != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  _17 = (int) i_77;
  _18 = arp_table[_17].state;
  if (_18 == 1)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 22> :
  if (is_new_entry_47 == 0)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _19 = (int) i_77;
  arp_table[_19].ctime = 0;

  <bb 24> :
  if (q_82(D) == 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  _86 = result_84;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 56>; [INV]

  <bb 26> :
  # result_45 = PHI <result_70(19), result_84(24)>
  if (q_82(D) == 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 27>; [INV]

  <bb 28> :
  _20 = (int) i_77;
  _21 = arp_table[_20].state;
  if (_21 > 1)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  etharp_cached_entry = i_77;
  _22 = (int) i_77;
  _23 = &arp_table[_22].ethaddr;
  result_118 = ethernet_output (netif_68(D), q_82(D), srcaddr_69, _23, 2048);
  goto <bb 55>; [INV]

  <bb 30> :
  _24 = (int) i_77;
  _25 = arp_table[_24].state;
  if (_25 == 1)
    goto <bb 31>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 31> :
  copy_needed_87 = 0;
  p_88 = q_82(D);
  goto <bb 38>; [INV]

  <bb 32> :
  _26 = p_48->len;
  _27 = p_48->tot_len;
  if (_26 == _27)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  _28 = p_48->next;
  if (_28 != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 34>; [INV]

  <bb 35> :
  _29 = p_48->type_internal;
  _30 = (int) _29;
  _31 = _30 & 64;
  if (_31 != 0)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  copy_needed_91 = 1;
  goto <bb 39>; [INV]

  <bb 37> :
  p_90 = p_48->next;

  <bb 38> :
  # p_48 = PHI <p_88(31), p_90(37)>
  if (p_48 != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 39> :
  # copy_needed_50 = PHI <copy_needed_91(36), copy_needed_87(38)>
  if (copy_needed_50 != 0)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  p_95 = pbuf_clone (14, 640, q_82(D));
  goto <bb 42>; [INV]

  <bb 41> :
  p_92 = q_82(D);
  pbuf_ref (p_92);

  <bb 42> :
  # p_49 = PHI <p_95(40), p_92(41)>
  if (p_49 != 0B)
    goto <bb 43>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 43> :
  new_entry_99 = memp_malloc (7);
  if (new_entry_99 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 44> :
  qlen_102 = 0;
  new_entry_99->next = 0B;
  new_entry_99->p = p_49;
  _32 = (int) i_77;
  _33 = arp_table[_32].q;
  if (_33 != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 45> :
  _34 = (int) i_77;
  r_106 = arp_table[_34].q;
  qlen_107 = qlen_102 + 1;
  goto <bb 47>; [INV]

  <bb 46> :
  r_109 = r_53->next;
  qlen_110 = qlen_51 + 1;

  <bb 47> :
  # qlen_51 = PHI <qlen_107(45), qlen_110(46)>
  # r_53 = PHI <r_106(45), r_109(46)>
  _35 = r_53->next;
  if (_35 != 0B)
    goto <bb 46>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 48> :
  r_53->next = new_entry_99;
  goto <bb 50>; [INV]

  <bb 49> :
  _36 = (int) i_77;
  arp_table[_36].q = new_entry_99;

  <bb 50> :
  # qlen_52 = PHI <qlen_51(48), qlen_102(49)>
  if (qlen_52 > 2)
    goto <bb 51>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 51> :
  _37 = (int) i_77;
  old_111 = arp_table[_37].q;
  _38 = (int) i_77;
  _39 = arp_table[_38].q;
  _40 = (int) i_77;
  _41 = _39->next;
  arp_table[_40].q = _41;
  _42 = old_111->p;
  pbuf_free (_42);
  memp_free (7, old_111);

  <bb 52> :
  result_115 = 0;
  goto <bb 55>; [INV]

  <bb 53> :
  pbuf_free (p_49);
  result_101 = -1;
  goto <bb 55>; [INV]

  <bb 54> :
  _43 = lwip_stats.etharp.memerr;
  _44 = _43 + 1;
  lwip_stats.etharp.memerr = _44;
  result_97 = -1;

  <bb 55> :
  # result_46 = PHI <result_118(29), result_45(30), result_101(53), result_97(54), result_115(52)>
  _119 = result_46;

  <bb 56> :
  # _54 = PHI <_124(6), _123(10), _86(25), _119(55)>
<L66>:
  return _54;

}


etharp_output (struct netif * netif, struct pbuf * q, const struct ip4_addr_t * ipaddr)
{
  netif_addr_idx_t i;
  const struct ip4_addr_t * dst_addr;
  struct eth_addr mcastaddr;
  const struct eth_addr * dest;
  err_t D.7642;
  long unsigned int _1;
  unsigned char _2;
  long unsigned int _3;
  long unsigned int _4;
  const u32_t * _5;
  const u8_t * _6;
  unsigned char _7;
  unsigned char _8;
  const u32_t * _9;
  const u8_t * _10;
  unsigned char _11;
  const u32_t * _12;
  const u8_t * _13;
  unsigned char _14;
  long unsigned int _15;
  struct ip4_addr_t * _16;
  long unsigned int _17;
  long unsigned int _18;
  struct ip4_addr_t * _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;
  struct ip4_addr_t * _24;
  long unsigned int _25;
  unsigned char etharp_cached_entry.2_26;
  int _27;
  unsigned char _28;
  unsigned char etharp_cached_entry.3_29;
  int _30;
  struct netif * _31;
  long unsigned int _32;
  unsigned char etharp_cached_entry.4_33;
  int _34;
  long unsigned int _35;
  short unsigned int _36;
  short unsigned int _37;
  unsigned char etharp_cached_entry.5_38;
  int _39;
  unsigned char _40;
  int _41;
  struct netif * _42;
  long unsigned int _43;
  int _44;
  long unsigned int _45;
  unsigned char i.6_46;
  u8_t[6] * _47;
  err_t _51;
  err_t _63;
  err_t _67;
  err_t _70;
  err_t _73;
  err_t _84;

  <bb 2> :
  dst_addr_58 = ipaddr_57(D);
  if (netif_59(D) == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (q_61(D) == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  if (ipaddr_57(D) == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  _1 = ipaddr_57(D)->addr;
  _2 = ip4_addr_isbroadcast_u32 (_1, netif_59(D));
  if (_2 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  dest_82 = &ethbroadcast;
  goto <bb 29>; [INV]

  <bb 10> :
  _3 = ipaddr_57(D)->addr;
  _4 = _3 & 240;
  if (_4 == 224)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  mcastaddr.addr[0] = 1;
  mcastaddr.addr[1] = 0;
  mcastaddr.addr[2] = 94;
  _5 = &ipaddr_57(D)->addr;
  _6 = _5 + 1;
  _7 = *_6;
  _8 = _7 & 127;
  mcastaddr.addr[3] = _8;
  _9 = &ipaddr_57(D)->addr;
  _10 = _9 + 2;
  _11 = *_10;
  mcastaddr.addr[4] = _11;
  _12 = &ipaddr_57(D)->addr;
  _13 = _12 + 3;
  _14 = *_13;
  mcastaddr.addr[5] = _14;
  dest_81 = &mcastaddr;
  goto <bb 29>; [INV]

  <bb 12> :
  _15 = ipaddr_57(D)->addr;
  _16 = &netif_59(D)->ip_addr.u_addr.ip4;
  _17 = MEM[(const struct ip4_addr_t *)_16].addr;
  _18 = _15 ^ _17;
  _19 = &netif_59(D)->netmask.u_addr.ip4;
  _20 = MEM[(const struct ip4_addr_t *)_19].addr;
  _21 = _18 & _20;
  if (_21 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  _22 = ipaddr_57(D)->addr;
  _23 = _22 & 65535;
  if (_23 != 65193)
    goto <bb 14>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 14> :
  _24 = &netif_59(D)->gw.u_addr.ip4;
  _25 = MEM[(const struct ip4_addr_t *)_24].addr;
  if (_25 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  dst_addr_64 = &netif_59(D)->gw.u_addr.ip4;
  goto <bb 17>; [INV]

  <bb 16> :
  _63 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 17> :
  # dst_addr_49 = PHI <dst_addr_58(12), dst_addr_58(13), dst_addr_64(15)>
  etharp_cached_entry.2_26 = etharp_cached_entry;
  _27 = (int) etharp_cached_entry.2_26;
  _28 = arp_table[_27].state;
  if (_28 > 1)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  etharp_cached_entry.3_29 = etharp_cached_entry;
  _30 = (int) etharp_cached_entry.3_29;
  _31 = arp_table[_30].netif;
  if (netif_59(D) == _31)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _32 = dst_addr_49->addr;
  etharp_cached_entry.4_33 = etharp_cached_entry;
  _34 = (int) etharp_cached_entry.4_33;
  _35 = arp_table[_34].ipaddr.addr;
  if (_32 == _35)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _36 = lwip_stats.etharp.cachehit;
  _37 = _36 + 1;
  lwip_stats.etharp.cachehit = _37;
  etharp_cached_entry.5_38 = etharp_cached_entry;
  _67 = etharp_output_to_arp_index (netif_59(D), q_61(D), etharp_cached_entry.5_38);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 21> :
  i_68 = 0;
  goto <bb 27>; [INV]

  <bb 22> :
  _39 = (int) i_50;
  _40 = arp_table[_39].state;
  if (_40 > 1)
    goto <bb 23>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 23> :
  _41 = (int) i_50;
  _42 = arp_table[_41].netif;
  if (netif_59(D) == _42)
    goto <bb 24>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 24> :
  _43 = dst_addr_49->addr;
  _44 = (int) i_50;
  _45 = arp_table[_44].ipaddr.addr;
  if (_43 == _45)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  etharp_cached_entry = i_50;
  _73 = etharp_output_to_arp_index (netif_59(D), q_61(D), i_50);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 26> :
  i.6_46 = i_50;
  i_74 = i.6_46 + 1;

  <bb 27> :
  # i_50 = PHI <i_68(21), i_74(26)>
  if (i_50 <= 9)
    goto <bb 22>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  _70 = etharp_query (netif_59(D), dst_addr_49, q_61(D));
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 29> :
  # dest_48 = PHI <dest_82(9), dest_81(11)>
  _47 = &netif_59(D)->hwaddr;
  _84 = ethernet_output (netif_59(D), q_61(D), _47, dest_48, 2048);

  <bb 30> :
  # _51 = PHI <_63(16), _67(20), _73(25), _70(28), _84(29)>
  mcastaddr ={v} {CLOBBER};

  <bb 31> :
<L38>:
  return _51;

}


etharp_output_to_arp_index (struct netif * netif, struct pbuf * q, netif_addr_idx_t arp_idx)
{
  err_t D.7621;
  int _1;
  unsigned char _2;
  int _3;
  unsigned char _4;
  int _5;
  short unsigned int _6;
  int _7;
  struct ip4_addr_t * _8;
  signed char _9;
  int _10;
  int _11;
  short unsigned int _12;
  int _13;
  struct ip4_addr_t * _14;
  int _15;
  struct eth_addr * _16;
  signed char _17;
  int _18;
  u8_t[6] * _19;
  int _20;
  struct eth_addr * _21;
  err_t _33;

  <bb 2> :
  _1 = (int) arp_idx_24(D);
  _2 = arp_table[_1].state;
  if (_2 <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _3 = (int) arp_idx_24(D);
  _4 = arp_table[_3].state;
  if (_4 == 2)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  _5 = (int) arp_idx_24(D);
  _6 = arp_table[_5].ctime;
  if (_6 > 284)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _7 = (int) arp_idx_24(D);
  _8 = &arp_table[_7].ipaddr;
  _9 = etharp_request (netif_26(D), _8);
  if (_9 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  _10 = (int) arp_idx_24(D);
  arp_table[_10].state = 3;
  goto <bb 11>; [INV]

  <bb 8> :
  _11 = (int) arp_idx_24(D);
  _12 = arp_table[_11].ctime;
  if (_12 > 269)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _13 = (int) arp_idx_24(D);
  _14 = &arp_table[_13].ipaddr;
  _15 = (int) arp_idx_24(D);
  _16 = &arp_table[_15].ethaddr;
  _17 = etharp_request_dst (netif_26(D), _14, _16);
  if (_17 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _18 = (int) arp_idx_24(D);
  arp_table[_18].state = 3;

  <bb 11> :
  _19 = &netif_26(D)->hwaddr;
  _20 = (int) arp_idx_24(D);
  _21 = &arp_table[_20].ethaddr;
  _33 = ethernet_output (netif_26(D), q_31(D), _19, _21, 2048);

  <bb 12> :
<L14>:
  return _33;

}


etharp_input (struct pbuf * p, struct netif * netif)
{
  unsigned int D.7605;
  unsigned int D.7604;
  u8_t for_us;
  struct ip4_addr_t dipaddr;
  struct ip4_addr_t sipaddr;
  struct etharp_hdr * hdr;
  u8_t iftmp.1;
  short unsigned int _1;
  unsigned char _2;
  unsigned char _3;
  short unsigned int _4;
  short unsigned int _5;
  short unsigned int _6;
  short unsigned int _7;
  short unsigned int _8;
  short unsigned int _9;
  short unsigned int _10;
  struct ip4_addr_wordaligned * _11;
  struct ip4_addr_wordaligned * _12;
  struct ip4_addr_t * _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ip4_addr_t * _16;
  long unsigned int _17;
  _Bool _18;
  struct eth_addr * _19;
  short unsigned int _20;
  int _21;
  u8_t[6] * _22;
  struct eth_addr * _23;
  u8_t[6] * _24;
  struct ip4_addr_t * _25;
  struct eth_addr * _26;
  struct ip4_addr_t * _27;
  long unsigned int _28;
  short unsigned int _29;
  short unsigned int _30;
  u8_t iftmp.1_32;
  unsigned int _42;
  unsigned int _44;
  u8_t iftmp.1_48;
  u8_t iftmp.1_49;

  <bb 2> :
  if (netif_37(D) == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 4> :
  hdr_40 = p_39(D)->payload;
  _1 = hdr_40->hwtype;
  if (_1 != 256)
    goto <bb 8>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _2 = hdr_40->hwlen;
  if (_2 != 6)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _3 = hdr_40->protolen;
  if (_3 != 4)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _4 = hdr_40->proto;
  if (_4 != 8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _5 = lwip_stats.etharp.proterr;
  _6 = _5 + 1;
  lwip_stats.etharp.proterr = _6;
  _7 = lwip_stats.etharp.drop;
  _8 = _7 + 1;
  lwip_stats.etharp.drop = _8;
  pbuf_free (p_39(D));
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 9> :
  _9 = lwip_stats.etharp.recv;
  _10 = _9 + 1;
  lwip_stats.etharp.recv = _10;
  _11 = &hdr_40->sipaddr;
  _42 = MEM <unsigned int> [(char * {ref-all})_11];
  MEM <unsigned int> [(char * {ref-all})&sipaddr] = _42;
  _12 = &hdr_40->dipaddr;
  _44 = MEM <unsigned int> [(char * {ref-all})_12];
  MEM <unsigned int> [(char * {ref-all})&dipaddr] = _44;
  _13 = &netif_37(D)->ip_addr.u_addr.ip4;
  _14 = MEM[(const struct ip4_addr_t *)_13].addr;
  if (_14 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  for_us_47 = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  _15 = dipaddr.addr;
  _16 = &netif_37(D)->ip_addr.u_addr.ip4;
  _17 = MEM[(const struct ip4_addr_t *)_16].addr;
  _18 = _15 == _17;
  for_us_46 = (u8_t) _18;

  <bb 12> :
  # for_us_31 = PHI <for_us_47(10), for_us_46(11)>
  _19 = &hdr_40->shwaddr;
  if (for_us_31 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  iftmp.1_49 = 1;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.1_48 = 2;

  <bb 15> :
  # iftmp.1_32 = PHI <iftmp.1_49(13), iftmp.1_48(14)>
  etharp_update_arp_entry (netif_37(D), &sipaddr, _19, iftmp.1_32);
  _20 = hdr_40->opcode;
  _21 = (int) _20;
  switch (_21) <default: <L21> [INV], case 256: <L13> [INV], case 512: <L20> [INV]>

  <bb 16> :
<L13>:
  if (for_us_31 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _22 = &netif_37(D)->hwaddr;
  _23 = &hdr_40->shwaddr;
  _24 = &netif_37(D)->hwaddr;
  _25 = &netif_37(D)->ip_addr.u_addr.ip4;
  _26 = &hdr_40->shwaddr;
  etharp_raw (netif_37(D), _22, _23, _24, _25, _26, &sipaddr, 2);
  goto <bb 19>; [INV]

  <bb 18> :
  _27 = &netif_37(D)->ip_addr.u_addr.ip4;
  _28 = MEM[(const struct ip4_addr_t *)_27].addr;

  <bb 19> :
  goto <bb 22>; [INV]

  <bb 20> :
<L20>:
  goto <bb 22>; [INV]

  <bb 21> :
<L21>:
  _29 = lwip_stats.etharp.err;
  _30 = _29 + 1;
  lwip_stats.etharp.err = _30;

  <bb 22> :
  pbuf_free (p_39(D));
  sipaddr ={v} {CLOBBER};
  dipaddr ={v} {CLOBBER};
  goto <bb 24>; [INV]

  <bb 23> :
  sipaddr ={v} {CLOBBER};
  dipaddr ={v} {CLOBBER};

  <bb 24> :
<L25>:
  return;

}


etharp_get_entry (size_t i, struct ip4_addr_t * * ipaddr, struct netif * * netif, struct eth_addr * * eth_ret)
{
  int D.7581;
  unsigned char _1;
  struct ip4_addr_t * _2;
  struct netif * _3;
  struct eth_addr * _4;
  int _5;
  int _18;
  int _19;

  <bb 2> :
  if (ipaddr_10(D) == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (netif_12(D) == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  if (eth_ret_13(D) == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  if (i_14(D) <= 9)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _1 = arp_table[i_14(D)].state;
  if (_1 > 1)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _2 = &arp_table[i_14(D)].ipaddr;
  *ipaddr_10(D) = _2;
  _3 = arp_table[i_14(D)].netif;
  *netif_12(D) = _3;
  _4 = &arp_table[i_14(D)].ethaddr;
  *eth_ret_13(D) = _4;
  _18 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 11> :
  _19 = 0;
  // predicted unlikely by early return (on trees) predictor.

  <bb 12> :
  # _5 = PHI <_18(10), _19(11)>
<L12>:
  return _5;

}


etharp_find_addr (struct netif * netif, const struct ip4_addr_t * ipaddr, struct eth_addr * * eth_ret, const struct ip4_addr_t * * ip_ret)
{
  s16_t i;
  ssize_t D.7570;
  int _1;
  unsigned char _2;
  int _3;
  struct eth_addr * _4;
  int _5;
  struct ip4_addr_t * _6;
  ssize_t _7;
  ssize_t _19;
  ssize_t _20;

  <bb 2> :
  if (eth_ret_10(D) == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (ip_ret_12(D) == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 4>; [INV]

  <bb 5> :
  i_16 = etharp_find_entry (ipaddr_13(D), 2, netif_14(D));
  if (i_16 >= 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _1 = (int) i_16;
  _2 = arp_table[_1].state;
  if (_2 > 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _3 = (int) i_16;
  _4 = &arp_table[_3].ethaddr;
  *eth_ret_10(D) = _4;
  _5 = (int) i_16;
  _6 = &arp_table[_5].ipaddr;
  *ip_ret_12(D) = _6;
  _19 = (ssize_t) i_16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  _20 = -1;

  <bb 9> :
  # _7 = PHI <_19(7), _20(8)>
<L8>:
  return _7;

}


etharp_cleanup_netif (struct netif * netif)
{
  u8_t state;
  int i;
  struct netif * _1;

  <bb 2> :
  i_5 = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  state_7 = arp_table[i_2].state;
  if (state_7 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _1 = arp_table[i_2].netif;
  if (netif_8(D) == _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  etharp_free_entry (i_2);

  <bb 6> :
  i_10 = i_2 + 1;

  <bb 7> :
  # i_2 = PHI <i_5(2), i_10(6)>
  if (i_2 <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  return;

}


etharp_update_arp_entry (struct netif * netif, const struct ip4_addr_t * ipaddr, struct eth_addr * ethaddr, u8_t flags)
{
  struct etharp_q_entry * q;
  struct pbuf * p;
  s16_t i;
  err_t D.7555;
  unsigned char _1;
  long unsigned int _2;
  long unsigned int _3;
  unsigned char _4;
  long unsigned int _5;
  long unsigned int _6;
  int _7;
  int _8;
  int _9;
  struct eth_addr * _10;
  int _11;
  int _12;
  int _13;
  struct etharp_q_entry * _14;
  u8_t[6] * _15;
  int _16;
  struct etharp_q_entry * _17;
  err_t _18;
  err_t _35;
  err_t _42;
  err_t _43;

  <bb 2> :
  _1 = netif_24(D)->hwaddr_len;
  if (_1 != 6)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (ipaddr_25(D) == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _2 = ipaddr_25(D)->addr;
  if (_2 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _3 = ipaddr_25(D)->addr;
  _4 = ip4_addr_isbroadcast_u32 (_3, netif_24(D));
  if (_4 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ipaddr_25(D)->addr;
  _6 = _5 & 240;
  if (_6 == 224)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _43 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 9> :
  i_29 = etharp_find_entry (ipaddr_25(D), flags_27(D), netif_24(D));
  if (i_29 < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _42 = (err_t) i_29;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 11> :
  _7 = (int) i_29;
  arp_table[_7].state = 2;
  _8 = (int) i_29;
  arp_table[_8].netif = netif_24(D);
  _9 = (int) i_29;
  _10 = &arp_table[_9].ethaddr;
  memcpy (_10, ethaddr_32(D), 6);
  _11 = (int) i_29;
  arp_table[_11].ctime = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  _12 = (int) i_29;
  q_36 = arp_table[_12].q;
  _13 = (int) i_29;
  _14 = q_36->next;
  arp_table[_13].q = _14;
  p_38 = q_36->p;
  memp_free (7, q_36);
  _15 = &netif_24(D)->hwaddr;
  ethernet_output (netif_24(D), p_38, _15, ethaddr_32(D), 2048);
  pbuf_free (p_38);

  <bb 13> :
  _16 = (int) i_29;
  _17 = arp_table[_16].q;
  if (_17 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _35 = 0;

  <bb 15> :
  # _18 = PHI <_43(8), _42(10), _35(14)>
<L13>:
  return _18;

}


etharp_find_entry (const struct ip4_addr_t * ipaddr, u8_t flags, struct netif * netif)
{
  u8_t state;
  u16_t age_stable;
  u16_t age_pending;
  u16_t age_queue;
  s16_t old_queue;
  s16_t i;
  s16_t empty;
  s16_t old_stable;
  s16_t old_pending;
  s16_t D.7506;
  int _1;
  long unsigned int _2;
  int _3;
  long unsigned int _4;
  int _5;
  struct netif * _6;
  int _7;
  struct etharp_q_entry * _8;
  int _9;
  short unsigned int _10;
  int _11;
  int _12;
  short unsigned int _13;
  int _14;
  int _15;
  short unsigned int _16;
  int _17;
  unsigned short i.0_18;
  unsigned short _19;
  int _20;
  int _21;
  int _22;
  int _23;
  int _24;
  struct etharp_q_entry * _25;
  int _26;
  int _27;
  unsigned char _28;
  int _29;
  long unsigned int _30;
  int _31;
  int _32;
  s16_t _50;
  s16_t _69;
  s16_t _83;
  s16_t _86;
  s16_t _90;

  <bb 2> :
  old_pending_59 = 10;
  old_stable_60 = 10;
  empty_61 = 10;
  i_62 = 0;
  old_queue_63 = 10;
  age_queue_64 = 0;
  age_pending_65 = 0;
  age_stable_66 = 0;
  i_67 = 0;
  goto <bb 25>; [INV]

  <bb 3> :
  _1 = (int) i_39;
  state_87 = arp_table[_1].state;
  if (empty_38 == 10)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (state_87 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  empty_88 = i_39;
  goto <bb 24>; [INV]

  <bb 6> :
  if (state_87 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 7> :
  if (state_87 != 1)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (state_87 <= 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  if (ipaddr_78(D) != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 11> :
  _2 = ipaddr_78(D)->addr;
  _3 = (int) i_39;
  _4 = arp_table[_3].ipaddr.addr;
  if (_2 == _4)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  if (netif_81(D) == 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  _5 = (int) i_39;
  _6 = arp_table[_5].netif;
  if (netif_81(D) == _6)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _90 = i_39;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 15> :
  if (state_87 == 1)
    goto <bb 16>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 16> :
  _7 = (int) i_39;
  _8 = arp_table[_7].q;
  if (_8 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 17> :
  _9 = (int) i_39;
  _10 = arp_table[_9].ctime;
  if (age_queue_45 <= _10)
    goto <bb 18>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 18> :
  old_queue_95 = i_39;
  _11 = (int) i_39;
  age_queue_96 = arp_table[_11].ctime;
  goto <bb 24>; [INV]

  <bb 19> :
  _12 = (int) i_39;
  _13 = arp_table[_12].ctime;
  if (age_pending_47 <= _13)
    goto <bb 20>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 20> :
  old_pending_93 = i_39;
  _14 = (int) i_39;
  age_pending_94 = arp_table[_14].ctime;
  goto <bb 24>; [INV]

  <bb 21> :
  if (state_87 > 1)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 22> :
  _15 = (int) i_39;
  _16 = arp_table[_15].ctime;
  if (age_stable_49 <= _16)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  old_stable_91 = i_39;
  _17 = (int) i_39;
  age_stable_92 = arp_table[_17].ctime;

  <bb 24> :
  # old_pending_33 = PHI <old_pending_34(5), old_pending_34(6), old_pending_34(19), old_pending_34(21), old_pending_34(22), old_pending_34(23), old_pending_34(18), old_pending_34(17), old_pending_93(20)>
  # old_stable_35 = PHI <old_stable_36(5), old_stable_36(6), old_stable_36(19), old_stable_36(21), old_stable_36(22), old_stable_91(23), old_stable_36(18), old_stable_36(17), old_stable_36(20)>
  # empty_37 = PHI <empty_88(5), empty_38(6), empty_38(19), empty_38(21), empty_38(22), empty_38(23), empty_38(18), empty_38(17), empty_38(20)>
  # old_queue_42 = PHI <old_queue_43(5), old_queue_43(6), old_queue_43(19), old_queue_43(21), old_queue_43(22), old_queue_43(23), old_queue_95(18), old_queue_43(17), old_queue_43(20)>
  # age_queue_44 = PHI <age_queue_45(5), age_queue_45(6), age_queue_45(19), age_queue_45(21), age_queue_45(22), age_queue_45(23), age_queue_96(18), age_queue_45(17), age_queue_45(20)>
  # age_pending_46 = PHI <age_pending_47(5), age_pending_47(6), age_pending_47(19), age_pending_47(21), age_pending_47(22), age_pending_47(23), age_pending_47(18), age_pending_47(17), age_pending_94(20)>
  # age_stable_48 = PHI <age_stable_49(5), age_stable_49(6), age_stable_49(19), age_stable_49(21), age_stable_49(22), age_stable_92(23), age_stable_49(18), age_stable_49(17), age_stable_49(20)>
  i.0_18 = (unsigned short) i_39;
  _19 = i.0_18 + 1;
  i_97 = (s16_t) _19;

  <bb 25> :
  # old_pending_34 = PHI <old_pending_59(2), old_pending_33(24)>
  # old_stable_36 = PHI <old_stable_60(2), old_stable_35(24)>
  # empty_38 = PHI <empty_61(2), empty_37(24)>
  # i_39 = PHI <i_67(2), i_97(24)>
  # old_queue_43 = PHI <old_queue_63(2), old_queue_42(24)>
  # age_queue_45 = PHI <age_queue_64(2), age_queue_44(24)>
  # age_pending_47 = PHI <age_pending_65(2), age_pending_46(24)>
  # age_stable_49 = PHI <age_stable_66(2), age_stable_48(24)>
  if (i_39 <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  _20 = (int) flags_68(D);
  _21 = _20 & 2;
  if (_21 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  if (empty_38 == 10)
    goto <bb 28>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 28> :
  _22 = (int) flags_68(D);
  _23 = _22 & 1;
  if (_23 == 0)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _86 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 30> :
  if (empty_38 <= 9)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  i_77 = empty_38;
  goto <bb 43>; [INV]

  <bb 32> :
  if (old_stable_36 <= 9)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  i_73 = old_stable_36;
  _24 = (int) i_73;
  _25 = arp_table[_24].q;
  if (_25 != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 34> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 34>; [INV]

  <bb 35> :
  if (old_pending_34 <= 9)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  i_72 = old_pending_34;
  goto <bb 40>; [INV]

  <bb 37> :
  if (old_queue_43 <= 9)
    goto <bb 38>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 38> :
  i_71 = old_queue_43;
  goto <bb 40>; [INV]

  <bb 39> :
  _69 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 40> :
  # i_40 = PHI <i_73(33), i_72(36), i_71(38)>
  if (i_40 > 9)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 41>; [INV]

  <bb 42> :
  _26 = (int) i_40;
  etharp_free_entry (_26);

  <bb 43> :
  # i_41 = PHI <i_77(31), i_40(42)>
  if (i_41 > 9)
    goto <bb 44>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 44> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 44>; [INV]

  <bb 45> :
  _27 = (int) i_41;
  _28 = arp_table[_27].state;
  if (_28 != 0)
    goto <bb 46>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 46> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 46>; [INV]

  <bb 47> :
  if (ipaddr_78(D) != 0B)
    goto <bb 48>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 48> :
  _29 = (int) i_41;
  _30 = ipaddr_78(D)->addr;
  arp_table[_29].ipaddr.addr = _30;

  <bb 49> :
  _31 = (int) i_41;
  arp_table[_31].ctime = 0;
  _32 = (int) i_41;
  arp_table[_32].netif = netif_81(D);
  _83 = i_41;

  <bb 50> :
  # _50 = PHI <_90(14), _86(29), _69(39), _83(49)>
<L65>:
  return _50;

}


etharp_tmr ()
{
  u8_t state;
  int i;
  short unsigned int _1;
  short unsigned int _2;
  short unsigned int _3;
  short unsigned int _4;
  unsigned char _5;
  short unsigned int _6;
  unsigned char _7;
  unsigned char _8;
  unsigned char _9;
  struct netif * _10;
  struct ip4_addr_t * _11;

  <bb 2> :
  i_15 = 0;
  goto <bb 15>; [INV]

  <bb 3> :
  state_17 = arp_table[i_12].state;
  if (state_17 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 4> :
  _1 = arp_table[i_12].ctime;
  _2 = _1;
  _3 = _2 + 1;
  arp_table[i_12].ctime = _3;
  _4 = arp_table[i_12].ctime;
  if (_4 > 299)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _5 = arp_table[i_12].state;
  if (_5 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _6 = arp_table[i_12].ctime;
  if (_6 > 4)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  etharp_free_entry (i_12);
  goto <bb 14>; [INV]

  <bb 8> :
  _7 = arp_table[i_12].state;
  if (_7 == 3)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  arp_table[i_12].state = 4;
  goto <bb 14>; [INV]

  <bb 10> :
  _8 = arp_table[i_12].state;
  if (_8 == 4)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  arp_table[i_12].state = 2;
  goto <bb 14>; [INV]

  <bb 12> :
  _9 = arp_table[i_12].state;
  if (_9 == 1)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _10 = arp_table[i_12].netif;
  _11 = &arp_table[i_12].ipaddr;
  etharp_request (_10, _11);

  <bb 14> :
  i_23 = i_12 + 1;

  <bb 15> :
  # i_12 = PHI <i_15(2), i_23(14)>
  if (i_12 <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  return;

}


etharp_free_entry (int i)
{
  struct etharp_q_entry * _1;
  struct etharp_q_entry * _2;

  <bb 2> :
  _1 = arp_table[i_5(D)].q;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = arp_table[i_5(D)].q;
  free_etharp_q (_2);
  arp_table[i_5(D)].q = 0B;

  <bb 4> :
  arp_table[i_5(D)].state = 0;
  return;

}


free_etharp_q (struct etharp_q_entry * q)
{
  struct etharp_q_entry * r;
  struct pbuf * _1;
  struct pbuf * _2;

  <bb 2> :
  if (q_7(D) == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  goto <bb 8>; [INV]

  <bb 5> :
  r_9 = q_3;
  q_10 = q_3->next;
  _1 = r_9->p;
  if (_1 == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 6>; [INV]

  <bb 7> :
  _2 = r_9->p;
  pbuf_free (_2);
  memp_free (7, r_9);

  <bb 8> :
  # q_3 = PHI <q_7(D)(4), q_10(7)>
  if (q_3 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}


