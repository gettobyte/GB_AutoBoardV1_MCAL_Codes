etharp_request (struct netif * netif, const struct ip4_addr_t * ipaddr)
{
  err_t D.7729;

  <bb 2> :
  D.7729 = etharp_request_dst (netif, ipaddr, &ethbroadcast);

  <bb 3> :
<L0>:
  return D.7729;

}


etharp_request_dst (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct eth_addr * hw_dst_addr)
{
  err_t D.7727;

  <bb 2> :
  _1 = &netif->hwaddr;
  _2 = &netif->hwaddr;
  _3 = &netif->ip_addr.u_addr.ip4;
  D.7727 = etharp_raw (netif, _1, hw_dst_addr, _2, _3, &ethzero, ipaddr, 1);

  <bb 3> :
<L0>:
  return D.7727;

}


etharp_raw (struct netif * netif, const struct eth_addr * ethsrc_addr, const struct eth_addr * ethdst_addr, const struct eth_addr * hwsrc_addr, const struct ip4_addr_t * ipsrc_addr, const struct eth_addr * hwdst_addr, const struct ip4_addr_t * ipdst_addr, const u16_t opcode)
{
  unsigned int D.7726;
  unsigned int D.7725;
  struct etharp_hdr * hdr;
  err_t result;
  struct pbuf * p;
  err_t D.7719;

  <bb 2> :
  result = 0;
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  p = pbuf_alloc (14, 28, 640);
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = lwip_stats.etharp.memerr;
  _2 = _1 + 1;
  lwip_stats.etharp.memerr = _2;
  D.7719 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 6> :
  _3 = p->len;
  if (_3 <= 27)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  hdr = p->payload;
  _4 = lwip_htons (opcode);
  hdr->opcode = _4;
  _5 = netif->hwaddr_len;
  if (_5 != 6)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  _6 = &hdr->shwaddr;
  memcpy (_6, hwsrc_addr, 6);
  _7 = &hdr->dhwaddr;
  memcpy (_7, hwdst_addr, 6);
  _8 = &hdr->sipaddr;
  D.7725 = MEM <unsigned int> [(char * {ref-all})ipsrc_addr];
  MEM <unsigned int> [(char * {ref-all})_8] = D.7725;
  _9 = &hdr->dipaddr;
  D.7726 = MEM <unsigned int> [(char * {ref-all})ipdst_addr];
  MEM <unsigned int> [(char * {ref-all})_9] = D.7726;
  hdr->hwtype = 256;
  hdr->proto = 8;
  hdr->hwlen = 6;
  hdr->protolen = 4;
  ethernet_output (netif, p, ethsrc_addr, ethdst_addr, 2054);
  _10 = lwip_stats.etharp.xmit;
  _11 = _10 + 1;
  lwip_stats.etharp.xmit = _11;
  pbuf_free (p);
  p = 0B;
  D.7719 = result;

  <bb 11> :
<L11>:
  return D.7719;

}


etharp_query (struct netif * netif, const struct ip4_addr_t * ipaddr, struct pbuf * q)
{
  struct etharp_q_entry * old;
  struct etharp_q_entry * r;
  unsigned int qlen;
  struct etharp_q_entry * new_entry;
  int copy_needed;
  struct pbuf * p;
  netif_addr_idx_t i;
  s16_t i_err;
  int is_new_entry;
  err_t result;
  struct eth_addr * srcaddr;
  err_t D.7662;

  <bb 2> :
  srcaddr = &netif->hwaddr;
  result = -1;
  is_new_entry = 0;
  _1 = ipaddr->addr;
  _2 = ip4_addr_isbroadcast_u32 (_1, netif);
  if (_2 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _3 = ipaddr->addr;
  _4 = _3 & 240;
  if (_4 == 224)
    goto <bb 6>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  if (ipaddr == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _5 = ipaddr->addr;
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.7662 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 56>; [INV]

  <bb 7> :
  i_err = etharp_find_entry (ipaddr, 1, netif);
  if (i_err < 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  if (q != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = lwip_stats.etharp.memerr;
  _7 = _6 + 1;
  lwip_stats.etharp.memerr = _7;

  <bb 10> :
  D.7662 = (err_t) i_err;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 56>; [INV]

  <bb 11> :
  i_err.7_8 = (short unsigned int) i_err;
  if (i_err.7_8 > 126)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 12>; [INV]

  <bb 13> :
  i = (netif_addr_idx_t) i_err;
  _9 = (int) i;
  _10 = arp_table[_9].state;
  if (_10 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  is_new_entry = 1;
  _11 = (int) i;
  arp_table[_11].state = 1;
  _12 = (int) i;
  arp_table[_12].netif = netif;

  <bb 15> :
  _13 = (int) i;
  _14 = arp_table[_13].state;
  if (_14 != 1)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _15 = (int) i;
  _16 = arp_table[_15].state;
  if (_16 <= 1)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 17>; [INV]

  <bb 18> :
  if (is_new_entry != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  if (q == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 20> :
  result = etharp_request (netif, ipaddr);
  if (result != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  _17 = (int) i;
  _18 = arp_table[_17].state;
  if (_18 == 1)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 22> :
  if (is_new_entry == 0)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _19 = (int) i;
  arp_table[_19].ctime = 0;

  <bb 24> :
  if (q == 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  D.7662 = result;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 56>; [INV]

  <bb 26> :
  if (q == 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 27>; [INV]

  <bb 28> :
  _20 = (int) i;
  _21 = arp_table[_20].state;
  if (_21 > 1)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  etharp_cached_entry = i;
  _22 = (int) i;
  _23 = &arp_table[_22].ethaddr;
  result = ethernet_output (netif, q, srcaddr, _23, 2048);
  goto <bb 55>; [INV]

  <bb 30> :
  _24 = (int) i;
  _25 = arp_table[_24].state;
  if (_25 == 1)
    goto <bb 31>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 31> :
  copy_needed = 0;
  p = q;
  goto <bb 38>; [INV]

  <bb 32> :
  _26 = p->len;
  _27 = p->tot_len;
  if (_26 == _27)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  _28 = p->next;
  if (_28 != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 34>; [INV]

  <bb 35> :
  _29 = p->type_internal;
  _30 = (int) _29;
  _31 = _30 & 64;
  if (_31 != 0)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  copy_needed = 1;
  goto <bb 39>; [INV]

  <bb 37> :
  p = p->next;

  <bb 38> :
  if (p != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 39> :
  if (copy_needed != 0)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  p = pbuf_clone (14, 640, q);
  goto <bb 42>; [INV]

  <bb 41> :
  p = q;
  pbuf_ref (p);

  <bb 42> :
  if (p != 0B)
    goto <bb 43>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 43> :
  new_entry = memp_malloc (7);
  if (new_entry != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 44> :
  qlen = 0;
  new_entry->next = 0B;
  new_entry->p = p;
  _32 = (int) i;
  _33 = arp_table[_32].q;
  if (_33 != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 45> :
  _34 = (int) i;
  r = arp_table[_34].q;
  qlen = qlen + 1;
  goto <bb 47>; [INV]

  <bb 46> :
  r = r->next;
  qlen = qlen + 1;

  <bb 47> :
  _35 = r->next;
  if (_35 != 0B)
    goto <bb 46>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 48> :
  r->next = new_entry;
  goto <bb 50>; [INV]

  <bb 49> :
  _36 = (int) i;
  arp_table[_36].q = new_entry;

  <bb 50> :
  if (qlen > 2)
    goto <bb 51>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 51> :
  _37 = (int) i;
  old = arp_table[_37].q;
  _38 = (int) i;
  _39 = arp_table[_38].q;
  _40 = (int) i;
  _41 = _39->next;
  arp_table[_40].q = _41;
  _42 = old->p;
  pbuf_free (_42);
  memp_free (7, old);

  <bb 52> :
  result = 0;
  goto <bb 55>; [INV]

  <bb 53> :
  pbuf_free (p);
  result = -1;
  goto <bb 55>; [INV]

  <bb 54> :
  _43 = lwip_stats.etharp.memerr;
  _44 = _43 + 1;
  lwip_stats.etharp.memerr = _44;
  result = -1;

  <bb 55> :
  D.7662 = result;

  <bb 56> :
<L66>:
  return D.7662;

}


etharp_output (struct netif * netif, struct pbuf * q, const struct ip4_addr_t * ipaddr)
{
  netif_addr_idx_t i;
  const struct ip4_addr_t * dst_addr;
  struct eth_addr mcastaddr;
  const struct eth_addr * dest;
  err_t D.7642;

  <bb 2> :
  dst_addr = ipaddr;
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (q == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  if (ipaddr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  _1 = ipaddr->addr;
  _2 = ip4_addr_isbroadcast_u32 (_1, netif);
  if (_2 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  dest = &ethbroadcast;
  goto <bb 29>; [INV]

  <bb 10> :
  _3 = ipaddr->addr;
  _4 = _3 & 240;
  if (_4 == 224)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  mcastaddr.addr[0] = 1;
  mcastaddr.addr[1] = 0;
  mcastaddr.addr[2] = 94;
  _5 = &ipaddr->addr;
  _6 = _5 + 1;
  _7 = *_6;
  _8 = _7 & 127;
  mcastaddr.addr[3] = _8;
  _9 = &ipaddr->addr;
  _10 = _9 + 2;
  _11 = *_10;
  mcastaddr.addr[4] = _11;
  _12 = &ipaddr->addr;
  _13 = _12 + 3;
  _14 = *_13;
  mcastaddr.addr[5] = _14;
  dest = &mcastaddr;
  goto <bb 29>; [INV]

  <bb 12> :
  _15 = ipaddr->addr;
  _16 = &netif->ip_addr.u_addr.ip4;
  _17 = MEM[(const struct ip4_addr_t *)_16].addr;
  _18 = _15 ^ _17;
  _19 = &netif->netmask.u_addr.ip4;
  _20 = MEM[(const struct ip4_addr_t *)_19].addr;
  _21 = _18 & _20;
  if (_21 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  _22 = ipaddr->addr;
  _23 = _22 & 65535;
  if (_23 != 65193)
    goto <bb 14>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 14> :
  _24 = &netif->gw.u_addr.ip4;
  _25 = MEM[(const struct ip4_addr_t *)_24].addr;
  if (_25 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  dst_addr = &netif->gw.u_addr.ip4;
  goto <bb 17>; [INV]

  <bb 16> :
  D.7642 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 17> :
  etharp_cached_entry.2_26 = etharp_cached_entry;
  _27 = (int) etharp_cached_entry.2_26;
  _28 = arp_table[_27].state;
  if (_28 > 1)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  etharp_cached_entry.3_29 = etharp_cached_entry;
  _30 = (int) etharp_cached_entry.3_29;
  _31 = arp_table[_30].netif;
  if (netif == _31)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _32 = dst_addr->addr;
  etharp_cached_entry.4_33 = etharp_cached_entry;
  _34 = (int) etharp_cached_entry.4_33;
  _35 = arp_table[_34].ipaddr.addr;
  if (_32 == _35)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _36 = lwip_stats.etharp.cachehit;
  _37 = _36 + 1;
  lwip_stats.etharp.cachehit = _37;
  etharp_cached_entry.5_38 = etharp_cached_entry;
  D.7642 = etharp_output_to_arp_index (netif, q, etharp_cached_entry.5_38);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 21> :
  i = 0;
  goto <bb 27>; [INV]

  <bb 22> :
  _39 = (int) i;
  _40 = arp_table[_39].state;
  if (_40 > 1)
    goto <bb 23>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 23> :
  _41 = (int) i;
  _42 = arp_table[_41].netif;
  if (netif == _42)
    goto <bb 24>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 24> :
  _43 = dst_addr->addr;
  _44 = (int) i;
  _45 = arp_table[_44].ipaddr.addr;
  if (_43 == _45)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  etharp_cached_entry = i;
  D.7642 = etharp_output_to_arp_index (netif, q, i);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 26> :
  i.6_46 = i;
  i = i.6_46 + 1;

  <bb 27> :
  if (i <= 9)
    goto <bb 22>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  D.7642 = etharp_query (netif, dst_addr, q);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 29> :
  _47 = &netif->hwaddr;
  D.7642 = ethernet_output (netif, q, _47, dest, 2048);

  <bb 30> :
  mcastaddr = {CLOBBER};

  <bb 31> :
<L38>:
  return D.7642;

}


etharp_output_to_arp_index (struct netif * netif, struct pbuf * q, netif_addr_idx_t arp_idx)
{
  err_t D.7621;

  <bb 2> :
  _1 = (int) arp_idx;
  _2 = arp_table[_1].state;
  if (_2 <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _3 = (int) arp_idx;
  _4 = arp_table[_3].state;
  if (_4 == 2)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  _5 = (int) arp_idx;
  _6 = arp_table[_5].ctime;
  if (_6 > 284)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _7 = (int) arp_idx;
  _8 = &arp_table[_7].ipaddr;
  _9 = etharp_request (netif, _8);
  if (_9 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  _10 = (int) arp_idx;
  arp_table[_10].state = 3;
  goto <bb 11>; [INV]

  <bb 8> :
  _11 = (int) arp_idx;
  _12 = arp_table[_11].ctime;
  if (_12 > 269)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _13 = (int) arp_idx;
  _14 = &arp_table[_13].ipaddr;
  _15 = (int) arp_idx;
  _16 = &arp_table[_15].ethaddr;
  _17 = etharp_request_dst (netif, _14, _16);
  if (_17 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _18 = (int) arp_idx;
  arp_table[_18].state = 3;

  <bb 11> :
  _19 = &netif->hwaddr;
  _20 = (int) arp_idx;
  _21 = &arp_table[_20].ethaddr;
  D.7621 = ethernet_output (netif, q, _19, _21, 2048);

  <bb 12> :
<L14>:
  return D.7621;

}


etharp_input (struct pbuf * p, struct netif * netif)
{
  unsigned int D.7605;
  unsigned int D.7604;
  u8_t for_us;
  struct ip4_addr_t dipaddr;
  struct ip4_addr_t sipaddr;
  struct etharp_hdr * hdr;
  u8_t iftmp.1;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 4> :
  hdr = p->payload;
  _1 = hdr->hwtype;
  if (_1 != 256)
    goto <bb 8>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _2 = hdr->hwlen;
  if (_2 != 6)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _3 = hdr->protolen;
  if (_3 != 4)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _4 = hdr->proto;
  if (_4 != 8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _5 = lwip_stats.etharp.proterr;
  _6 = _5 + 1;
  lwip_stats.etharp.proterr = _6;
  _7 = lwip_stats.etharp.drop;
  _8 = _7 + 1;
  lwip_stats.etharp.drop = _8;
  pbuf_free (p);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 9> :
  _9 = lwip_stats.etharp.recv;
  _10 = _9 + 1;
  lwip_stats.etharp.recv = _10;
  _11 = &hdr->sipaddr;
  D.7604 = MEM <unsigned int> [(char * {ref-all})_11];
  MEM <unsigned int> [(char * {ref-all})&sipaddr] = D.7604;
  _12 = &hdr->dipaddr;
  D.7605 = MEM <unsigned int> [(char * {ref-all})_12];
  MEM <unsigned int> [(char * {ref-all})&dipaddr] = D.7605;
  _13 = &netif->ip_addr.u_addr.ip4;
  _14 = MEM[(const struct ip4_addr_t *)_13].addr;
  if (_14 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  for_us = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  _15 = dipaddr.addr;
  _16 = &netif->ip_addr.u_addr.ip4;
  _17 = MEM[(const struct ip4_addr_t *)_16].addr;
  _18 = _15 == _17;
  for_us = (u8_t) _18;

  <bb 12> :
  _19 = &hdr->shwaddr;
  if (for_us != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  iftmp.1 = 1;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.1 = 2;

  <bb 15> :
  etharp_update_arp_entry (netif, &sipaddr, _19, iftmp.1);
  _20 = hdr->opcode;
  _21 = (int) _20;
  switch (_21) <default: <L21> [INV], case 256: <L13> [INV], case 512: <L20> [INV]>

  <bb 16> :
<L13>:
  if (for_us != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _22 = &netif->hwaddr;
  _23 = &hdr->shwaddr;
  _24 = &netif->hwaddr;
  _25 = &netif->ip_addr.u_addr.ip4;
  _26 = &hdr->shwaddr;
  etharp_raw (netif, _22, _23, _24, _25, _26, &sipaddr, 2);
  goto <bb 19>; [INV]

  <bb 18> :
  _27 = &netif->ip_addr.u_addr.ip4;
  _28 = MEM[(const struct ip4_addr_t *)_27].addr;

  <bb 19> :
  goto <bb 22>; [INV]

  <bb 20> :
<L20>:
  goto <bb 22>; [INV]

  <bb 21> :
<L21>:
  _29 = lwip_stats.etharp.err;
  _30 = _29 + 1;
  lwip_stats.etharp.err = _30;

  <bb 22> :
  pbuf_free (p);
  sipaddr = {CLOBBER};
  dipaddr = {CLOBBER};
  goto <bb 24>; [INV]

  <bb 23> :
  sipaddr = {CLOBBER};
  dipaddr = {CLOBBER};

  <bb 24> :
<L25>:
  return;

}


etharp_get_entry (size_t i, struct ip4_addr_t * * ipaddr, struct netif * * netif, struct eth_addr * * eth_ret)
{
  int D.7581;

  <bb 2> :
  if (ipaddr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (netif == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  if (eth_ret == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  if (i <= 9)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _1 = arp_table[i].state;
  if (_1 > 1)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _2 = &arp_table[i].ipaddr;
  *ipaddr = _2;
  _3 = arp_table[i].netif;
  *netif = _3;
  _4 = &arp_table[i].ethaddr;
  *eth_ret = _4;
  D.7581 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 11> :
  D.7581 = 0;
  // predicted unlikely by early return (on trees) predictor.

  <bb 12> :
<L12>:
  return D.7581;

}


etharp_find_addr (struct netif * netif, const struct ip4_addr_t * ipaddr, struct eth_addr * * eth_ret, const struct ip4_addr_t * * ip_ret)
{
  s16_t i;
  ssize_t D.7570;

  <bb 2> :
  if (eth_ret == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (ip_ret == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 4>; [INV]

  <bb 5> :
  i = etharp_find_entry (ipaddr, 2, netif);
  if (i >= 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _1 = (int) i;
  _2 = arp_table[_1].state;
  if (_2 > 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _3 = (int) i;
  _4 = &arp_table[_3].ethaddr;
  *eth_ret = _4;
  _5 = (int) i;
  _6 = &arp_table[_5].ipaddr;
  *ip_ret = _6;
  D.7570 = (ssize_t) i;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  D.7570 = -1;

  <bb 9> :
<L8>:
  return D.7570;

}


etharp_cleanup_netif (struct netif * netif)
{
  u8_t state;
  int i;

  <bb 2> :
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  state = arp_table[i].state;
  if (state != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _1 = arp_table[i].netif;
  if (netif == _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  etharp_free_entry (i);

  <bb 6> :
  i = i + 1;

  <bb 7> :
  if (i <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  return;

}


etharp_update_arp_entry (struct netif * netif, const struct ip4_addr_t * ipaddr, struct eth_addr * ethaddr, u8_t flags)
{
  struct etharp_q_entry * q;
  struct pbuf * p;
  s16_t i;
  err_t D.7555;

  <bb 2> :
  _1 = netif->hwaddr_len;
  if (_1 != 6)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (ipaddr == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _2 = ipaddr->addr;
  if (_2 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _3 = ipaddr->addr;
  _4 = ip4_addr_isbroadcast_u32 (_3, netif);
  if (_4 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ipaddr->addr;
  _6 = _5 & 240;
  if (_6 == 224)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.7555 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 9> :
  i = etharp_find_entry (ipaddr, flags, netif);
  if (i < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.7555 = (err_t) i;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 11> :
  _7 = (int) i;
  arp_table[_7].state = 2;
  _8 = (int) i;
  arp_table[_8].netif = netif;
  _9 = (int) i;
  _10 = &arp_table[_9].ethaddr;
  memcpy (_10, ethaddr, 6);
  _11 = (int) i;
  arp_table[_11].ctime = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  _12 = (int) i;
  q = arp_table[_12].q;
  _13 = (int) i;
  _14 = q->next;
  arp_table[_13].q = _14;
  p = q->p;
  memp_free (7, q);
  _15 = &netif->hwaddr;
  ethernet_output (netif, p, _15, ethaddr, 2048);
  pbuf_free (p);

  <bb 13> :
  _16 = (int) i;
  _17 = arp_table[_16].q;
  if (_17 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  D.7555 = 0;

  <bb 15> :
<L13>:
  return D.7555;

}


etharp_find_entry (const struct ip4_addr_t * ipaddr, u8_t flags, struct netif * netif)
{
  u8_t state;
  u16_t age_stable;
  u16_t age_pending;
  u16_t age_queue;
  s16_t old_queue;
  s16_t i;
  s16_t empty;
  s16_t old_stable;
  s16_t old_pending;
  s16_t D.7506;

  <bb 2> :
  old_pending = 10;
  old_stable = 10;
  empty = 10;
  i = 0;
  old_queue = 10;
  age_queue = 0;
  age_pending = 0;
  age_stable = 0;
  i = 0;
  goto <bb 25>; [INV]

  <bb 3> :
  _1 = (int) i;
  state = arp_table[_1].state;
  if (empty == 10)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (state == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  empty = i;
  goto <bb 24>; [INV]

  <bb 6> :
  if (state != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 7> :
  if (state != 1)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (state <= 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  if (ipaddr != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 11> :
  _2 = ipaddr->addr;
  _3 = (int) i;
  _4 = arp_table[_3].ipaddr.addr;
  if (_2 == _4)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  if (netif == 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  _5 = (int) i;
  _6 = arp_table[_5].netif;
  if (netif == _6)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  D.7506 = i;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 15> :
  if (state == 1)
    goto <bb 16>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 16> :
  _7 = (int) i;
  _8 = arp_table[_7].q;
  if (_8 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 17> :
  _9 = (int) i;
  _10 = arp_table[_9].ctime;
  if (age_queue <= _10)
    goto <bb 18>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 18> :
  old_queue = i;
  _11 = (int) i;
  age_queue = arp_table[_11].ctime;
  goto <bb 24>; [INV]

  <bb 19> :
  _12 = (int) i;
  _13 = arp_table[_12].ctime;
  if (age_pending <= _13)
    goto <bb 20>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 20> :
  old_pending = i;
  _14 = (int) i;
  age_pending = arp_table[_14].ctime;
  goto <bb 24>; [INV]

  <bb 21> :
  if (state > 1)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 22> :
  _15 = (int) i;
  _16 = arp_table[_15].ctime;
  if (age_stable <= _16)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  old_stable = i;
  _17 = (int) i;
  age_stable = arp_table[_17].ctime;

  <bb 24> :
  i.0_18 = (unsigned short) i;
  _19 = i.0_18 + 1;
  i = (s16_t) _19;

  <bb 25> :
  if (i <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  _20 = (int) flags;
  _21 = _20 & 2;
  if (_21 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  if (empty == 10)
    goto <bb 28>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 28> :
  _22 = (int) flags;
  _23 = _22 & 1;
  if (_23 == 0)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  D.7506 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 30> :
  if (empty <= 9)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  i = empty;
  goto <bb 43>; [INV]

  <bb 32> :
  if (old_stable <= 9)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  i = old_stable;
  _24 = (int) i;
  _25 = arp_table[_24].q;
  if (_25 != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 34> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 34>; [INV]

  <bb 35> :
  if (old_pending <= 9)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  i = old_pending;
  goto <bb 40>; [INV]

  <bb 37> :
  if (old_queue <= 9)
    goto <bb 38>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 38> :
  i = old_queue;
  goto <bb 40>; [INV]

  <bb 39> :
  D.7506 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 40> :
  if (i > 9)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 41>; [INV]

  <bb 42> :
  _26 = (int) i;
  etharp_free_entry (_26);

  <bb 43> :
  if (i > 9)
    goto <bb 44>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 44> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 44>; [INV]

  <bb 45> :
  _27 = (int) i;
  _28 = arp_table[_27].state;
  if (_28 != 0)
    goto <bb 46>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 46> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 46>; [INV]

  <bb 47> :
  if (ipaddr != 0B)
    goto <bb 48>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 48> :
  _29 = (int) i;
  _30 = ipaddr->addr;
  arp_table[_29].ipaddr.addr = _30;

  <bb 49> :
  _31 = (int) i;
  arp_table[_31].ctime = 0;
  _32 = (int) i;
  arp_table[_32].netif = netif;
  D.7506 = i;

  <bb 50> :
<L65>:
  return D.7506;

}


etharp_tmr ()
{
  u8_t state;
  int i;

  <bb 2> :
  i = 0;
  goto <bb 15>; [INV]

  <bb 3> :
  state = arp_table[i].state;
  if (state != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 4> :
  _1 = arp_table[i].ctime;
  _2 = _1;
  _3 = _2 + 1;
  arp_table[i].ctime = _3;
  _4 = arp_table[i].ctime;
  if (_4 > 299)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _5 = arp_table[i].state;
  if (_5 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _6 = arp_table[i].ctime;
  if (_6 > 4)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  etharp_free_entry (i);
  goto <bb 14>; [INV]

  <bb 8> :
  _7 = arp_table[i].state;
  if (_7 == 3)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  arp_table[i].state = 4;
  goto <bb 14>; [INV]

  <bb 10> :
  _8 = arp_table[i].state;
  if (_8 == 4)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  arp_table[i].state = 2;
  goto <bb 14>; [INV]

  <bb 12> :
  _9 = arp_table[i].state;
  if (_9 == 1)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _10 = arp_table[i].netif;
  _11 = &arp_table[i].ipaddr;
  etharp_request (_10, _11);

  <bb 14> :
  i = i + 1;

  <bb 15> :
  if (i <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  return;

}


etharp_free_entry (int i)
{
  <bb 2> :
  _1 = arp_table[i].q;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = arp_table[i].q;
  free_etharp_q (_2);
  arp_table[i].q = 0B;

  <bb 4> :
  arp_table[i].state = 0;
  return;

}


free_etharp_q (struct etharp_q_entry * q)
{
  struct etharp_q_entry * r;

  <bb 2> :
  if (q == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  goto <bb 8>; [INV]

  <bb 5> :
  r = q;
  q = q->next;
  _1 = r->p;
  if (_1 == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 6>; [INV]

  <bb 7> :
  _2 = r->p;
  pbuf_free (_2);
  memp_free (7, r);

  <bb 8> :
  if (q != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}


