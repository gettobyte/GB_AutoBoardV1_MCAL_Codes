netif_find (const char * name)
{
  u8_t num;
  struct netif * netif;
  struct netif * D.8533;

  <bb 2> :
  if (name == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.8533 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 4> :
  _1 = name + 2;
  _2 = atoi (_1);
  num = (u8_t) _2;
  if (num == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _3 = name + 2;
  _4 = *_3;
  if (_4 != 48)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.8533 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 7> :
  netif = netif_list;
  goto <bb 13>; [INV]

  <bb 8> :
  _5 = netif->num;
  if (num == _5)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  _6 = *name;
  _7 = netif->name[0];
  if (_6 == _7)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _8 = name + 1;
  _9 = *_8;
  _10 = netif->name[1];
  if (_9 == _10)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  D.8533 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 12> :
  netif = netif->next;

  <bb 13> :
  if (netif != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  D.8533 = 0B;

  <bb 15> :
<L15>:
  return D.8533;

}


netif_get_by_index (u8_t idx)
{
  struct netif * netif;
  struct netif * D.8529;

  <bb 2> :
  if (idx != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  netif = netif_list;
  goto <bb 7>; [INV]

  <bb 4> :
  _1 = netif->num;
  _2 = _1 + 1;
  if (idx == _2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8529 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  netif = netif->next;

  <bb 7> :
  if (netif != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.8529 = 0B;

  <bb 9> :
<L7>:
  return D.8529;

}


netif_index_to_name (u8_t idx, char * name)
{
  struct netif * netif;
  char * D.8523;

  <bb 2> :
  netif = netif_get_by_index (idx);
  if (netif != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = netif->name[0];
  *name = _1;
  _2 = name + 1;
  _3 = netif->name[1];
  *_2 = _3;
  _4 = name + 2;
  _5 = (int) idx;
  _6 = _5 + -1;
  lwip_itoa (_4, 4, _6);
  D.8523 = name;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.8523 = 0B;

  <bb 5> :
<L2>:
  return D.8523;

}


netif_name_to_index (const char * name)
{
  struct netif * netif;
  u8_t D.8519;

  <bb 2> :
  netif = netif_find (name);
  if (netif != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = netif->num;
  D.8519 = _1 + 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.8519 = 0;

  <bb 5> :
<L2>:
  return D.8519;

}


netif_null_output_ip4 (struct netif * netif, struct pbuf * p, const struct ip4_addr_t * ipaddr)
{
  err_t D.8515;

  <bb 2> :
  D.8515 = -12;

  <bb 3> :
<L0>:
  return D.8515;

}


netif_null_output_ip6 (struct netif * netif, struct pbuf * p, const struct ip6_addr_t * ipaddr)
{
  err_t D.8513;

  <bb 2> :
  D.8513 = -12;

  <bb 3> :
<L0>:
  return D.8513;

}


netif_add_ip6_address (struct netif * netif, const struct ip6_addr_t * ip6addr, s8_t * chosen_idx)
{
  s8_t i;
  u8_t iftmp.18;
  err_t D.8501;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (ip6addr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  i = netif_get_ip6_addr_match (netif, ip6addr);
  if (i >= 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  if (chosen_idx != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  *chosen_idx = i;

  <bb 9> :
  D.8501 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 10> :
  _1 = ip6addr->addr[0];
  _2 = _1 & 49407;
  _3 = _2 != 33022;
  i = (s8_t) _3;
  goto <bb 19>; [INV]

  <bb 11> :
  _4 = (int) i;
  _5 = netif->ip6_addr_state[_4];
  if (_5 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 12> :
  _6 = (int) i;
  _7 = ip6addr->addr[0];
  netif->ip6_addr[_6].u_addr.ip6.addr[0] = _7;
  _8 = (int) i;
  _9 = ip6addr->addr[1];
  netif->ip6_addr[_8].u_addr.ip6.addr[1] = _9;
  _10 = (int) i;
  _11 = ip6addr->addr[2];
  netif->ip6_addr[_10].u_addr.ip6.addr[2] = _11;
  _12 = (int) i;
  _13 = ip6addr->addr[3];
  netif->ip6_addr[_12].u_addr.ip6.addr[3] = _13;
  _14 = (int) i;
  _15 = ip6addr->zone;
  netif->ip6_addr[_14].u_addr.ip6.zone = _15;
  _16 = (int) i;
  netif->ip6_addr[_16].type = 6;
  _17 = (int) i;
  _18 = netif->ip6_addr[_17].u_addr.ip6.addr[0];
  _19 = _18 & 49407;
  if (_19 == 33022)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _20 = netif->num;
  iftmp.18 = _20 + 1;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.18 = 0;

  <bb 15> :
  _21 = (int) i;
  netif->ip6_addr[_21].u_addr.ip6.zone = iftmp.18;
  netif_ip6_addr_set_state (netif, i, 8);
  if (chosen_idx != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  *chosen_idx = i;

  <bb 17> :
  D.8501 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 18> :
  i.19_22 = i;
  i.20_23 = (unsigned char) i.19_22;
  _24 = i.20_23 + 1;
  i = (s8_t) _24;

  <bb 19> :
  if (i <= 2)
    goto <bb 11>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  if (chosen_idx != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  *chosen_idx = -1;

  <bb 22> :
  D.8501 = -6;

  <bb 23> :
<L22>:
  return D.8501;

}


netif_create_ip6_linklocal_address (struct netif * netif, u8_t from_mac_48bit)
{
  u8_t addr_index;
  u8_t i;
  u8_t iftmp.17;
  long unsigned int D.8487;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  netif->ip6_addr[0].u_addr.ip6.addr[0] = 33022;
  netif->ip6_addr[0].u_addr.ip6.addr[1] = 0;
  if (from_mac_48bit != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = netif->hwaddr[0];
  _2 = _1 ^ 2;
  _3 = (long unsigned int) _2;
  _4 = _3 << 24;
  _5 = netif->hwaddr[1];
  _6 = (long unsigned int) _5;
  _7 = _6 << 16;
  _8 = _4 | _7;
  _9 = netif->hwaddr[2];
  _10 = (long unsigned int) _9;
  _11 = _10 << 8;
  _12 = _8 | _11;
  _13 = _12 | 255;
  _14 = lwip_htonl (_13);
  netif->ip6_addr[0].u_addr.ip6.addr[2] = _14;
  _15 = netif->hwaddr[3];
  _16 = (long unsigned int) _15;
  _17 = _16 << 16;
  _18 = netif->hwaddr[4];
  _19 = (long unsigned int) _18;
  _20 = _19 << 8;
  _21 = _17 | _20;
  _22 = netif->hwaddr[5];
  _23 = (long unsigned int) _22;
  _24 = _21 | _23;
  _25 = _24 | 4261412864;
  _26 = lwip_htonl (_25);
  netif->ip6_addr[0].u_addr.ip6.addr[3] = _26;
  goto <bb 12>; [INV]

  <bb 6> :
  netif->ip6_addr[0].u_addr.ip6.addr[2] = 0;
  netif->ip6_addr[0].u_addr.ip6.addr[3] = 0;
  addr_index = 3;
  i = 0;
  goto <bb 10>; [INV]

  <bb 7> :
  if (i == 4)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  addr_index.15_27 = addr_index;
  addr_index = addr_index.15_27 + 255;

  <bb 9> :
  _28 = netif->hwaddr_len;
  _29 = (int) _28;
  _30 = (int) i;
  _31 = _29 - _30;
  _32 = _31 + -1;
  _33 = netif->hwaddr[_32];
  _34 = (long unsigned int) _33;
  _35 = (int) i;
  _36 = _35 & 3;
  _37 = _36 * 8;
  _38 = _34 << _37;
  D.8487 = lwip_htonl (_38);
  _39 = (int) addr_index;
  _40 = netif->ip6_addr[0].u_addr.ip6.addr[_39];
  _41 = (int) addr_index;
  _42 = D.8487 | _40;
  netif->ip6_addr[0].u_addr.ip6.addr[_41] = _42;
  i.16_43 = i;
  i = i.16_43 + 1;

  <bb 10> :
  if (i <= 7)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _44 = netif->hwaddr_len;
  if (i < _44)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  _45 = netif->ip6_addr[0].u_addr.ip6.addr[0];
  _46 = _45 & 49407;
  if (_46 == 33022)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _47 = netif->num;
  iftmp.17 = _47 + 1;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.17 = 0;

  <bb 15> :
  netif->ip6_addr[0].u_addr.ip6.zone = iftmp.17;
  netif_ip6_addr_set_state (netif, 0, 8);
  return;

}


netif_get_ip6_addr_match (struct netif * netif, const struct ip6_addr_t * ip6addr)
{
  s8_t i;
  s8_t D.8468;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (ip6addr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = ip6addr->zone;
  if (_1 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _2 = ip6addr->zone;
  _3 = netif->num;
  _4 = _3 + 1;
  if (_2 != _4)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.8468 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 9> :
  i = 0;
  goto <bb 17>; [INV]

  <bb 10> :
  _5 = (int) i;
  _6 = netif->ip6_addr_state[_5];
  if (_6 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 11> :
  _7 = (int) i;
  _8 = &netif->ip6_addr[_7].u_addr.ip6;
  _9 = MEM[(const struct ip6_addr_t *)_8].addr[0];
  _10 = ip6addr->addr[0];
  if (_9 == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 12> :
  _11 = (int) i;
  _12 = &netif->ip6_addr[_11].u_addr.ip6;
  _13 = MEM[(const struct ip6_addr_t *)_12].addr[1];
  _14 = ip6addr->addr[1];
  if (_13 == _14)
    goto <bb 13>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 13> :
  _15 = (int) i;
  _16 = &netif->ip6_addr[_15].u_addr.ip6;
  _17 = MEM[(const struct ip6_addr_t *)_16].addr[2];
  _18 = ip6addr->addr[2];
  if (_17 == _18)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _19 = (int) i;
  _20 = &netif->ip6_addr[_19].u_addr.ip6;
  _21 = MEM[(const struct ip6_addr_t *)_20].addr[3];
  _22 = ip6addr->addr[3];
  if (_21 == _22)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  D.8468 = i;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 16> :
  i.13_23 = i;
  i.14_24 = (unsigned char) i.13_23;
  _25 = i.14_24 + 1;
  i = (s8_t) _25;

  <bb 17> :
  if (i <= 2)
    goto <bb 10>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  D.8468 = -1;

  <bb 19> :
<L23>:
  return D.8468;

}


netif_ip6_addr_set_state (struct netif * netif, s8_t addr_idx, u8_t state)
{
  u8_t new_valid;
  u8_t old_valid;
  u8_t old_state;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (addr_idx > 2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = (int) addr_idx;
  old_state = netif->ip6_addr_state[_1];
  if (old_state != state)
    goto <bb 7>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 7> :
  old_valid = old_state & 16;
  new_valid = state & 16;
  _2 = netif->flags;
  _3 = (unsigned int) _2;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  nd6_adjust_mld_membership (netif, addr_idx, state);

  <bb 9> :
  if (old_valid != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  if (new_valid == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _5 = (int) addr_idx;
  _6 = &netif->ip6_addr[_5];
  netif_do_ip_addr_changed (_6, 0B);

  <bb 12> :
  _7 = (int) addr_idx;
  netif->ip6_addr_state[_7] = state;
  if (old_valid == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  if (new_valid != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  netif_issue_reports (netif, 2);

  <bb 15> :
  _8 = old_state ^ state;
  _9 = (int) _8;
  _10 = _9 & -8;

  <bb 16> :
  return;

}


netif_ip6_addr_set_parts (struct netif * netif, s8_t addr_idx, u32_t i0, u32_t i1, u32_t i2, u32_t i3)
{
  struct ip_addr_t new_ipaddr;
  struct ip_addr_t old_addr;
  u8_t iftmp.12;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (addr_idx > 2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = (int) addr_idx;
  _2 = &netif->ip6_addr[_1].u_addr.ip6;
  _3 = MEM[(const struct ip6_addr_t *)_2].addr[0];
  old_addr.u_addr.ip6.addr[0] = _3;
  _4 = (int) addr_idx;
  _5 = &netif->ip6_addr[_4].u_addr.ip6;
  _6 = MEM[(const struct ip6_addr_t *)_5].addr[1];
  old_addr.u_addr.ip6.addr[1] = _6;
  _7 = (int) addr_idx;
  _8 = &netif->ip6_addr[_7].u_addr.ip6;
  _9 = MEM[(const struct ip6_addr_t *)_8].addr[2];
  old_addr.u_addr.ip6.addr[2] = _9;
  _10 = (int) addr_idx;
  _11 = &netif->ip6_addr[_10].u_addr.ip6;
  _12 = MEM[(const struct ip6_addr_t *)_11].addr[3];
  old_addr.u_addr.ip6.addr[3] = _12;
  _13 = (int) addr_idx;
  _14 = &netif->ip6_addr[_13].u_addr.ip6;
  _15 = MEM[(const struct ip6_addr_t *)_14].zone;
  old_addr.u_addr.ip6.zone = _15;
  old_addr.type = 6;
  _16 = old_addr.u_addr.ip6.addr[0];
  if (i0 != _16)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _17 = old_addr.u_addr.ip6.addr[1];
  if (i1 != _17)
    goto <bb 10>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _18 = old_addr.u_addr.ip6.addr[2];
  if (i2 != _18)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _19 = old_addr.u_addr.ip6.addr[3];
  if (i3 != _19)
    goto <bb 10>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 10> :
  new_ipaddr.u_addr.ip6.addr[0] = i0;
  new_ipaddr.u_addr.ip6.addr[1] = i1;
  new_ipaddr.u_addr.ip6.addr[2] = i2;
  new_ipaddr.u_addr.ip6.addr[3] = i3;
  new_ipaddr.u_addr.ip6.zone = 0;
  new_ipaddr.type = 6;
  _20 = new_ipaddr.u_addr.ip6.addr[0];
  _21 = _20 & 49407;
  if (_21 == 33022)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _22 = netif->num;
  iftmp.12 = _22 + 1;
  goto <bb 13>; [INV]

  <bb 12> :
  iftmp.12 = 0;

  <bb 13> :
  new_ipaddr.u_addr.ip6.zone = iftmp.12;
  _23 = (int) addr_idx;
  _24 = netif->ip6_addr_state[_23];
  _25 = (int) _24;
  _26 = _25 & 16;
  if (_26 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _27 = (int) addr_idx;
  _28 = &netif->ip6_addr[_27];
  netif_do_ip_addr_changed (_28, &new_ipaddr);

  <bb 15> :
  _29 = (int) addr_idx;
  _30 = new_ipaddr.type;
  netif->ip6_addr[_29].type = _30;
  _31 = new_ipaddr.type;
  if (_31 == 6)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _32 = (int) addr_idx;
  _33 = new_ipaddr.u_addr.ip6.addr[0];
  netif->ip6_addr[_32].u_addr.ip6.addr[0] = _33;
  _34 = (int) addr_idx;
  _35 = new_ipaddr.u_addr.ip6.addr[1];
  netif->ip6_addr[_34].u_addr.ip6.addr[1] = _35;
  _36 = (int) addr_idx;
  _37 = new_ipaddr.u_addr.ip6.addr[2];
  netif->ip6_addr[_36].u_addr.ip6.addr[2] = _37;
  _38 = (int) addr_idx;
  _39 = new_ipaddr.u_addr.ip6.addr[3];
  netif->ip6_addr[_38].u_addr.ip6.addr[3] = _39;
  _40 = (int) addr_idx;
  _41 = new_ipaddr.u_addr.ip6.zone;
  netif->ip6_addr[_40].u_addr.ip6.zone = _41;
  goto <bb 18>; [INV]

  <bb 17> :
  _42 = (int) addr_idx;
  _43 = new_ipaddr.u_addr.ip4.addr;
  netif->ip6_addr[_42].u_addr.ip4.addr = _43;
  _44 = (int) addr_idx;
  netif->ip6_addr[_44].u_addr.ip6.addr[3] = 0;
  _45 = (int) addr_idx;
  _46 = netif->ip6_addr[_44].u_addr.ip6.addr[3];
  netif->ip6_addr[_45].u_addr.ip6.addr[2] = _46;
  _47 = (int) addr_idx;
  _48 = netif->ip6_addr[_45].u_addr.ip6.addr[2];
  netif->ip6_addr[_47].u_addr.ip6.addr[1] = _48;
  _49 = (int) addr_idx;
  netif->ip6_addr[_49].u_addr.ip6.zone = 0;

  <bb 18> :
  _50 = (int) addr_idx;
  _51 = netif->ip6_addr_state[_50];
  _52 = (int) _51;
  _53 = _52 & 16;
  if (_53 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  netif_issue_reports (netif, 2);

  <bb 20> :
  old_addr = {CLOBBER};
  new_ipaddr = {CLOBBER};
  return;

}


netif_ip6_addr_set (struct netif * netif, s8_t addr_idx, const struct ip6_addr_t * addr6)
{
  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (addr6 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = addr6->addr[0];
  _2 = addr6->addr[1];
  _3 = addr6->addr[2];
  _4 = addr6->addr[3];
  netif_ip6_addr_set_parts (netif, addr_idx, _1, _2, _3, _4);
  return;

}


netif_alloc_client_data_id ()
{
  u8_t result;
  u8_t D.8416;

  <bb 2> :
  result = netif_client_id;
  netif_client_id.10_1 = netif_client_id;
  netif_client_id.11_2 = netif_client_id.10_1;
  _3 = netif_client_id.11_2 + 1;
  netif_client_id = _3;
  if (result != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  D.8416 = result + 2;

  <bb 5> :
<L3>:
  return D.8416;

}


netif_set_link_down (struct netif * netif)
{
  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 4;
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _4 = netif->flags;
  _5 = _4 & 251;
  netif->flags = _5;
  _6 = netif->mtu;
  netif->mtu6 = _6;

  <bb 6> :
<L4>:
  return;

}


netif_set_link_up (struct netif * netif)
{
  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 4;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _4 = netif->flags;
  _5 = _4 | 4;
  netif->flags = _5;
  netif_issue_reports (netif, 3);
  nd6_restart_netif (netif);

  <bb 6> :
<L4>:
  return;

}


netif_set_down (struct netif * netif)
{
  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 1;
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _4 = netif->flags;
  _5 = _4 & 254;
  netif->flags = _5;
  _6 = sys_now ();
  _7 = _6 / 10;
  netif->ts = _7;
  _8 = netif->flags;
  _9 = (unsigned int) _8;
  _10 = _9 & 8;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  etharp_cleanup_netif (netif);

  <bb 7> :
  nd6_cleanup_netif (netif);

  <bb 8> :
<L6>:
  return;

}


netif_issue_reports (struct netif * netif, u8_t report_type)
{
  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 4;
  if (_3 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _4 = netif->flags;
  _5 = (unsigned int) _4;
  _6 = _5 & 1;
  if (_6 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 7> :
  _7 = (int) report_type;
  _8 = _7 & 1;
  if (_8 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 8> :
  _9 = &netif->ip_addr.u_addr.ip4;
  _10 = MEM[(const struct ip4_addr_t *)_9].addr;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _11 = netif->flags;
  _12 = (unsigned int) _11;
  _13 = _12 & 8;
  if (_13 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _14 = &netif->ip_addr.u_addr.ip4;
  etharp_request (netif, _14);

  <bb 11> :
  _15 = netif->flags;
  _16 = (unsigned int) _15;
  _17 = _16 & 32;
  if (_17 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  igmp_report_groups (netif);

  <bb 13> :
  _18 = (int) report_type;
  _19 = _18 & 2;
  if (_19 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  mld6_report_groups (netif);

  <bb 15> :
<L16>:
  return;

}


netif_set_up (struct netif * netif)
{
  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 1;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _4 = netif->flags;
  _5 = _4 | 1;
  netif->flags = _5;
  _6 = sys_now ();
  _7 = _6 / 10;
  netif->ts = _7;
  netif_issue_reports (netif, 3);
  nd6_restart_netif (netif);

  <bb 6> :
<L4>:
  return;

}


netif_set_default (struct netif * netif)
{
  <bb 2> :

  <bb 3> :
  netif_default = netif;
  return;

}


netif_remove (struct netif * netif)
{
  struct netif * tmp_netif;
  int i;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 26>; [INV]

  <bb 4> :
  _1 = &netif->ip_addr.u_addr.ip4;
  _2 = MEM[(const struct ip4_addr_t *)_1].addr;
  if (_2 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _3 = &netif->ip_addr;
  netif_do_ip_addr_changed (_3, 0B);

  <bb 6> :
  _4 = netif->flags;
  _5 = (unsigned int) _4;
  _6 = _5 & 32;
  if (_6 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  igmp_stop (netif);

  <bb 8> :
  i = 0;
  goto <bb 12>; [INV]

  <bb 9> :
  _7 = netif->ip6_addr_state[i];
  _8 = (int) _7;
  _9 = _8 & 16;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _10 = &netif->ip6_addr[i];
  netif_do_ip_addr_changed (_10, 0B);

  <bb 11> :
  i = i + 1;

  <bb 12> :
  if (i <= 2)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  mld6_stop (netif);
  _11 = netif->flags;
  _12 = (_Bool) _11;
  if (_12 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  netif_set_down (netif);

  <bb 15> :
  netif_default.8_13 = netif_default;
  if (netif == netif_default.8_13)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  netif_set_default (0B);

  <bb 17> :
  netif_list.9_14 = netif_list;
  if (netif == netif_list.9_14)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  _15 = netif->next;
  netif_list = _15;
  goto <bb 26>; [INV]

  <bb 19> :
  tmp_netif = netif_list;
  goto <bb 23>; [INV]

  <bb 20> :
  _16 = tmp_netif->next;
  if (netif == _16)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  _17 = netif->next;
  tmp_netif->next = _17;
  goto <bb 24>; [INV]

  <bb 22> :
  tmp_netif = tmp_netif->next;

  <bb 23> :
  if (tmp_netif != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  if (tmp_netif == 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  // predicted unlikely by early return (on trees) predictor.

  <bb 26> :
<L25>:
  return;

}


netif_set_addr (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct ip4_addr_t * netmask, const struct ip4_addr_t * gw)
{
  int remove;
  struct ip_addr_t old_addr;
  struct ip_addr_t * old_gw;
  struct ip_addr_t * old_nm;
  int iftmp.7;

  <bb 2> :
  old_nm = 0B;
  old_gw = 0B;
  if (ipaddr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ipaddr = &ip_addr_any.u_addr.ip4;

  <bb 4> :
  if (netmask == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  netmask = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  if (gw == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  gw = &ip_addr_any.u_addr.ip4;

  <bb 8> :
  if (ipaddr == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _1 = ipaddr->addr;
  if (_1 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  iftmp.7 = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  iftmp.7 = 0;

  <bb 12> :
  remove = iftmp.7;
  if (remove != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _2 = netif_do_set_ipaddr (netif, ipaddr, &old_addr);

  <bb 14> :
  _3 = netif_do_set_netmask (netif, netmask, old_nm);

  <bb 15> :
  _4 = netif_do_set_gw (netif, gw, old_gw);

  <bb 16> :
  if (remove == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _5 = netif_do_set_ipaddr (netif, ipaddr, &old_addr);

  <bb 18> :
  old_addr = {CLOBBER};
  return;

}


netif_set_gw (struct netif * netif, const struct ip4_addr_t * gw)
{
  struct ip_addr_t * old_gw;

  <bb 2> :
  old_gw = 0B;
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  if (gw == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  gw = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  _1 = netif_do_set_gw (netif, gw, old_gw);

  <bb 7> :
<L6>:
  return;

}


netif_do_set_gw (struct netif * netif, const struct ip4_addr_t * gw, struct ip_addr_t * old_gw)
{
  int D.8321;
  const long unsigned int iftmp.6;

  <bb 2> :
  _1 = gw->addr;
  _2 = &netif->gw.u_addr.ip4;
  _3 = MEM[(const struct ip4_addr_t *)_2].addr;
  if (_1 != _3)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  if (gw != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.6 = gw->addr;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.6 = 0;

  <bb 6> :
  netif->gw.u_addr.ip4.addr = iftmp.6;
  netif->gw.type = 0;
  D.8321 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  D.8321 = 0;

  <bb 8> :
<L5>:
  return D.8321;

}


netif_set_netmask (struct netif * netif, const struct ip4_addr_t * netmask)
{
  struct ip_addr_t * old_nm;

  <bb 2> :
  old_nm = 0B;
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  if (netmask == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  netmask = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  _1 = netif_do_set_netmask (netif, netmask, old_nm);

  <bb 7> :
<L6>:
  return;

}


netif_do_set_netmask (struct netif * netif, const struct ip4_addr_t * netmask, struct ip_addr_t * old_nm)
{
  int D.8306;
  const long unsigned int iftmp.5;

  <bb 2> :
  _1 = netmask->addr;
  _2 = &netif->netmask.u_addr.ip4;
  _3 = MEM[(const struct ip4_addr_t *)_2].addr;
  if (_1 != _3)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  if (netmask != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.5 = netmask->addr;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.5 = 0;

  <bb 6> :
  netif->netmask.u_addr.ip4.addr = iftmp.5;
  netif->netmask.type = 0;
  D.8306 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  D.8306 = 0;

  <bb 8> :
<L5>:
  return D.8306;

}


netif_set_ipaddr (struct netif * netif, const struct ip4_addr_t * ipaddr)
{
  struct ip_addr_t old_addr;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  old_addr = {CLOBBER};
  goto <bb 7>; [INV]

  <bb 4> :
  if (ipaddr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  ipaddr = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  _1 = netif_do_set_ipaddr (netif, ipaddr, &old_addr);
  old_addr = {CLOBBER};

  <bb 7> :
<L8>:
  return;

}


netif_do_set_ipaddr (struct netif * netif, const struct ip4_addr_t * ipaddr, struct ip_addr_t * old_addr)
{
  struct ip_addr_t new_addr;
  int D.8288;
  const long unsigned int iftmp.4;

  <bb 2> :
  if (ipaddr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (old_addr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = ipaddr->addr;
  _2 = &netif->ip_addr.u_addr.ip4;
  _3 = MEM[(const struct ip4_addr_t *)_2].addr;
  if (_1 != _3)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 7> :
  new_addr.u_addr.ip4 = *ipaddr;
  new_addr.type = 0;
  _4 = &netif->ip_addr;
  _5 = MEM[(const struct ip_addr_t *)_4].type;
  old_addr->type = _5;
  _6 = &netif->ip_addr;
  _7 = MEM[(const struct ip_addr_t *)_6].type;
  if (_7 == 6)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _8 = &netif->ip_addr;
  _9 = MEM[(const struct ip_addr_t *)_8].u_addr.ip6.addr[0];
  old_addr->u_addr.ip6.addr[0] = _9;
  _10 = &netif->ip_addr;
  _11 = MEM[(const struct ip_addr_t *)_10].u_addr.ip6.addr[1];
  old_addr->u_addr.ip6.addr[1] = _11;
  _12 = &netif->ip_addr;
  _13 = MEM[(const struct ip_addr_t *)_12].u_addr.ip6.addr[2];
  old_addr->u_addr.ip6.addr[2] = _13;
  _14 = &netif->ip_addr;
  _15 = MEM[(const struct ip_addr_t *)_14].u_addr.ip6.addr[3];
  old_addr->u_addr.ip6.addr[3] = _15;
  _16 = &netif->ip_addr;
  _17 = MEM[(const struct ip_addr_t *)_16].u_addr.ip6.zone;
  old_addr->u_addr.ip6.zone = _17;
  goto <bb 10>; [INV]

  <bb 9> :
  _18 = &netif->ip_addr;
  _19 = MEM[(const struct ip_addr_t *)_18].u_addr.ip4.addr;
  old_addr->u_addr.ip4.addr = _19;
  old_addr->u_addr.ip6.addr[3] = 0;
  _20 = old_addr->u_addr.ip6.addr[3];
  old_addr->u_addr.ip6.addr[2] = _20;
  _21 = old_addr->u_addr.ip6.addr[2];
  old_addr->u_addr.ip6.addr[1] = _21;
  old_addr->u_addr.ip6.zone = 0;

  <bb 10> :
  netif_do_ip_addr_changed (old_addr, &new_addr);
  if (ipaddr != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  iftmp.4 = ipaddr->addr;
  goto <bb 13>; [INV]

  <bb 12> :
  iftmp.4 = 0;

  <bb 13> :
  netif->ip_addr.u_addr.ip4.addr = iftmp.4;
  netif->ip_addr.type = 0;
  netif_issue_reports (netif, 1);
  D.8288 = 1;
  // predicted unlikely by early return (on trees) predictor.
  new_addr = {CLOBBER};
  goto <bb 15>; [INV]

  <bb 14> :
  D.8288 = 0;

  <bb 15> :
<L15>:
  return D.8288;

}


netif_do_ip_addr_changed (const struct ip_addr_t * old_addr, const struct ip_addr_t * new_addr)
{
  <bb 2> :
  tcp_netif_ip_addr_changed (old_addr, new_addr);
  udp_netif_ip_addr_changed (old_addr, new_addr);
  raw_netif_ip_addr_changed (old_addr, new_addr);
  return;

}


netif_add (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct ip4_addr_t * netmask, const struct ip4_addr_t * gw, void * state, err_t (*netif_init_fn) (struct netif *) init, err_t (*netif_input_fn) (struct pbuf *, struct netif *) input)
{
  int num_netifs;
  struct netif * netif2;
  s8_t i;
  struct netif * D.8242;

  <bb 2> :
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.8242 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 44>; [INV]

  <bb 4> :
  if (init == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8242 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 44>; [INV]

  <bb 6> :
  if (ipaddr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  ipaddr = &ip_addr_any.u_addr.ip4;

  <bb 8> :
  if (netmask == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  netmask = &ip_addr_any.u_addr.ip4;

  <bb 10> :
  if (gw == 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  gw = &ip_addr_any.u_addr.ip4;

  <bb 12> :
  netif->ip_addr.u_addr.ip6.addr[0] = 0;
  netif->ip_addr.u_addr.ip6.addr[1] = 0;
  netif->ip_addr.u_addr.ip6.addr[2] = 0;
  netif->ip_addr.u_addr.ip6.addr[3] = 0;
  netif->ip_addr.u_addr.ip6.zone = 0;
  _1 = &netif->ip_addr;
  if (_1 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  netif->ip_addr.type = 0;

  <bb 14> :
  netif->netmask.u_addr.ip6.addr[0] = 0;
  netif->netmask.u_addr.ip6.addr[1] = 0;
  netif->netmask.u_addr.ip6.addr[2] = 0;
  netif->netmask.u_addr.ip6.addr[3] = 0;
  netif->netmask.u_addr.ip6.zone = 0;
  _2 = &netif->netmask;
  if (_2 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  netif->netmask.type = 0;

  <bb 16> :
  netif->gw.u_addr.ip6.addr[0] = 0;
  netif->gw.u_addr.ip6.addr[1] = 0;
  netif->gw.u_addr.ip6.addr[2] = 0;
  netif->gw.u_addr.ip6.addr[3] = 0;
  netif->gw.u_addr.ip6.zone = 0;
  _3 = &netif->gw;
  if (_3 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  netif->gw.type = 0;

  <bb 18> :
  netif->output = netif_null_output_ip4;
  i = 0;
  goto <bb 22>; [INV]

  <bb 19> :
  _4 = (int) i;
  netif->ip6_addr[_4].u_addr.ip6.addr[0] = 0;
  _5 = (int) i;
  netif->ip6_addr[_5].u_addr.ip6.addr[1] = 0;
  _6 = (int) i;
  netif->ip6_addr[_6].u_addr.ip6.addr[2] = 0;
  _7 = (int) i;
  netif->ip6_addr[_7].u_addr.ip6.addr[3] = 0;
  _8 = (int) i;
  netif->ip6_addr[_8].u_addr.ip6.zone = 0;
  _9 = (int) i;
  _10 = &netif->ip6_addr[_9];
  if (_10 != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _11 = (int) i;
  netif->ip6_addr[_11].type = 6;

  <bb 21> :
  _12 = (int) i;
  netif->ip6_addr_state[_12] = 0;
  _13 = (int) i;
  netif->ip6_addr_valid_life[_13] = 0;
  _14 = (int) i;
  netif->ip6_addr_pref_life[_14] = 0;
  i.0_15 = i;
  i.1_16 = (unsigned char) i.0_15;
  _17 = i.1_16 + 1;
  i = (s8_t) _17;

  <bb 22> :
  if (i <= 2)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  netif->output_ip6 = netif_null_output_ip6;
  netif->mtu = 0;
  netif->flags = 0;
  _18 = &netif->client_data;
  memset (_18, 0, 12);
  netif->ip6_autoconfig_enabled = 0;
  nd6_restart_netif (netif);
  netif->igmp_mac_filter = 0B;
  netif->mld_mac_filter = 0B;
  netif->state = state;
  netif_num.2_19 = netif_num;
  netif->num = netif_num.2_19;
  netif->input = input;
  netif_set_addr (netif, ipaddr, netmask, gw);
  _20 = init (netif);
  if (_20 != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  D.8242 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 44>; [INV]

  <bb 25> :
  _21 = netif->mtu;
  netif->mtu6 = _21;

  <bb 26> :
  _22 = netif->num;
  if (_22 == 255)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  netif->num = 0;

  <bb 28> :
  num_netifs = 0;
  netif2 = netif_list;
  goto <bb 36>; [INV]

  <bb 29> :
  if (netif2 == netif)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 30>; [INV]

  <bb 31> :
  num_netifs = num_netifs + 1;
  if (num_netifs > 255)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 32>; [INV]

  <bb 33> :
  _23 = netif2->num;
  _24 = netif->num;
  if (_23 == _24)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  _25 = netif->num;
  _26 = _25;
  _27 = _26 + 1;
  netif->num = _27;
  goto <bb 37>; [INV]

  <bb 35> :
  netif2 = netif2->next;

  <bb 36> :
  if (netif2 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 37> :
  if (netif2 != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  _28 = netif->num;
  if (_28 == 254)
    goto <bb 39>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 39> :
  netif_num = 0;
  goto <bb 41>; [INV]

  <bb 40> :
  _29 = netif->num;
  _30 = _29 + 1;
  netif_num = _30;

  <bb 41> :
  netif_list.3_31 = netif_list;
  netif->next = netif_list.3_31;
  netif_list = netif;
  _32 = netif->flags;
  _33 = (unsigned int) _32;
  _34 = _33 & 32;
  if (_34 != 0)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  igmp_start (netif);

  <bb 43> :
  D.8242 = netif;

  <bb 44> :
<L43>:
  return D.8242;

}


netif_add_noaddr (struct netif * netif, void * state, err_t (*netif_init_fn) (struct netif *) init, err_t (*netif_input_fn) (struct pbuf *, struct netif *) input)
{
  struct netif * D.8238;

  <bb 2> :
  D.8238 = netif_add (netif, 0B, 0B, 0B, state, init, input);

  <bb 3> :
<L0>:
  return D.8238;

}


netif_input (struct pbuf * p, struct netif * inp)
{
  err_t D.8236;

  <bb 2> :
  if (p == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (inp == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = inp->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 24;
  if (_3 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.8236 = ethernet_input (p, inp);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  D.8236 = ip_input (p, inp);
  // predicted unlikely by early return (on trees) predictor.

  <bb 9> :
<L8>:
  return D.8236;

}


netif_init ()
{
  <bb 2> :
  return;

}


