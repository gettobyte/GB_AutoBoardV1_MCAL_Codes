
Marking local functions:


Marking externally visible functions: mem_calloc/13 mem_malloc/12 mem_trim/11 mem_free/10 mem_init/8


Marking externally visible variables: ram_heap/1


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

memset/15 (memset) @06bc4e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: mem_calloc/13 
  Calls: 
lwip_stats/14 (lwip_stats) @06bc25e8
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: mem_init/8 (write) mem_free/10 (read) mem_free/10 (write) mem_trim/11 (read) mem_trim/11 (write) mem_trim/11 (read) mem_trim/11 (write) mem_trim/11 (read) mem_trim/11 (write) mem_malloc/12 (read) mem_malloc/12 (write) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (write) mem_malloc/12 (read) mem_malloc/12 (write) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (write) mem_malloc/12 (read) mem_malloc/12 (write) 
  Availability: not_available
  Varpool flags:
mem_calloc/13 (mem_calloc) @06b749a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: memset/15 mem_malloc/12 
mem_malloc/12 (mem_malloc) @06b74700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lfree/4 (read) lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (read) lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (read) lwip_stats/14 (read) lwip_stats/14 (write) lfree/4 (read) lfree/4 (read) ram_end/3 (read) lfree/4 (write) lfree/4 (read) ram_end/3 (read) lfree/4 (read) ram_end/3 (read) lwip_stats/14 (read) lwip_stats/14 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: mem_calloc/13 
  Calls: ptr_to_mem/5 ptr_to_mem/5 mem_to_ptr/6 ptr_to_mem/5 ptr_to_mem/5 ptr_to_mem/5 mem_to_ptr/6 
mem_trim/11 (mem_trim) @06b6c620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ram/2 (read) ram_end/3 (read) ram/2 (read) ram_end/3 (read) lwip_stats/14 (read) lwip_stats/14 (write) lfree/4 (read) lfree/4 (write) lwip_stats/14 (read) lwip_stats/14 (write) lfree/4 (read) lfree/4 (write) lwip_stats/14 (read) lwip_stats/14 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: ptr_to_mem/5 ptr_to_mem/5 ptr_to_mem/5 ptr_to_mem/5 ptr_to_mem/5 ptr_to_mem/5 mem_to_ptr/6 
mem_free/10 (mem_free) @06b667e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ram/2 (read) ram_end/3 (read) lfree/4 (read) lfree/4 (write) lwip_stats/14 (read) ram/2 (read) lwip_stats/14 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: plug_holes/7 mem_link_valid/9 
mem_link_valid/9 (mem_link_valid) @06b66000
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: ram_end/3 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: mem_free/10 
  Calls: ptr_to_mem/5 ptr_to_mem/5 mem_to_ptr/6 
mem_init/8 (mem_init) @06b5dc40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ram_heap/1 (addr) ram/2 (write) ram/2 (read) ram_end/3 (write) ram_end/3 (read) ram_end/3 (read) ram_end/3 (read) ram/2 (read) lfree/4 (write) lwip_stats/14 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: ptr_to_mem/5 
plug_holes/7 (plug_holes) @06b5d380
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: ram/2 (read) ram_end/3 (read) ram_end/3 (read) lfree/4 (read) lfree/4 (write) lfree/4 (read) lfree/4 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: mem_free/10 
  Calls: mem_to_ptr/6 ptr_to_mem/5 ptr_to_mem/5 mem_to_ptr/6 ptr_to_mem/5 ptr_to_mem/5 
mem_to_ptr/6 (mem_to_ptr) @06b59e00
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: ram/2 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: mem_malloc/12 mem_malloc/12 mem_trim/11 mem_link_valid/9 plug_holes/7 plug_holes/7 
  Calls: 
ptr_to_mem/5 (ptr_to_mem) @06b59b60
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: ram/2 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: mem_malloc/12 mem_malloc/12 mem_malloc/12 mem_malloc/12 mem_malloc/12 mem_trim/11 mem_trim/11 mem_trim/11 mem_trim/11 mem_trim/11 mem_trim/11 mem_link_valid/9 mem_link_valid/9 mem_init/8 plug_holes/7 plug_holes/7 plug_holes/7 plug_holes/7 
  Calls: 
lfree/4 (lfree) @06b5b168
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: plug_holes/7 (read) plug_holes/7 (write) plug_holes/7 (read) plug_holes/7 (write) mem_init/8 (write) mem_free/10 (read) mem_free/10 (write) mem_trim/11 (read) mem_trim/11 (write) mem_trim/11 (read) mem_trim/11 (write) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (write) mem_malloc/12 (read) mem_malloc/12 (read) 
  Availability: available
  Varpool flags:
ram_end/3 (ram_end) @06b57d80
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: plug_holes/7 (read) plug_holes/7 (read) mem_init/8 (write) mem_init/8 (read) mem_init/8 (read) mem_init/8 (read) mem_link_valid/9 (read) mem_free/10 (read) mem_trim/11 (read) mem_trim/11 (read) mem_malloc/12 (read) mem_malloc/12 (read) mem_malloc/12 (read) 
  Availability: available
  Varpool flags:
ram/2 (ram) @06b57cf0
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: ptr_to_mem/5 (read) mem_to_ptr/6 (read) plug_holes/7 (read) mem_init/8 (write) mem_init/8 (read) mem_init/8 (read) mem_free/10 (read) mem_free/10 (read) mem_trim/11 (read) mem_trim/11 (read) 
  Availability: available
  Varpool flags:
ram_heap/1 (ram_heap) @06b57c60
  Type: variable definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: mem_init/8 (addr) 
  Availability: available
  Varpool flags:
mem_calloc (mem_size_t count, mem_size_t size)
{
  size_t alloc_size;
  void * p;
  void * D.6936;

  <bb 2> :
  _1 = (unsigned int) count;
  _2 = (unsigned int) size;
  alloc_size = _1 * _2;
  _3 = (short unsigned int) alloc_size;
  _4 = (unsigned int) _3;
  if (alloc_size != _4)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.6936 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _5 = (short unsigned int) alloc_size;
  p = mem_malloc (_5);
  if (p != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  memset (p, 0, alloc_size);

  <bb 6> :
  D.6936 = p;

  <bb 7> :
<L4>:
  return D.6936;

}


mem_malloc (mem_size_t size_in)
{
  struct mem * cur;
  struct mem * mem2;
  struct mem * mem;
  mem_size_t size;
  mem_size_t ptr2;
  mem_size_t ptr;
  void * D.6899;

  <bb 2> :
  if (size_in == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.6899 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 39>; [INV]

  <bb 4> :
  _1 = size_in + 7;
  size = _1 & 65528;
  if (size <= 15)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  size = 16;

  <bb 6> :
  if (size > 20800)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (size < size_in)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.6899 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 39>; [INV]

  <bb 9> :
  lfree.24_2 = lfree;
  ptr = mem_to_ptr (lfree.24_2);
  goto <bb 37>; [INV]

  <bb 10> :
  mem = ptr_to_mem (ptr);
  _3 = mem->used;
  if (_3 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 11> :
  _4 = mem->next;
  _5 = (unsigned int) _4;
  _6 = (unsigned int) ptr;
  _7 = _5 - _6;
  _8 = _7 + 4294967288;
  _9 = (unsigned int) size;
  if (_8 >= _9)
    goto <bb 12>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 12> :
  _10 = mem->next;
  _11 = (unsigned int) _10;
  _12 = (unsigned int) ptr;
  _13 = _11 - _12;
  _14 = _13 + 4294967288;
  _15 = (unsigned int) size;
  _16 = _15 + 24;
  if (_14 >= _16)
    goto <bb 13>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 13> :
  _17 = ptr + size;
  ptr2 = _17 + 8;
  if (ptr2 == 20800)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 14>; [INV]

  <bb 15> :
  mem2 = ptr_to_mem (ptr2);
  mem2->used = 0;
  _18 = mem->next;
  mem2->next = _18;
  mem2->prev = ptr;
  mem->next = ptr2;
  mem->used = 1;
  _19 = mem2->next;
  if (_19 != 20800)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _20 = mem2->next;
  _21 = ptr_to_mem (_20);
  _21->prev = ptr2;

  <bb 17> :
  _22 = lwip_stats.mem.used;
  _23 = size + _22;
  _24 = _23 + 8;
  lwip_stats.mem.used = _24;
  _25 = lwip_stats.mem.max;
  _26 = lwip_stats.mem.used;
  if (_25 < _26)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  _27 = lwip_stats.mem.used;
  lwip_stats.mem.max = _27;
  goto <bb 21>; [INV]

  <bb 19> :
  mem->used = 1;
  _28 = lwip_stats.mem.used;
  _29 = mem->next;
  _30 = _28 + _29;
  _31 = mem_to_ptr (mem);
  _32 = _30 - _31;
  lwip_stats.mem.used = _32;
  _33 = lwip_stats.mem.max;
  _34 = lwip_stats.mem.used;
  if (_33 < _34)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _35 = lwip_stats.mem.used;
  lwip_stats.mem.max = _35;

  <bb 21> :
  lfree.25_36 = lfree;
  if (mem == lfree.25_36)
    goto <bb 22>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 22> :
  cur = lfree;
  goto <bb 24>; [INV]

  <bb 23> :
  _37 = cur->next;
  cur = ptr_to_mem (_37);

  <bb 24> :
  _38 = cur->used;
  if (_38 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  ram_end.26_39 = ram_end;
  if (cur != ram_end.26_39)
    goto <bb 23>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  lfree = cur;
  lfree.27_40 = lfree;
  ram_end.28_41 = ram_end;
  if (lfree.27_40 != ram_end.28_41)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 27> :
  lfree.29_42 = lfree;
  _43 = lfree.29_42->used;
  if (_43 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 28>; [INV]

  <bb 29> :
  _44 = (unsigned int) size;
  mem.30_45 = (unsigned int) mem;
  _46 = _44 + mem.30_45;
  _47 = _46 + 8;
  ram_end.31_48 = ram_end;
  ram_end.32_49 = (unsigned int) ram_end.31_48;
  if (_47 > ram_end.32_49)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 30>; [INV]

  <bb 31> :
  mem.33_50 = (unsigned int) mem;
  _51 = mem.33_50 & 7;
  if (_51 != 0)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 32>; [INV]

  <bb 33> :
  mem.34_52 = (unsigned int) mem;
  _53 = mem.34_52 & 7;
  if (_53 != 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 34>; [INV]

  <bb 35> :
  D.6899 = mem + 8;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 39>; [INV]

  <bb 36> :
  _54 = ptr_to_mem (ptr);
  ptr = _54->next;

  <bb 37> :
  _55 = (unsigned int) ptr;
  _56 = (unsigned int) size;
  _57 = 20800 - _56;
  if (_55 < _57)
    goto <bb 10>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  _58 = lwip_stats.mem.err;
  _59 = _58 + 1;
  lwip_stats.mem.err = _59;
  D.6899 = 0B;

  <bb 39> :
<L46>:
  return D.6899;

}


mem_trim (void * rmem, mem_size_t new_size)
{
  mem_size_t next;
  struct mem * mem2;
  struct mem * mem;
  mem_size_t ptr2;
  mem_size_t ptr;
  mem_size_t newsize;
  mem_size_t size;
  void * D.6866;

  <bb 2> :
  _1 = new_size + 7;
  newsize = _1 & 65528;
  if (newsize <= 15)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  newsize = 16;

  <bb 4> :
  if (newsize > 20800)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  if (newsize < new_size)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.6866 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 7> :
  ram.18_2 = ram;
  if (rmem < ram.18_2)
    goto <bb 9>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  ram_end.19_3 = ram_end;
  if (rmem >= ram_end.19_3)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  ram.20_4 = ram;
  if (rmem < ram.20_4)
    goto <bb 12>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  ram_end.21_5 = ram_end;
  if (rmem >= ram_end.21_5)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _6 = lwip_stats.mem.illegal;
  _7 = _6 + 1;
  lwip_stats.mem.illegal = _7;
  D.6866 = rmem;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 13> :
  mem = rmem + 4294967288;
  ptr = mem_to_ptr (mem);
  _8 = mem->next;
  _9 = _8 - ptr;
  size = _9 + 65528;
  if (newsize > size)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 14>; [INV]

  <bb 15> :
  if (newsize > size)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  D.6866 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 17> :
  if (newsize == size)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  D.6866 = rmem;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 36>; [INV]

  <bb 19> :
  _10 = mem->next;
  mem2 = ptr_to_mem (_10);
  _11 = mem2->used;
  if (_11 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 20> :
  _12 = mem->next;
  if (_12 == 20800)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 21>; [INV]

  <bb 22> :
  next = mem2->next;
  _13 = ptr + newsize;
  ptr2 = _13 + 8;
  lfree.22_14 = lfree;
  if (mem2 == lfree.22_14)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _15 = ptr_to_mem (ptr2);
  lfree = _15;

  <bb 24> :
  mem2 = ptr_to_mem (ptr2);
  mem2->used = 0;
  mem2->next = next;
  mem2->prev = ptr;
  mem->next = ptr2;
  _16 = mem2->next;
  if (_16 != 20800)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  _17 = mem2->next;
  _18 = ptr_to_mem (_17);
  _18->prev = ptr2;

  <bb 26> :
  _19 = lwip_stats.mem.used;
  _20 = newsize - size;
  _21 = _19 + _20;
  lwip_stats.mem.used = _21;
  goto <bb 35>; [INV]

  <bb 27> :
  _22 = (unsigned int) newsize;
  _23 = _22 + 24;
  _24 = (unsigned int) size;
  if (_23 <= _24)
    goto <bb 28>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 28> :
  _25 = ptr + newsize;
  ptr2 = _25 + 8;
  _26 = mem->next;
  if (_26 == 20800)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 29>; [INV]

  <bb 30> :
  mem2 = ptr_to_mem (ptr2);
  lfree.23_27 = lfree;
  if (mem2 < lfree.23_27)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  lfree = mem2;

  <bb 32> :
  mem2->used = 0;
  _28 = mem->next;
  mem2->next = _28;
  mem2->prev = ptr;
  mem->next = ptr2;
  _29 = mem2->next;
  if (_29 != 20800)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _30 = mem2->next;
  _31 = ptr_to_mem (_30);
  _31->prev = ptr2;

  <bb 34> :
  _32 = lwip_stats.mem.used;
  _33 = newsize - size;
  _34 = _32 + _33;
  lwip_stats.mem.used = _34;

  <bb 35> :
  D.6866 = rmem;

  <bb 36> :
<L38>:
  return D.6866;

}


mem_free (void * rmem)
{
  struct mem * mem;

  <bb 2> :
  if (rmem == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 16>; [INV]

  <bb 4> :
  rmem.13_1 = (unsigned int) rmem;
  _2 = rmem.13_1 & 7;
  if (_2 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  mem = rmem + 4294967288;
  ram.14_5 = ram;
  if (mem < ram.14_5)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _6 = rmem + 16;
  ram_end.15_7 = ram_end;
  if (_6 > ram_end.15_7)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 8>; [INV]

  <bb 9> :
  _10 = mem->used;
  if (_10 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 10>; [INV]

  <bb 11> :
  _13 = mem_link_valid (mem);
  if (_13 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 12>; [INV]

  <bb 13> :
  mem->used = 0;
  lfree.16_16 = lfree;
  if (mem < lfree.16_16)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  lfree = mem;

  <bb 15> :
  _17 = lwip_stats.mem.used;
  ram.17_18 = ram;
  _19 = mem - ram.17_18;
  _20 = (short unsigned int) _19;
  _21 = mem->next;
  _22 = _20 - _21;
  _23 = _17 + _22;
  lwip_stats.mem.used = _23;
  plug_holes (mem);

  <bb 16> :
<L25>:
  return;

}


mem_link_valid (struct mem * mem)
{
  mem_size_t rmem_idx;
  struct mem * pmem;
  struct mem * nmem;
  int D.6837;

  <bb 2> :
  rmem_idx = mem_to_ptr (mem);
  _1 = mem->next;
  nmem = ptr_to_mem (_1);
  _2 = mem->prev;
  pmem = ptr_to_mem (_2);
  _3 = mem->next;
  if (_3 > 20800)
    goto <bb 8>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _4 = mem->prev;
  if (_4 > 20800)
    goto <bb 8>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  _5 = mem->prev;
  if (rmem_idx != _5)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = pmem->next;
  if (rmem_idx != _6)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  ram_end.12_7 = ram_end;
  if (nmem != ram_end.12_7)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _8 = nmem->prev;
  if (rmem_idx != _8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.6837 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 9> :
  D.6837 = 1;

  <bb 10> :
<L7>:
  return D.6837;

}


mem_init ()
{
  struct mem * mem;

  <bb 2> :

  <bb 3> :
  ram_heap.7_1 = (unsigned int) &ram_heap;
  _2 = ram_heap.7_1 + 7;
  _3 = _2 & 4294967288;
  _4 = (u8_t *) _3;
  ram = _4;
  mem = ram;
  mem->next = 20800;
  mem->prev = 0;
  mem->used = 0;
  _5 = ptr_to_mem (20800);
  ram_end = _5;
  ram_end.8_6 = ram_end;
  ram_end.8_6->used = 1;
  ram_end.9_7 = ram_end;
  ram_end.9_7->next = 20800;
  ram_end.10_8 = ram_end;
  ram_end.10_8->prev = 20800;
  ram.11_9 = ram;
  lfree = ram.11_9;
  lwip_stats.mem.avail = 20800;

  <bb 4> :
  return;

}


plug_holes (struct mem * mem)
{
  struct mem * pmem;
  struct mem * nmem;

  <bb 2> :
  ram.2_1 = ram;
  if (mem < ram.2_1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  ram_end.3_2 = ram_end;
  if (mem >= ram_end.3_2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _3 = mem->used;
  if (_3 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  _4 = mem->next;
  if (_4 > 20800)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  _5 = mem->next;
  nmem = ptr_to_mem (_5);
  if (mem != nmem)
    goto <bb 11>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 11> :
  _6 = nmem->used;
  if (_6 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 12> :
  ram_end.4_7 = ram_end;
  if (nmem != ram_end.4_7)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  lfree.5_8 = lfree;
  if (nmem == lfree.5_8)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  lfree = mem;

  <bb 15> :
  _9 = nmem->next;
  mem->next = _9;
  _10 = nmem->next;
  if (_10 != 20800)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _11 = nmem->next;
  _12 = ptr_to_mem (_11);
  _13 = mem_to_ptr (mem);
  _12->prev = _13;

  <bb 17> :
  _14 = mem->prev;
  pmem = ptr_to_mem (_14);
  if (pmem != mem)
    goto <bb 18>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 18> :
  _15 = pmem->used;
  if (_15 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  lfree.6_16 = lfree;
  if (mem == lfree.6_16)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  lfree = pmem;

  <bb 21> :
  _17 = mem->next;
  pmem->next = _17;
  _18 = mem->next;
  if (_18 != 20800)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _19 = mem->next;
  _20 = ptr_to_mem (_19);
  _21 = mem_to_ptr (pmem);
  _20->prev = _21;

  <bb 23> :
  return;

}


mem_to_ptr (void * mem)
{
  mem_size_t D.6796;

  <bb 2> :
  ram.1_1 = ram;
  _2 = mem - ram.1_1;
  D.6796 = (mem_size_t) _2;

  <bb 3> :
<L0>:
  return D.6796;

}


ptr_to_mem (mem_size_t ptr)
{
  struct mem * D.6794;

  <bb 2> :
  ram.0_1 = ram;
  _2 = (sizetype) ptr;
  D.6794 = ram.0_1 + _2;

  <bb 3> :
<L0>:
  return D.6794;

}


