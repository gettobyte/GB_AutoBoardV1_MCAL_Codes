
Marking local functions:


Marking externally visible functions: tcp_zero_window_probe/24 tcp_keepalive/23 tcp_send_empty_ack/22 tcp_rst/21 tcp_rexmit_fast/16 tcp_rexmit/15 tcp_rexmit_rto/14 tcp_rexmit_rto_commit/13 tcp_rexmit_rto_prepare/12 tcp_output/9 tcp_enqueue_flags/8 tcp_send_fin/7 tcp_split_unsent_seg/6 tcp_write/5


Marking externally visible variables:


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

ip4_output_if/48 (ip4_output_if) @06e45d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output_control_segment/20 tcp_output_segment/11 
  Calls: 
ip6_output_if/47 (ip6_output_if) @06e45a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output_control_segment/20 tcp_output_segment/11 
  Calls: 
ip_chksum_pseudo/46 (ip_chksum_pseudo) @06e458c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output_control_segment/20 tcp_output_segment/11 
  Calls: 
tcp_ticks/45 (tcp_ticks) @06e78828
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: tcp_output_segment/11 (read) 
  Availability: not_available
  Varpool flags:
tcp_eff_send_mss_netif/44 (tcp_eff_send_mss_netif) @06e450e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output_segment/11 
  Calls: 
ip6_select_source_address/43 (ip6_select_source_address) @06e45b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output/9 
  Calls: 
tcp_input_pcb/42 (tcp_input_pcb) @06e6c750
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: tcp_output/9 (read) 
  Availability: not_available
  Varpool flags:
pbuf_realloc/41 (pbuf_realloc) @06e45460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_split_unsent_seg/6 
  Calls: 
pbuf_copy_partial/40 (pbuf_copy_partial) @06e45380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_zero_window_probe/24 tcp_split_unsent_seg/6 
  Calls: 
tcp_segs_free/39 (tcp_segs_free) @06e45000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_write/5 
  Calls: 
pbuf_cat/38 (pbuf_cat) @06defee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_write/5 tcp_write/5 
  Calls: 
pbuf_clen/37 (pbuf_clen) @06defe00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_enqueue_flags/8 tcp_split_unsent_seg/6 tcp_split_unsent_seg/6 tcp_split_unsent_seg/6 tcp_write/5 tcp_write/5 tcp_write/5 
  Calls: 
memcpy/36 (memcpy) @06defc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_write/5 tcp_write/5 tcp_write/5 
  Calls: 
pbuf_alloc/35 (pbuf_alloc) @06def9a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output_alloc_header_common/17 tcp_enqueue_flags/8 tcp_split_unsent_seg/6 tcp_write/5 tcp_write/5 tcp_write/5 tcp_pbuf_prealloc/3 
  Calls: 
lwip_htonl/34 (lwip_htonl) @06def7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_zero_window_probe/24 tcp_keepalive/23 tcp_send_empty_ack/22 tcp_rst/21 tcp_output_alloc_header_common/17 tcp_rexmit/15 tcp_rexmit/15 tcp_rexmit_rto_prepare/12 tcp_output_segment/11 tcp_output_segment/11 tcp_output_segment/11 tcp_output/9 tcp_output/9 tcp_output/9 tcp_output/9 tcp_output/9 tcp_output/9 tcp_output/9 tcp_split_unsent_seg/6 tcp_create_segment/2 
  Calls: 
lwip_htons/33 (lwip_htons) @06def700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_zero_window_probe/24 tcp_zero_window_probe/24 tcp_output_alloc_header_common/17 tcp_output_alloc_header_common/17 tcp_output_alloc_header_common/17 tcp_output_alloc_header_common/17 tcp_rexmit_rto_prepare/12 tcp_output_segment/11 tcp_output/9 tcp_output/9 tcp_output/9 tcp_output/9 tcp_send_fin/7 tcp_send_fin/7 tcp_split_unsent_seg/6 tcp_split_unsent_seg/6 tcp_write/5 tcp_create_segment/2 tcp_create_segment/2 tcp_create_segment/2 
  Calls: 
tcp_seg_free/32 (tcp_seg_free) @06def620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output/9 tcp_create_segment/2 
  Calls: 
lwip_stats/31 (lwip_stats) @06e241f8
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: tcp_create_segment/2 (read) tcp_create_segment/2 (write) tcp_write_checks/4 (read) tcp_write_checks/4 (write) tcp_write/5 (read) tcp_write/5 (write) tcp_split_unsent_seg/6 (read) tcp_split_unsent_seg/6 (write) tcp_enqueue_flags/8 (read) tcp_enqueue_flags/8 (write) tcp_enqueue_flags/8 (read) tcp_enqueue_flags/8 (write) tcp_output_segment/11 (read) tcp_output_segment/11 (write) tcp_output_segment/11 (read) tcp_output_segment/11 (write) tcp_rexmit/15 (read) tcp_rexmit/15 (write) tcp_output_control_segment/20 (read) tcp_output_control_segment/20 (write) tcp_rst/21 (read) tcp_rst/21 (write) 
  Availability: not_available
  Varpool flags:
pbuf_add_header/30 (pbuf_add_header) @06def540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_create_segment/2 
  Calls: 
pbuf_free/29 (pbuf_free) @06def460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_output_control_segment/20 tcp_split_unsent_seg/6 tcp_write/5 tcp_write/5 tcp_write/5 tcp_create_segment/2 
  Calls: 
memp_malloc/28 (memp_malloc) @06def380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_create_segment/2 
  Calls: 
ip4_route/27 (ip4_route) @06def1c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_route/1 
  Calls: 
ip6_route/26 (ip6_route) @06def0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_route/1 
  Calls: 
netif_get_by_index/25 (netif_get_by_index) @06def000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: tcp_route/1 
  Calls: 
tcp_zero_window_probe/24 (tcp_zero_window_probe) @06dc0ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_output_control_segment/20 tcp_output_fill_options/19 lwip_htonl/34 pbuf_copy_partial/40 lwip_htons/33 tcp_output_alloc_header/18 lwip_htons/33 
tcp_keepalive/23 (tcp_keepalive) @06dc08c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_output_control_segment/20 tcp_output_fill_options/19 tcp_output_alloc_header/18 lwip_htonl/34 
tcp_send_empty_ack/22 (tcp_send_empty_ack) @06dc0460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_output/9 tcp_output/9 
  Calls: tcp_output_control_segment/20 tcp_output_fill_options/19 tcp_output_alloc_header/18 lwip_htonl/34 
tcp_rst/21 (tcp_rst) @06dc01c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_output_control_segment/20 tcp_output_fill_options/19 tcp_output_alloc_header_common/17 lwip_htonl/34 
tcp_output_control_segment/20 (tcp_output_control_segment) @06dae380
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_zero_window_probe/24 tcp_keepalive/23 tcp_send_empty_ack/22 tcp_rst/21 
  Calls: pbuf_free/29 ip4_output_if/48 ip6_output_if/47 ip_chksum_pseudo/46 tcp_route/1 
tcp_output_fill_options/19 (tcp_output_fill_options) @06daed20
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_zero_window_probe/24 tcp_keepalive/23 tcp_send_empty_ack/22 tcp_rst/21 
  Calls: 
tcp_output_alloc_header/18 (tcp_output_alloc_header) @06daea80
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_zero_window_probe/24 tcp_keepalive/23 tcp_send_empty_ack/22 
  Calls: tcp_output_alloc_header_common/17 
tcp_output_alloc_header_common/17 (tcp_output_alloc_header_common) @06dae7e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_rst/21 tcp_output_alloc_header/18 
  Calls: lwip_htons/33 lwip_htons/33 lwip_htonl/34 lwip_htons/33 lwip_htons/33 pbuf_alloc/35 
tcp_rexmit_fast/16 (tcp_rexmit_fast) @06dae540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_rexmit/15 
tcp_rexmit/15 (tcp_rexmit) @06dae2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_rexmit_fast/16 
  Calls: lwip_htonl/34 lwip_htonl/34 tcp_output_segment_busy/10 
tcp_rexmit_rto/14 (tcp_rexmit_rto) @06dae000
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_rexmit_rto_commit/13 tcp_rexmit_rto_prepare/12 
tcp_rexmit_rto_commit/13 (tcp_rexmit_rto_commit) @06da3a80
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_rexmit_rto/14 
  Calls: tcp_output/9 
tcp_rexmit_rto_prepare/12 (tcp_rexmit_rto_prepare) @06da3e00
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_rexmit_rto/14 
  Calls: lwip_htons/33 lwip_htonl/34 tcp_output_segment_busy/10 tcp_output_segment_busy/10 
tcp_output_segment/11 (tcp_output_segment) @06da39a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: tcp_ticks/45 (read) lwip_stats/31 (read) lwip_stats/31 (write) lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_output/9 
  Calls: ip4_output_if/48 ip6_output_if/47 ip_chksum_pseudo/46 lwip_htonl/34 lwip_htonl/34 tcp_eff_send_mss_netif/44 lwip_htons/33 lwip_htonl/34 tcp_output_segment_busy/10 
tcp_output_segment_busy/10 (tcp_output_segment_busy) @06da30e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_rexmit/15 tcp_rexmit_rto_prepare/12 tcp_rexmit_rto_prepare/12 tcp_output_segment/11 
  Calls: 
tcp_output/9 (tcp_output) @06d82e00
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: tcp_input_pcb/42 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_rexmit_rto_commit/13 
  Calls: lwip_htonl/34 tcp_seg_free/32 lwip_htonl/34 lwip_htonl/34 lwip_htonl/34 lwip_htonl/34 lwip_htons/33 lwip_htons/33 lwip_htonl/34 tcp_output_segment/11 lwip_htons/33 lwip_htons/33 tcp_send_empty_ack/22 lwip_htonl/34 ip6_select_source_address/43 tcp_route/1 tcp_send_empty_ack/22 
tcp_enqueue_flags/8 (tcp_enqueue_flags) @06d4c7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/31 (read) lwip_stats/31 (write) lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_send_fin/7 
  Calls: pbuf_clen/37 tcp_create_segment/2 pbuf_alloc/35 
tcp_send_fin/7 (tcp_send_fin) @06d4c540
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_enqueue_flags/8 lwip_htons/33 lwip_htons/33 
tcp_split_unsent_seg/6 (tcp_split_unsent_seg) @06d4c1c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: pbuf_free/29 pbuf_clen/37 pbuf_clen/37 lwip_htons/33 pbuf_realloc/41 pbuf_clen/37 tcp_create_segment/2 lwip_htonl/34 lwip_htons/33 pbuf_copy_partial/40 pbuf_alloc/35 
tcp_write/5 (tcp_write) @06d05e00
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: tcp_segs_free/39 pbuf_free/29 lwip_htons/33 pbuf_cat/38 memcpy/36 tcp_create_segment/2 pbuf_free/29 pbuf_clen/37 pbuf_cat/38 pbuf_free/29 pbuf_alloc/35 pbuf_alloc/35 memcpy/36 tcp_pbuf_prealloc/3 pbuf_clen/37 pbuf_alloc/35 pbuf_clen/37 memcpy/36 tcp_pbuf_prealloc/3 tcp_write_checks/4 
tcp_write_checks/4 (tcp_write_checks) @06d05380
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_write/5 
  Calls: 
tcp_pbuf_prealloc/3 (tcp_pbuf_prealloc) @06d050e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_write/5 tcp_write/5 
  Calls: pbuf_alloc/35 
tcp_create_segment/2 (tcp_create_segment) @06cf6e00
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: lwip_stats/31 (read) lwip_stats/31 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_enqueue_flags/8 tcp_split_unsent_seg/6 tcp_write/5 
  Calls: lwip_htons/33 lwip_htonl/34 lwip_htons/33 lwip_htons/33 tcp_seg_free/32 pbuf_add_header/30 pbuf_free/29 memp_malloc/28 
tcp_route/1 (tcp_route) @06cf6b60
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: tcp_output_control_segment/20 tcp_output/9 
  Calls: ip4_route/27 ip6_route/26 netif_get_by_index/25 
tcp_zero_window_probe (struct tcp_pcb * pcb)
{
  char * d;
  u8_t optlen;
  u32_t snd_nxt;
  u8_t is_fin;
  u16_t len;
  struct tcp_seg * seg;
  struct tcp_hdr * tcphdr;
  struct pbuf * p;
  err_t err;
  int iftmp.24;
  err_t D.8484;

  <bb 2> :
  optlen = 0;
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->remote_ip.type;

  <bb 5> :
  seg = pcb->unsent;
  if (seg == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.8484 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 7> :
  _2 = pcb->persist_probe;
  if (_2 != 255)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _3 = pcb->persist_probe;
  _4 = _3 + 1;
  pcb->persist_probe = _4;

  <bb 9> :
  _5 = seg->tcphdr;
  _6 = _5->_hdrlen_rsvd_flags;
  _7 = lwip_htons (_6);
  _8 = (unsigned char) _7;
  _9 = (unsigned int) _8;
  _10 = _9 & 1;
  if (_10 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _11 = seg->len;
  if (_11 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  iftmp.24 = 1;
  goto <bb 13>; [INV]

  <bb 12> :
  iftmp.24 = 0;

  <bb 13> :
  is_fin = (u8_t) iftmp.24;
  _12 = is_fin == 0;
  len = (u16_t) _12;
  _13 = (short unsigned int) optlen;
  _14 = seg->tcphdr;
  _15 = _14->seqno;
  p = tcp_output_alloc_header (pcb, _13, len, _15);
  if (p == 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  D.8484 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 15> :
  tcphdr = p->payload;
  if (is_fin != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _16 = tcphdr->_hdrlen_rsvd_flags;
  _17 = (signed short) _16;
  _18 = _17 & -16129;
  _19 = lwip_htons (17);
  _20 = (signed short) _19;
  _21 = _18 | _20;
  _22 = (short unsigned int) _21;
  tcphdr->_hdrlen_rsvd_flags = _22;
  goto <bb 18>; [INV]

  <bb 17> :
  _23 = p->payload;
  d = _23 + 20;
  _24 = seg->p;
  _25 = seg->p;
  _26 = _25->tot_len;
  _27 = seg->len;
  _28 = _26 - _27;
  pbuf_copy_partial (_24, d, 1, _28);

  <bb 18> :
  _29 = seg->tcphdr;
  _30 = _29->seqno;
  _31 = lwip_htonl (_30);
  snd_nxt = _31 + 1;
  _32 = pcb->snd_nxt;
  _33 = _32 - snd_nxt;
  _34 = (long int) _33;
  if (_34 < 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  pcb->snd_nxt = snd_nxt;

  <bb 20> :
  tcp_output_fill_options (pcb, p, 0, 0);
  _35 = &pcb->local_ip;
  _36 = &pcb->remote_ip;
  err = tcp_output_control_segment (pcb, p, _35, _36);
  D.8484 = err;

  <bb 21> :
<L21>:
  return D.8484;

}


tcp_keepalive (struct tcp_pcb * pcb)
{
  u8_t optlen;
  struct pbuf * p;
  err_t err;
  err_t D.8475;

  <bb 2> :
  optlen = 0;
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->remote_ip.type;

  <bb 5> :
  _2 = (short unsigned int) optlen;
  _3 = pcb->snd_nxt;
  _4 = _3 + 4294967295;
  _5 = lwip_htonl (_4);
  p = tcp_output_alloc_header (pcb, _2, 0, _5);
  if (p == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.8475 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  tcp_output_fill_options (pcb, p, 0, 0);
  _6 = &pcb->local_ip;
  _7 = &pcb->remote_ip;
  err = tcp_output_control_segment (pcb, p, _6, _7);
  D.8475 = err;

  <bb 8> :
<L8>:
  return D.8475;

}


tcp_send_empty_ack (struct tcp_pcb * pcb)
{
  u8_t num_sacks;
  u8_t optflags;
  u8_t optlen;
  struct pbuf * p;
  err_t err;
  err_t D.8463;

  <bb 2> :
  optflags = 0;
  num_sacks = 0;
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = (int) optflags;
  _2 = _1 << 2;
  _3 = (unsigned char) _2;
  optlen = _3 & 4;
  _4 = (short unsigned int) optlen;
  _5 = pcb->snd_nxt;
  _6 = lwip_htonl (_5);
  p = tcp_output_alloc_header (pcb, _4, 0, _6);
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _7 = pcb->flags;
  _8 = _7 | 3;
  pcb->flags = _8;
  D.8463 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 6> :
  tcp_output_fill_options (pcb, p, optflags, num_sacks);
  _9 = &pcb->local_ip;
  _10 = &pcb->remote_ip;
  err = tcp_output_control_segment (pcb, p, _9, _10);
  if (err != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _11 = pcb->flags;
  _12 = _11 | 3;
  pcb->flags = _12;
  goto <bb 9>; [INV]

  <bb 8> :
  _13 = pcb->flags;
  _14 = _13 & 65532;
  pcb->flags = _14;

  <bb 9> :
  D.8463 = err;

  <bb 10> :
<L8>:
  return D.8463;

}


tcp_rst (const struct tcp_pcb * pcb, u32_t seqno, u32_t ackno, const struct ip_addr_t * local_ip, const struct ip_addr_t * remote_ip, u16_t local_port, u16_t remote_port)
{
  u8_t optlen;
  u16_t wnd;
  struct pbuf * p;

  <bb 2> :
  if (local_ip == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (remote_ip == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  optlen = 0;
  wnd = 33820;
  _1 = (short unsigned int) optlen;
  _2 = lwip_htonl (seqno);
  p = tcp_output_alloc_header_common (ackno, _1, 0, _2, local_port, remote_port, 20, wnd);
  if (p == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  tcp_output_fill_options (pcb, p, 0, 0);
  _3 = lwip_stats.mib2.tcpoutrsts;
  _4 = _3 + 1;
  lwip_stats.mib2.tcpoutrsts = _4;
  tcp_output_control_segment (pcb, p, local_ip, remote_ip);

  <bb 9> :
<L8>:
  return;

}


tcp_output_control_segment (const struct tcp_pcb * pcb, struct pbuf * p, const struct ip_addr_t * src, const struct ip_addr_t * dst)
{
  struct tcp_hdr * tcphdr;
  u8_t tos;
  u8_t ttl;
  struct netif * netif;
  err_t err;
  err_t D.8450;
  err_t iftmp.23;

  <bb 2> :
  if (p == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  netif = tcp_route (pcb, src, dst);
  if (netif == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  err = -4;
  goto <bb 14>; [INV]

  <bb 6> :
  tcphdr = p->payload;
  _1 = p->tot_len;
  _2 = ip_chksum_pseudo (p, 6, _1, src, dst);
  tcphdr->chksum = _2;
  if (pcb != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  ttl = pcb->ttl;
  tos = pcb->tos;
  goto <bb 9>; [INV]

  <bb 8> :
  ttl = 255;
  tos = 0;

  <bb 9> :
  _3 = lwip_stats.tcp.xmit;
  _4 = _3 + 1;
  lwip_stats.tcp.xmit = _4;
  if (dst != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _5 = dst->type;
  if (_5 == 6)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _6 = &src->u_addr.ip6;
  _7 = &dst->u_addr.ip6;
  iftmp.23 = ip6_output_if (p, _6, _7, ttl, tos, 6, netif);
  goto <bb 13>; [INV]

  <bb 12> :
  _8 = &src->u_addr.ip4;
  _9 = &dst->u_addr.ip4;
  iftmp.23 = ip4_output_if (p, _8, _9, ttl, tos, 6, netif);

  <bb 13> :
  err = iftmp.23;

  <bb 14> :
  pbuf_free (p);
  D.8450 = err;

  <bb 15> :
<L13>:
  return D.8450;

}


tcp_output_fill_options (const struct tcp_pcb * pcb, struct pbuf * p, u8_t optflags, u8_t num_sacks)
{
  u16_t sacks_len;
  u32_t * opts;
  struct tcp_hdr * tcphdr;

  <bb 2> :
  sacks_len = 0;
  if (p == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  tcphdr = p->payload;
  opts = tcphdr + 20;
  _1 = tcphdr + 20;
  _2 = (int) sacks_len;
  _3 = _2 * 4;
  _4 = (sizetype) _3;
  _5 = (sizetype) optflags;
  _6 = _5 << 2;
  _7 = _6 & 4;
  _8 = _4 + _7;
  _9 = _1 + _8;
  if (opts != _9)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  return;

}


tcp_output_alloc_header (struct tcp_pcb * pcb, u16_t optlen, u16_t datalen, u32_t seqno_be)
{
  struct pbuf * p;
  struct pbuf * D.8431;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->rcv_nxt;
  _2 = pcb->local_port;
  _3 = pcb->remote_port;
  _4 = pcb->rcv_ann_wnd;
  p = tcp_output_alloc_header_common (_1, optlen, datalen, seqno_be, _2, _3, 16, _4);
  if (p != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _5 = pcb->rcv_nxt;
  _6 = pcb->rcv_ann_wnd;
  _7 = (long unsigned int) _6;
  _8 = _5 + _7;
  pcb->rcv_ann_right_edge = _8;

  <bb 6> :
  D.8431 = p;

  <bb 7> :
<L5>:
  return D.8431;

}


tcp_output_alloc_header_common (u32_t ackno, u16_t optlen, u16_t datalen, u32_t seqno_be, u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
  struct pbuf * p;
  struct tcp_hdr * tcphdr;
  struct pbuf * D.8425;

  <bb 2> :
  _1 = optlen + datalen;
  _2 = _1 + 20;
  p = pbuf_alloc (54, _2, 640);
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _3 = (int) optlen;
  _4 = _3 + 19;
  _5 = p->len;
  _6 = (int) _5;
  if (_4 >= _6)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 4>; [INV]

  <bb 5> :
  tcphdr = p->payload;
  _7 = lwip_htons (src_port);
  tcphdr->src = _7;
  _8 = lwip_htons (dst_port);
  tcphdr->dest = _8;
  tcphdr->seqno = seqno_be;
  _9 = lwip_htonl (ackno);
  tcphdr->ackno = _9;
  _10 = optlen / 4;
  _11 = _10 + 5;
  _12 = _11 << 12;
  _13 = (short unsigned int) flags;
  _14 = _12 | _13;
  _15 = lwip_htons (_14);
  tcphdr->_hdrlen_rsvd_flags = _15;
  _16 = lwip_htons (wnd);
  tcphdr->wnd = _16;
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

  <bb 6> :
  D.8425 = p;

  <bb 7> :
<L5>:
  return D.8425;

}


tcp_rexmit_fast (struct tcp_pcb * pcb)
{
  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->unacked;
  if (_1 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  _2 = pcb->flags;
  _3 = (unsigned int) _2;
  _4 = _3 & 4;
  if (_4 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _5 = tcp_rexmit (pcb);
  if (_5 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _6 = pcb->snd_wnd;
  _7 = pcb->cwnd;
  _8 = MIN_EXPR <_6, _7>;
  _9 = (int) _8;
  _10 = _9 / 2;
  _11 = (short unsigned int) _10;
  pcb->ssthresh = _11;
  _12 = pcb->ssthresh;
  _13 = (unsigned int) _12;
  _14 = pcb->mss;
  _15 = (unsigned int) _14;
  _16 = _15 * 2;
  if (_13 < _16)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _17 = pcb->mss;
  _18 = _17 * 2;
  pcb->ssthresh = _18;

  <bb 9> :
  _19 = pcb->ssthresh;
  _20 = pcb->mss;
  _21 = _20 * 3;
  _22 = _19 + _21;
  pcb->cwnd = _22;
  _23 = pcb->flags;
  _24 = _23 | 4;
  pcb->flags = _24;
  pcb->rtime = 0;

  <bb 10> :
  return;

}


tcp_rexmit (struct tcp_pcb * pcb)
{
  struct tcp_seg * * cur_seg;
  struct tcp_seg * seg;
  err_t D.8402;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->unacked;
  if (_1 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8402 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 6> :
  seg = pcb->unacked;
  _2 = tcp_output_segment_busy (seg);
  if (_2 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.8402 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 8> :
  _3 = seg->next;
  pcb->unacked = _3;
  cur_seg = &pcb->unsent;
  goto <bb 10>; [INV]

  <bb 9> :
  _4 = *cur_seg;
  cur_seg = &_4->next;

  <bb 10> :
  _5 = *cur_seg;
  if (_5 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _6 = *cur_seg;
  _7 = _6->tcphdr;
  _8 = _7->seqno;
  _9 = lwip_htonl (_8);
  _10 = seg->tcphdr;
  _11 = _10->seqno;
  _12 = lwip_htonl (_11);
  _13 = _9 - _12;
  _14 = (long int) _13;
  if (_14 < 0)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  _15 = *cur_seg;
  seg->next = _15;
  *cur_seg = seg;
  _16 = seg->next;
  if (_16 == 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  pcb->unsent_oversize = 0;

  <bb 14> :
  _17 = pcb->nrtx;
  if (_17 != 255)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _18 = pcb->nrtx;
  _19 = _18 + 1;
  pcb->nrtx = _19;

  <bb 16> :
  pcb->rttest = 0;
  _20 = lwip_stats.mib2.tcpretranssegs;
  _21 = _20 + 1;
  lwip_stats.mib2.tcpretranssegs = _21;
  D.8402 = 0;

  <bb 17> :
<L15>:
  return D.8402;

}


tcp_rexmit_rto (struct tcp_pcb * pcb)
{
  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = tcp_rexmit_rto_prepare (pcb);
  if (_1 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  tcp_rexmit_rto_commit (pcb);

  <bb 6> :
  return;

}


tcp_rexmit_rto_commit (struct tcp_pcb * pcb)
{
  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->nrtx;
  if (_1 != 255)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _2 = pcb->nrtx;
  _3 = _2 + 1;
  pcb->nrtx = _3;

  <bb 6> :
  tcp_output (pcb);
  return;

}


tcp_rexmit_rto_prepare (struct tcp_pcb * pcb)
{
  struct tcp_seg * seg;
  unsigned int iftmp.22;
  err_t D.8380;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->unacked;
  if (_1 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8380 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 6> :
  seg = pcb->unacked;
  goto <bb 10>; [INV]

  <bb 7> :
  _2 = tcp_output_segment_busy (seg);
  if (_2 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.8380 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 9> :
  seg = seg->next;

  <bb 10> :
  _3 = seg->next;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _4 = tcp_output_segment_busy (seg);
  if (_4 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  D.8380 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 13> :
  _5 = pcb->unsent;
  seg->next = _5;
  _6 = pcb->unacked;
  pcb->unsent = _6;
  pcb->unacked = 0B;
  _7 = pcb->flags;
  _8 = _7 | 2048;
  pcb->flags = _8;
  _9 = seg->tcphdr;
  _10 = _9->seqno;
  _11 = lwip_htonl (_10);
  _12 = seg->len;
  _13 = (unsigned int) _12;
  _14 = seg->tcphdr;
  _15 = _14->_hdrlen_rsvd_flags;
  _16 = lwip_htons (_15);
  _17 = (unsigned char) _16;
  _18 = (unsigned int) _17;
  _19 = _18 & 3;
  if (_19 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  iftmp.22 = 1;
  goto <bb 16>; [INV]

  <bb 15> :
  iftmp.22 = 0;

  <bb 16> :
  _20 = iftmp.22 + _13;
  _21 = _11 + _20;
  pcb->rto_end = _21;
  pcb->rttest = 0;
  D.8380 = 0;

  <bb 17> :
<L15>:
  return D.8380;

}


tcp_output_segment (struct tcp_seg * seg, struct tcp_pcb * pcb, struct netif * netif)
{
  u16_t mss;
  u32_t * opts;
  u16_t len;
  err_t err;
  err_t iftmp.21;
  err_t D.8359;

  <bb 2> :
  if (seg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (pcb == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  if (netif == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  _1 = tcp_output_segment_busy (seg);
  if (_1 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.8359 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 25>; [INV]

  <bb 10> :
  _2 = pcb->rcv_nxt;
  _3 = seg->tcphdr;
  _4 = lwip_htonl (_2);
  _3->ackno = _4;
  _5 = pcb->rcv_ann_wnd;
  _6 = seg->tcphdr;
  _7 = lwip_htons (_5);
  _6->wnd = _7;
  _8 = pcb->rcv_nxt;
  _9 = pcb->rcv_ann_wnd;
  _10 = (long unsigned int) _9;
  _11 = _8 + _10;
  pcb->rcv_ann_right_edge = _11;
  _12 = seg->tcphdr;
  opts = _12 + 20;
  _13 = seg->flags;
  _14 = (int) _13;
  _15 = _14 & 1;
  if (_15 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _16 = &pcb->remote_ip;
  mss = tcp_eff_send_mss_netif (1460, netif, _16);
  _17 = (int) mss;
  _18 = _17 | 33816576;
  _19 = (long unsigned int) _18;
  _20 = lwip_htonl (_19);
  *opts = _20;
  opts = opts + 4;

  <bb 12> :
  _21 = pcb->rtime;
  if (_21 < 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  pcb->rtime = 0;

  <bb 14> :
  _22 = pcb->rttest;
  if (_22 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  tcp_ticks.20_23 = tcp_ticks;
  pcb->rttest = tcp_ticks.20_23;
  _24 = seg->tcphdr;
  _25 = _24->seqno;
  _26 = lwip_htonl (_25);
  pcb->rtseq = _26;

  <bb 16> :
  _27 = seg->tcphdr;
  _28 = seg->p;
  _29 = _28->payload;
  _30 = _27 - _29;
  len = (u16_t) _30;
  if (len == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _31 = lwip_stats.mib2.tcpoutsegs;
  _32 = _31 + 1;
  lwip_stats.mib2.tcpoutsegs = _32;

  <bb 18> :
  _33 = seg->p;
  _34 = _33->len;
  _35 = seg->p;
  _36 = _34 - len;
  _35->len = _36;
  _37 = seg->p;
  _38 = _37->tot_len;
  _39 = seg->p;
  _40 = _38 - len;
  _39->tot_len = _40;
  _41 = seg->p;
  _42 = seg->tcphdr;
  _41->payload = _42;
  _43 = seg->tcphdr;
  _43->chksum = 0;
  _44 = seg->tcphdr;
  _45 = _44 + 20;
  _46 = seg->flags;
  _47 = (sizetype) _46;
  _48 = _47 << 2;
  _49 = _48 & 4;
  _50 = _45 + _49;
  if (opts != _50)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 19>; [INV]

  <bb 20> :
  _51 = seg->p;
  _52 = seg->p;
  _53 = _52->tot_len;
  _54 = &pcb->local_ip;
  _55 = &pcb->remote_ip;
  _56 = seg->tcphdr;
  _57 = ip_chksum_pseudo (_51, 6, _53, _54, _55);
  _56->chksum = _57;
  _58 = lwip_stats.tcp.xmit;
  _59 = _58 + 1;
  lwip_stats.tcp.xmit = _59;
  _60 = &pcb->remote_ip;
  if (_60 != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 21> :
  _61 = pcb->remote_ip.type;
  if (_61 == 6)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _62 = seg->p;
  _63 = &pcb->local_ip.u_addr.ip6;
  _64 = &pcb->remote_ip.u_addr.ip6;
  _65 = pcb->ttl;
  _66 = pcb->tos;
  iftmp.21 = ip6_output_if (_62, _63, _64, _65, _66, 6, netif);
  goto <bb 24>; [INV]

  <bb 23> :
  _67 = seg->p;
  _68 = &pcb->local_ip.u_addr.ip4;
  _69 = &pcb->remote_ip.u_addr.ip4;
  _70 = pcb->ttl;
  _71 = pcb->tos;
  iftmp.21 = ip4_output_if (_67, _68, _69, _70, _71, 6, netif);

  <bb 24> :
  err = iftmp.21;
  D.8359 = err;

  <bb 25> :
<L26>:
  return D.8359;

}


tcp_output_segment_busy (const struct tcp_seg * seg)
{
  int D.8349;

  <bb 2> :
  if (seg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = seg->p;
  _2 = _1->ref;
  if (_2 != 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8349 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  D.8349 = 0;

  <bb 7> :
<L5>:
  return D.8349;

}


tcp_output (struct tcp_pcb * pcb)
{
  struct tcp_seg * * cur_seg;
  const struct ip_addr_t * local_ip;
  struct netif * netif;
  err_t err;
  u32_t snd_nxt;
  u32_t wnd;
  struct tcp_seg * useg;
  struct tcp_seg * seg;
  unsigned int iftmp.19;
  unsigned int iftmp.18;
  int iftmp.17;
  const struct ip_addr_t * iftmp.16;
  const struct ip_addr_t * iftmp.15;
  const struct ip_addr_t * iftmp.14;
  int iftmp.13;
  int iftmp.12;
  _Bool iftmp.11;
  _Bool iftmp.10;
  err_t D.8238;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->state;
  if (_1 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  tcp_input_pcb.9_2 = tcp_input_pcb;
  if (pcb == tcp_input_pcb.9_2)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.8238 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 106>; [INV]

  <bb 8> :
  _3 = pcb->cwnd;
  _4 = pcb->snd_wnd;
  _5 = MIN_EXPR <_3, _4>;
  wnd = (u32_t) _5;
  seg = pcb->unsent;
  if (seg == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  _6 = pcb->flags;
  _7 = (unsigned int) _6;
  _8 = _7 & 2;
  if (_8 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.8238 = tcp_send_empty_ack (pcb);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 106>; [INV]

  <bb 11> :
  // predicted unlikely by goto predictor.
  goto <bb 105>; [INV]

  <bb 12> :
  _9 = &pcb->local_ip;
  _10 = &pcb->remote_ip;
  netif = tcp_route (pcb, _9, _10);
  if (netif == 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  D.8238 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 106>; [INV]

  <bb 14> :
  _11 = &pcb->local_ip;
  if (_11 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 15> :
  _12 = &pcb->local_ip;
  if (_12 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 16> :
  _13 = pcb->local_ip.type;
  if (_13 == 6)
    goto <bb 17>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 17> :
  _14 = &pcb->local_ip.u_addr.ip6;
  if (_14 == 0B)
    goto <bb 22>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  _15 = pcb->local_ip.u_addr.ip6.addr[0];
  if (_15 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  _16 = pcb->local_ip.u_addr.ip6.addr[1];
  if (_16 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 20> :
  _17 = pcb->local_ip.u_addr.ip6.addr[2];
  if (_17 == 0)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 21> :
  _18 = pcb->local_ip.u_addr.ip6.addr[3];
  if (_18 == 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  iftmp.12 = 1;
  goto <bb 24>; [INV]

  <bb 23> :
  iftmp.12 = 0;

  <bb 24> :
  iftmp.11 = (_Bool) iftmp.12;
  goto <bb 30>; [INV]

  <bb 25> :
  _19 = &pcb->local_ip.u_addr.ip4;
  if (_19 == 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  _20 = pcb->local_ip.u_addr.ip4.addr;
  if (_20 == 0)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  iftmp.13 = 1;
  goto <bb 29>; [INV]

  <bb 28> :
  iftmp.13 = 0;

  <bb 29> :
  iftmp.11 = (_Bool) iftmp.13;

  <bb 30> :
  iftmp.10 = iftmp.11;
  goto <bb 32>; [INV]

  <bb 31> :
  iftmp.10 = 1;

  <bb 32> :
  if (iftmp.10 != 0)
    goto <bb 33>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 33> :
  _21 = &pcb->remote_ip;
  if (_21 != 0B)
    goto <bb 34>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 34> :
  _22 = pcb->remote_ip.type;
  if (_22 == 6)
    goto <bb 35>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 35> :
  if (netif != 0B)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _23 = &pcb->remote_ip.u_addr.ip6;
  iftmp.15 = ip6_select_source_address (netif, _23);
  goto <bb 38>; [INV]

  <bb 37> :
  iftmp.15 = 0B;

  <bb 38> :
  iftmp.14 = iftmp.15;
  goto <bb 43>; [INV]

  <bb 39> :
  if (netif != 0B)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  iftmp.16 = &netif->ip_addr;
  goto <bb 42>; [INV]

  <bb 41> :
  iftmp.16 = 0B;

  <bb 42> :
  iftmp.14 = iftmp.16;

  <bb 43> :
  local_ip = iftmp.14;
  if (local_ip == 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 44> :
  D.8238 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 106>; [INV]

  <bb 45> :
  _24 = local_ip->type;
  pcb->local_ip.type = _24;
  _25 = local_ip->type;
  if (_25 == 6)
    goto <bb 46>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 46> :
  _26 = local_ip->u_addr.ip6.addr[0];
  pcb->local_ip.u_addr.ip6.addr[0] = _26;
  _27 = local_ip->u_addr.ip6.addr[1];
  pcb->local_ip.u_addr.ip6.addr[1] = _27;
  _28 = local_ip->u_addr.ip6.addr[2];
  pcb->local_ip.u_addr.ip6.addr[2] = _28;
  _29 = local_ip->u_addr.ip6.addr[3];
  pcb->local_ip.u_addr.ip6.addr[3] = _29;
  _30 = local_ip->u_addr.ip6.zone;
  pcb->local_ip.u_addr.ip6.zone = _30;
  goto <bb 48>; [INV]

  <bb 47> :
  _31 = local_ip->u_addr.ip4.addr;
  pcb->local_ip.u_addr.ip4.addr = _31;
  pcb->local_ip.u_addr.ip6.addr[3] = 0;
  _32 = pcb->local_ip.u_addr.ip6.addr[3];
  pcb->local_ip.u_addr.ip6.addr[2] = _32;
  _33 = pcb->local_ip.u_addr.ip6.addr[2];
  pcb->local_ip.u_addr.ip6.addr[1] = _33;
  pcb->local_ip.u_addr.ip6.zone = 0;

  <bb 48> :
  _34 = seg->tcphdr;
  _35 = _34->seqno;
  _36 = lwip_htonl (_35);
  _37 = pcb->lastack;
  _38 = _36 - _37;
  _39 = seg->len;
  _40 = (long unsigned int) _39;
  _41 = _38 + _40;
  if (wnd < _41)
    goto <bb 49>; [INV]
  else
    goto <bb 56>; [INV]

  <bb 49> :
  _42 = pcb->snd_wnd;
  _43 = (long unsigned int) _42;
  if (wnd == _43)
    goto <bb 50>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 50> :
  _44 = pcb->unacked;
  if (_44 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 51> :
  _45 = pcb->persist_backoff;
  if (_45 == 0)
    goto <bb 52>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 52> :
  pcb->persist_cnt = 0;
  pcb->persist_backoff = 1;
  pcb->persist_probe = 0;

  <bb 53> :
  _46 = pcb->flags;
  _47 = (unsigned int) _46;
  _48 = _47 & 2;
  if (_48 != 0)
    goto <bb 54>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 54> :
  D.8238 = tcp_send_empty_ack (pcb);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 106>; [INV]

  <bb 55> :
  // predicted unlikely by goto predictor.
  goto <bb 105>; [INV]

  <bb 56> :
  pcb->persist_backoff = 0;
  useg = pcb->unacked;
  if (useg != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 57> :
  goto <bb 59>; [INV]

  <bb 58> :
  useg = useg->next;

  <bb 59> :
  _49 = useg->next;
  if (_49 != 0B)
    goto <bb 58>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 60> :
  goto <bb 101>; [INV]

  <bb 61> :
  _50 = seg->tcphdr;
  _51 = _50->_hdrlen_rsvd_flags;
  _52 = lwip_htons (_51);
  _53 = (unsigned char) _52;
  _54 = (unsigned int) _53;
  _55 = _54 & 4;
  if (_55 != 0)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 62>; [INV]

  <bb 63> :
  _56 = pcb->unacked;
  if (_56 == 0B)
    goto <bb 70>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 64> :
  _57 = pcb->flags;
  _58 = (unsigned int) _57;
  _59 = _58 & 68;
  if (_59 != 0)
    goto <bb 70>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 65> :
  _60 = pcb->unsent;
  if (_60 != 0B)
    goto <bb 66>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 66> :
  _61 = pcb->unsent;
  _62 = _61->next;
  if (_62 != 0B)
    goto <bb 70>; [INV]
  else
    goto <bb 67>; [INV]

  <bb 67> :
  _63 = pcb->unsent;
  _64 = _63->len;
  _65 = pcb->mss;
  if (_64 >= _65)
    goto <bb 70>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 68> :
  _66 = pcb->snd_buf;
  if (_66 == 0)
    goto <bb 70>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 69> :
  _67 = pcb->snd_queuelen;
  if (_67 > 19)
    goto <bb 70>; [INV]
  else
    goto <bb 71>; [INV]

  <bb 70> :
  iftmp.17 = 1;
  goto <bb 72>; [INV]

  <bb 71> :
  iftmp.17 = 0;

  <bb 72> :
  if (iftmp.17 == 0)
    goto <bb 73>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 73> :
  _68 = pcb->flags;
  _69 = (unsigned int) _68;
  _70 = _69 & 160;
  if (_70 == 0)
    goto <bb 74>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 74> :
  goto <bb 103>; [INV]

  <bb 75> :
  _71 = pcb->state;
  if (_71 != 2)
    goto <bb 76>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 76> :
  _72 = seg->tcphdr;
  _73 = _72->_hdrlen_rsvd_flags;
  _74 = lwip_htons (16);
  _75 = seg->tcphdr;
  _76 = _73 | _74;
  _75->_hdrlen_rsvd_flags = _76;

  <bb 77> :
  err = tcp_output_segment (seg, pcb, netif);
  if (err != 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _77 = pcb->flags;
  _78 = _77 | 128;
  pcb->flags = _78;
  D.8238 = err;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 106>; [INV]

  <bb 79> :
  _79 = seg->next;
  pcb->unsent = _79;
  _80 = pcb->state;
  if (_80 != 2)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  _81 = pcb->flags;
  _82 = _81 & 65532;
  pcb->flags = _82;

  <bb 81> :
  _83 = seg->tcphdr;
  _84 = _83->seqno;
  _85 = lwip_htonl (_84);
  _86 = seg->len;
  _87 = (unsigned int) _86;
  _88 = seg->tcphdr;
  _89 = _88->_hdrlen_rsvd_flags;
  _90 = lwip_htons (_89);
  _91 = (unsigned char) _90;
  _92 = (unsigned int) _91;
  _93 = _92 & 3;
  if (_93 != 0)
    goto <bb 82>; [INV]
  else
    goto <bb 83>; [INV]

  <bb 82> :
  iftmp.18 = 1;
  goto <bb 84>; [INV]

  <bb 83> :
  iftmp.18 = 0;

  <bb 84> :
  _94 = iftmp.18 + _87;
  snd_nxt = _85 + _94;
  _95 = pcb->snd_nxt;
  _96 = _95 - snd_nxt;
  _97 = (long int) _96;
  if (_97 < 0)
    goto <bb 85>; [INV]
  else
    goto <bb 86>; [INV]

  <bb 85> :
  pcb->snd_nxt = snd_nxt;

  <bb 86> :
  _98 = seg->len;
  _99 = (unsigned int) _98;
  _100 = seg->tcphdr;
  _101 = _100->_hdrlen_rsvd_flags;
  _102 = lwip_htons (_101);
  _103 = (unsigned char) _102;
  _104 = (unsigned int) _103;
  _105 = _104 & 3;
  if (_105 != 0)
    goto <bb 87>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 87> :
  iftmp.19 = 1;
  goto <bb 89>; [INV]

  <bb 88> :
  iftmp.19 = 0;

  <bb 89> :
  _106 = iftmp.19 + _99;
  if (_106 != 0)
    goto <bb 90>; [INV]
  else
    goto <bb 99>; [INV]

  <bb 90> :
  seg->next = 0B;
  _107 = pcb->unacked;
  if (_107 == 0B)
    goto <bb 91>; [INV]
  else
    goto <bb 92>; [INV]

  <bb 91> :
  pcb->unacked = seg;
  useg = seg;
  goto <bb 100>; [INV]

  <bb 92> :
  _108 = seg->tcphdr;
  _109 = _108->seqno;
  _110 = lwip_htonl (_109);
  _111 = useg->tcphdr;
  _112 = _111->seqno;
  _113 = lwip_htonl (_112);
  _114 = _110 - _113;
  _115 = (long int) _114;
  if (_115 < 0)
    goto <bb 93>; [INV]
  else
    goto <bb 98>; [INV]

  <bb 93> :
  cur_seg = &pcb->unacked;
  goto <bb 95>; [INV]

  <bb 94> :
  _116 = *cur_seg;
  cur_seg = &_116->next;

  <bb 95> :
  _117 = *cur_seg;
  if (_117 != 0B)
    goto <bb 96>; [INV]
  else
    goto <bb 97>; [INV]

  <bb 96> :
  _118 = *cur_seg;
  _119 = _118->tcphdr;
  _120 = _119->seqno;
  _121 = lwip_htonl (_120);
  _122 = seg->tcphdr;
  _123 = _122->seqno;
  _124 = lwip_htonl (_123);
  _125 = _121 - _124;
  _126 = (long int) _125;
  if (_126 < 0)
    goto <bb 94>; [INV]
  else
    goto <bb 97>; [INV]

  <bb 97> :
  _127 = *cur_seg;
  seg->next = _127;
  *cur_seg = seg;
  goto <bb 100>; [INV]

  <bb 98> :
  useg->next = seg;
  useg = useg->next;
  goto <bb 100>; [INV]

  <bb 99> :
  tcp_seg_free (seg);

  <bb 100> :
  seg = pcb->unsent;

  <bb 101> :
  if (seg != 0B)
    goto <bb 102>; [INV]
  else
    goto <bb 103>; [INV]

  <bb 102> :
  _128 = seg->tcphdr;
  _129 = _128->seqno;
  _130 = lwip_htonl (_129);
  _131 = pcb->lastack;
  _132 = _130 - _131;
  _133 = seg->len;
  _134 = (long unsigned int) _133;
  _135 = _132 + _134;
  if (wnd >= _135)
    goto <bb 61>; [INV]
  else
    goto <bb 103>; [INV]

  <bb 103> :
  _136 = pcb->unsent;
  if (_136 == 0B)
    goto <bb 104>; [INV]
  else
    goto <bb 105>; [INV]

  <bb 104> :
  pcb->unsent_oversize = 0;

  <bb 105> :
output_done:
  _137 = pcb->flags;
  _138 = _137 & 65407;
  pcb->flags = _138;
  D.8238 = 0;

  <bb 106> :
<L114>:
  return D.8238;

}


tcp_enqueue_flags (struct tcp_pcb * pcb, u8_t flags)
{
  struct tcp_seg * useg;
  u8_t optlen;
  u8_t optflags;
  struct tcp_seg * seg;
  struct pbuf * p;
  short unsigned int D.8224;
  err_t D.8207;

  <bb 2> :
  optflags = 0;
  optlen = 0;
  _1 = (unsigned int) flags;
  _2 = _1 & 3;
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (pcb == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _3 = (unsigned int) flags;
  _4 = _3 & 2;
  if (_4 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  optflags = 1;

  <bb 8> :
  _5 = (int) optflags;
  _6 = _5 << 2;
  _7 = (unsigned char) _6;
  optlen = _7 & 4;
  _8 = (short unsigned int) optlen;
  p = pbuf_alloc (74, _8, 640);
  if (p == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _9 = pcb->flags;
  _10 = _9 | 128;
  pcb->flags = _10;
  _11 = lwip_stats.tcp.memerr;
  _12 = _11 + 1;
  lwip_stats.tcp.memerr = _12;
  D.8207 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 34>; [INV]

  <bb 10> :
  _13 = p->len;
  _14 = (short unsigned int) optlen;
  if (_13 < _14)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 11>; [INV]

  <bb 12> :
  _15 = pcb->snd_lbb;
  seg = tcp_create_segment (pcb, p, flags, _15, optflags);
  if (seg == 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _16 = pcb->flags;
  _17 = _16 | 128;
  pcb->flags = _17;
  _18 = lwip_stats.tcp.memerr;
  _19 = _18 + 1;
  lwip_stats.tcp.memerr = _19;
  D.8207 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 34>; [INV]

  <bb 14> :
  _20 = seg->tcphdr;
  _21 = (unsigned int) _20;
  _22 = _21 & 3;
  if (_22 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 15>; [INV]

  <bb 16> :
  _23 = seg->len;
  if (_23 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 17>; [INV]

  <bb 18> :
  _24 = pcb->unsent;
  if (_24 == 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  pcb->unsent = seg;
  goto <bb 24>; [INV]

  <bb 20> :
  useg = pcb->unsent;
  goto <bb 22>; [INV]

  <bb 21> :
  useg = useg->next;

  <bb 22> :
  _25 = useg->next;
  if (_25 != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  useg->next = seg;

  <bb 24> :
  pcb->unsent_oversize = 0;
  _26 = (unsigned int) flags;
  _27 = _26 & 2;
  if (_27 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  _28 = (unsigned int) flags;
  _29 = _28 & 1;
  if (_29 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _30 = pcb->snd_lbb;
  _31 = _30 + 1;
  pcb->snd_lbb = _31;

  <bb 27> :
  _32 = (unsigned int) flags;
  _33 = _32 & 1;
  if (_33 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  _34 = pcb->flags;
  _35 = _34 | 32;
  pcb->flags = _35;

  <bb 29> :
  _36 = seg->p;
  D.8224 = pbuf_clen (_36);
  _37 = pcb->snd_queuelen;
  _38 = D.8224 + _37;
  pcb->snd_queuelen = _38;
  _39 = pcb->snd_queuelen;
  if (_39 != 0)
    goto <bb 30>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 30> :
  _40 = pcb->unacked;
  if (_40 == 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 31> :
  _41 = pcb->unsent;
  if (_41 == 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 32>; [INV]

  <bb 33> :
  D.8207 = 0;

  <bb 34> :
<L39>:
  return D.8207;

}


tcp_send_fin (struct tcp_pcb * pcb)
{
  struct tcp_seg * last_unsent;
  err_t D.8197;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->unsent;
  if (_1 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  last_unsent = pcb->unsent;
  goto <bb 7>; [INV]

  <bb 6> :
  last_unsent = last_unsent->next;

  <bb 7> :
  _2 = last_unsent->next;
  if (_2 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _3 = last_unsent->tcphdr;
  _4 = _3->_hdrlen_rsvd_flags;
  _5 = lwip_htons (_4);
  _6 = (unsigned char) _5;
  _7 = (unsigned int) _6;
  _8 = _7 & 7;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _9 = last_unsent->tcphdr;
  _10 = _9->_hdrlen_rsvd_flags;
  _11 = lwip_htons (1);
  _12 = last_unsent->tcphdr;
  _13 = _10 | _11;
  _12->_hdrlen_rsvd_flags = _13;
  _14 = pcb->flags;
  _15 = _14 | 32;
  pcb->flags = _15;
  D.8197 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 10> :
  D.8197 = tcp_enqueue_flags (pcb, 1);

  <bb 11> :
<L10>:
  return D.8197;

}


tcp_split_unsent_seg (struct tcp_pcb * pcb, u16_t split)
{
  u16_t offset;
  u16_t remainder;
  u8_t remainder_flags;
  u8_t split_flags;
  u8_t optflags;
  u8_t optlen;
  struct pbuf * p;
  struct tcp_seg * useg;
  struct tcp_seg * seg;
  short unsigned int D.8183;
  short unsigned int D.8182;
  short unsigned int D.8181;
  err_t D.8160;

  <bb 2> :
  seg = 0B;
  useg = 0B;
  p = 0B;
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  useg = pcb->unsent;
  if (useg == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.8160 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 32>; [INV]

  <bb 6> :
  if (split == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 7>; [INV]

  <bb 8> :
  _1 = useg->len;
  if (split >= _1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.8160 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 32>; [INV]

  <bb 10> :
  _2 = pcb->mss;
  if (split > _2)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 11>; [INV]

  <bb 12> :
  _3 = useg->len;
  if (_3 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 13>; [INV]

  <bb 14> :
  optflags = useg->flags;
  _4 = (int) optflags;
  _5 = _4 << 2;
  _6 = (unsigned char) _5;
  optlen = _6 & 4;
  _7 = useg->len;
  remainder = _7 - split;
  _8 = (short unsigned int) optlen;
  _9 = remainder + _8;
  p = pbuf_alloc (74, _9, 640);
  if (p == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  // predicted unlikely by goto predictor.
  goto <bb 27>; [INV]

  <bb 16> :
  _10 = useg->p;
  _11 = _10->tot_len;
  _12 = useg->len;
  _13 = _11 - _12;
  offset = split + _13;
  _14 = useg->p;
  _15 = p->payload;
  _16 = (sizetype) optlen;
  _17 = _15 + _16;
  _18 = pbuf_copy_partial (_14, _17, remainder, offset);
  if (remainder != _18)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  // predicted unlikely by goto predictor.
  goto <bb 27>; [INV]

  <bb 18> :
  _19 = useg->tcphdr;
  _20 = _19->_hdrlen_rsvd_flags;
  _21 = lwip_htons (_20);
  _22 = (unsigned char) _21;
  split_flags = _22 & 63;
  remainder_flags = 0;
  _23 = (unsigned int) split_flags;
  _24 = _23 & 8;
  if (_24 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  split_flags = split_flags & 247;
  remainder_flags = remainder_flags | 8;

  <bb 20> :
  _25 = (unsigned int) split_flags;
  _26 = _25 & 1;
  if (_26 != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  split_flags = split_flags & 254;
  remainder_flags = remainder_flags | 1;

  <bb 22> :
  _27 = useg->tcphdr;
  _28 = _27->seqno;
  _29 = lwip_htonl (_28);
  _30 = (long unsigned int) split;
  _31 = _29 + _30;
  seg = tcp_create_segment (pcb, p, remainder_flags, _31, optflags);
  if (seg == 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  p = 0B;
  // predicted unlikely by goto predictor.
  goto <bb 27>; [INV]

  <bb 24> :
  _32 = useg->p;
  D.8181 = pbuf_clen (_32);
  _33 = pcb->snd_queuelen;
  _34 = _33 - D.8181;
  pcb->snd_queuelen = _34;
  _35 = useg->p;
  _36 = useg->p;
  _37 = _36->tot_len;
  _38 = _37 - remainder;
  pbuf_realloc (_35, _38);
  _39 = useg->len;
  _40 = _39 - remainder;
  useg->len = _40;
  _41 = useg->tcphdr;
  _42 = _41->_hdrlen_rsvd_flags;
  _43 = (short unsigned int) split_flags;
  _44 = lwip_htons (_43);
  _45 = useg->tcphdr;
  _46 = _42 | _44;
  _45->_hdrlen_rsvd_flags = _46;
  _47 = useg->p;
  D.8182 = pbuf_clen (_47);
  _48 = pcb->snd_queuelen;
  _49 = D.8182 + _48;
  pcb->snd_queuelen = _49;
  _50 = seg->p;
  D.8183 = pbuf_clen (_50);
  _51 = pcb->snd_queuelen;
  _52 = D.8183 + _51;
  pcb->snd_queuelen = _52;
  _53 = useg->next;
  seg->next = _53;
  useg->next = seg;
  _54 = seg->next;
  if (_54 == 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  pcb->unsent_oversize = 0;

  <bb 26> :
  D.8160 = 0;
  goto <bb 32>; [INV]

  <bb 27> :
memerr:
  _55 = lwip_stats.tcp.memerr;
  _56 = _55 + 1;
  lwip_stats.tcp.memerr = _56;
  if (seg != 0B)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 28>; [INV]

  <bb 29> :
  if (p != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  pbuf_free (p);

  <bb 31> :
  D.8160 = -1;

  <bb 32> :
<L36>:
  return D.8160;

}


tcp_write (struct tcp_pcb * pcb, const void * arg, u16_t len, u8_t apiflags)
{
  struct pbuf * p;
  struct pbuf * p;
  struct pbuf * p2;
  u16_t seglen;
  u16_t max_len;
  u16_t left;
  struct pbuf * p;
  struct pbuf * p;
  u16_t seglen;
  u16_t unsent_optlen;
  u16_t space;
  u16_t mss_local;
  err_t err;
  u16_t extendlen;
  u16_t oversize_used;
  u16_t oversize;
  u8_t optflags;
  u8_t optlen;
  u16_t queuelen;
  u16_t pos;
  struct tcp_seg * queue;
  struct tcp_seg * prev_seg;
  struct tcp_seg * seg;
  struct tcp_seg * last_unsent;
  struct pbuf * concat_p;
  short unsigned int D.8105;
  short unsigned int D.8088;
  short unsigned int D.8078;
  u16_t iftmp.1;
  err_t D.8047;

  <bb 2> :
  concat_p = 0B;
  last_unsent = 0B;
  seg = 0B;
  prev_seg = 0B;
  queue = 0B;
  pos = 0;
  optflags = 0;
  oversize = 0;
  oversize_used = 0;
  extendlen = 0;
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.8047 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 110>; [INV]

  <bb 4> :
  _1 = pcb->snd_wnd_max;
  _2 = _1 / 2;
  _3 = pcb->mss;
  mss_local = MIN_EXPR <_2, _3>;
  if (mss_local == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  iftmp.1 = pcb->mss;
  goto <bb 7>; [INV]

  <bb 6> :
  iftmp.1 = mss_local;

  <bb 7> :
  mss_local = iftmp.1;
  if (arg == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.8047 = -16;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 110>; [INV]

  <bb 9> :
  err = tcp_write_checks (pcb, len);
  if (err != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.8047 = err;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 110>; [INV]

  <bb 11> :
  queuelen = pcb->snd_queuelen;
  optlen = 0;
  _4 = pcb->unsent;
  if (_4 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 12> :
  last_unsent = pcb->unsent;
  goto <bb 14>; [INV]

  <bb 13> :
  last_unsent = last_unsent->next;

  <bb 14> :
  _5 = last_unsent->next;
  if (_5 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  _6 = last_unsent->flags;
  _7 = (int) _6;
  _8 = _7 << 2;
  _9 = (short unsigned int) _8;
  unsent_optlen = _9 & 4;
  _10 = (int) mss_local;
  _11 = last_unsent->len;
  _12 = (int) _11;
  _13 = (int) unsent_optlen;
  _14 = _12 + _13;
  if (_10 < _14)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 16>; [INV]

  <bb 17> :
  _15 = last_unsent->len;
  _16 = unsent_optlen + _15;
  space = mss_local - _16;
  _17 = pcb->unsent_oversize;
  oversize = _17;
  oversize.2_18 = oversize;
  if (oversize.2_18 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  oversize.3_19 = oversize;
  if (space < oversize.3_19)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 19>; [INV]

  <bb 20> :
  seg = last_unsent;
  oversize.4_20 = oversize;
  _21 = MIN_EXPR <len, oversize.4_20>;
  oversize_used = MIN_EXPR <space, _21>;
  pos = pos + oversize_used;
  oversize.5_22 = oversize;
  _23 = oversize.5_22 - oversize_used;
  oversize = _23;
  space = space - oversize_used;

  <bb 21> :
  oversize.6_24 = oversize;
  if (oversize.6_24 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 22> :
  if (pos != len)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 23>; [INV]

  <bb 24> :
  if (pos < len)
    goto <bb 25>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 25> :
  if (space != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 26> :
  _25 = last_unsent->len;
  if (_25 != 0)
    goto <bb 27>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 27> :
  _26 = (int) len;
  _27 = (int) pos;
  _28 = _26 - _27;
  _29 = (int) space;
  _30 = MIN_EXPR <_28, _29>;
  seglen = (u16_t) _30;
  seg = last_unsent;
  _31 = (int) apiflags;
  _32 = _31 & 1;
  if (_32 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 28> :
  concat_p = tcp_pbuf_prealloc (0, seglen, space, &oversize, pcb, apiflags, 1);
  if (concat_p == 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 30> :
  _33 = concat_p->payload;
  _34 = (sizetype) pos;
  _35 = arg + _34;
  _36 = (unsigned int) seglen;
  memcpy (_33, _35, _36);
  D.8078 = pbuf_clen (concat_p);
  queuelen = D.8078 + queuelen;
  goto <bb 42>; [INV]

  <bb 31> :
  p = last_unsent->p;
  goto <bb 33>; [INV]

  <bb 32> :
  p = p->next;

  <bb 33> :
  _37 = p->next;
  if (_37 != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 34> :
  _38 = p->type_internal;
  _39 = (int) _38;
  _40 = _39 & 192;
  if (_40 == 0)
    goto <bb 35>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 35> :
  _41 = p->payload;
  _42 = p->len;
  _43 = (sizetype) _42;
  _44 = _41 + _43;
  if (arg == _44)
    goto <bb 36>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 36> :
  if (pos != 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 37>; [INV]

  <bb 38> :
  extendlen = seglen;
  goto <bb 42>; [INV]

  <bb 39> :
  concat_p = pbuf_alloc (0, seglen, 1);
  if (concat_p == 0B)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 41> :
  _45 = (sizetype) pos;
  _46 = arg + _45;
  MEM[(struct pbuf_rom *)concat_p].payload = _46;
  D.8088 = pbuf_clen (concat_p);
  queuelen = D.8088 + queuelen;

  <bb 42> :
  pos = pos + seglen;
  goto <bb 45>; [INV]

  <bb 43> :
  _47 = pcb->unsent_oversize;
  if (_47 != 0)
    goto <bb 44>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 44> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 44>; [INV]

  <bb 45> :
  goto <bb 69>; [INV]

  <bb 46> :
  left = len - pos;
  _48 = (short unsigned int) optlen;
  max_len = mss_local - _48;
  seglen = MIN_EXPR <max_len, left>;
  _49 = (int) apiflags;
  _50 = _49 & 1;
  if (_50 != 0)
    goto <bb 47>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 47> :
  _51 = (short unsigned int) optlen;
  _52 = seglen + _51;
  _53 = queue == 0B;
  _54 = (unsigned char) _53;
  p = tcp_pbuf_prealloc (74, _52, mss_local, &oversize, pcb, apiflags, _54);
  if (p == 0B)
    goto <bb 48>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 48> :
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 49> :
  _55 = p->len;
  if (seglen > _55)
    goto <bb 50>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 50> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 50>; [INV]

  <bb 51> :
  _56 = p->payload;
  _57 = (sizetype) optlen;
  _58 = _56 + _57;
  _59 = (sizetype) pos;
  _60 = arg + _59;
  _61 = (unsigned int) seglen;
  memcpy (_58, _60, _61);
  goto <bb 59>; [INV]

  <bb 52> :
  oversize.7_62 = oversize;
  if (oversize.7_62 != 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 53>; [INV]

  <bb 54> :
  p2 = pbuf_alloc (74, seglen, 1);
  if (p2 == 0B)
    goto <bb 55>; [INV]
  else
    goto <bb 56>; [INV]

  <bb 55> :
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 56> :
  _63 = (sizetype) pos;
  _64 = arg + _63;
  MEM[(struct pbuf_rom *)p2].payload = _64;
  _65 = (short unsigned int) optlen;
  p = pbuf_alloc (74, _65, 640);
  if (p == 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  pbuf_free (p2);
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 58> :
  pbuf_cat (p, p2);

  <bb 59> :
  D.8105 = pbuf_clen (p);
  queuelen = D.8105 + queuelen;
  if (queuelen > 20)
    goto <bb 60>; [INV]
  else
    goto <bb 61>; [INV]

  <bb 60> :
  pbuf_free (p);
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 61> :
  _66 = pcb->snd_lbb;
  _67 = (long unsigned int) pos;
  _68 = _66 + _67;
  seg = tcp_create_segment (pcb, p, 0, _68, optflags);
  if (seg == 0B)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  // predicted unlikely by goto predictor.
  goto <bb 101>; [INV]

  <bb 63> :
  if (queue == 0B)
    goto <bb 64>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 64> :
  queue = seg;
  goto <bb 68>; [INV]

  <bb 65> :
  if (prev_seg == 0B)
    goto <bb 66>; [INV]
  else
    goto <bb 67>; [INV]

  <bb 66> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 66>; [INV]

  <bb 67> :
  prev_seg->next = seg;

  <bb 68> :
  prev_seg = seg;
  pos = pos + seglen;

  <bb 69> :
  if (pos < len)
    goto <bb 46>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 70> :
  if (oversize_used != 0)
    goto <bb 71>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 71> :
  p = last_unsent->p;
  goto <bb 75>; [INV]

  <bb 72> :
  _69 = p->tot_len;
  _70 = oversize_used + _69;
  p->tot_len = _70;
  _71 = p->next;
  if (_71 == 0B)
    goto <bb 73>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 73> :
  _72 = p->payload;
  _73 = p->len;
  _74 = (sizetype) _73;
  _75 = _72 + _74;
  _76 = (unsigned int) oversize_used;
  memcpy (_75, arg, _76);
  _77 = p->len;
  _78 = oversize_used + _77;
  p->len = _78;

  <bb 74> :
  p = p->next;

  <bb 75> :
  if (p != 0B)
    goto <bb 72>; [INV]
  else
    goto <bb 76>; [INV]

  <bb 76> :
  _79 = last_unsent->len;
  _80 = oversize_used + _79;
  last_unsent->len = _80;

  <bb 77> :
  oversize.8_81 = oversize;
  pcb->unsent_oversize = oversize.8_81;
  if (concat_p != 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 78> :
  if (last_unsent == 0B)
    goto <bb 79>; [INV]
  else
    goto <bb 80>; [INV]

  <bb 79> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 79>; [INV]

  <bb 80> :
  _82 = last_unsent->p;
  pbuf_cat (_82, concat_p);
  _83 = last_unsent->len;
  _84 = concat_p->tot_len;
  _85 = _83 + _84;
  last_unsent->len = _85;
  goto <bb 89>; [INV]

  <bb 81> :
  if (extendlen != 0)
    goto <bb 82>; [INV]
  else
    goto <bb 89>; [INV]

  <bb 82> :
  if (last_unsent == 0B)
    goto <bb 84>; [INV]
  else
    goto <bb 83>; [INV]

  <bb 83> :
  _86 = last_unsent->p;
  if (_86 == 0B)
    goto <bb 84>; [INV]
  else
    goto <bb 85>; [INV]

  <bb 84> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 84>; [INV]

  <bb 85> :
  p = last_unsent->p;
  goto <bb 87>; [INV]

  <bb 86> :
  _87 = p->tot_len;
  _88 = extendlen + _87;
  p->tot_len = _88;
  p = p->next;

  <bb 87> :
  _89 = p->next;
  if (_89 != 0B)
    goto <bb 86>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 88> :
  _90 = p->tot_len;
  _91 = extendlen + _90;
  p->tot_len = _91;
  _92 = p->len;
  _93 = extendlen + _92;
  p->len = _93;
  _94 = last_unsent->len;
  _95 = extendlen + _94;
  last_unsent->len = _95;

  <bb 89> :
  if (last_unsent == 0B)
    goto <bb 90>; [INV]
  else
    goto <bb 91>; [INV]

  <bb 90> :
  pcb->unsent = queue;
  goto <bb 92>; [INV]

  <bb 91> :
  last_unsent->next = queue;

  <bb 92> :
  _96 = pcb->snd_lbb;
  _97 = (long unsigned int) len;
  _98 = _96 + _97;
  pcb->snd_lbb = _98;
  _99 = pcb->snd_buf;
  _100 = _99 - len;
  pcb->snd_buf = _100;
  pcb->snd_queuelen = queuelen;
  _101 = pcb->snd_queuelen;
  if (_101 != 0)
    goto <bb 93>; [INV]
  else
    goto <bb 96>; [INV]

  <bb 93> :
  _102 = pcb->unacked;
  if (_102 == 0B)
    goto <bb 94>; [INV]
  else
    goto <bb 96>; [INV]

  <bb 94> :
  _103 = pcb->unsent;
  if (_103 == 0B)
    goto <bb 95>; [INV]
  else
    goto <bb 96>; [INV]

  <bb 95> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 95>; [INV]

  <bb 96> :
  if (seg != 0B)
    goto <bb 97>; [INV]
  else
    goto <bb 100>; [INV]

  <bb 97> :
  _104 = seg->tcphdr;
  if (_104 != 0B)
    goto <bb 98>; [INV]
  else
    goto <bb 100>; [INV]

  <bb 98> :
  _105 = (int) apiflags;
  _106 = _105 & 2;
  if (_106 == 0)
    goto <bb 99>; [INV]
  else
    goto <bb 100>; [INV]

  <bb 99> :
  _107 = seg->tcphdr;
  _108 = _107->_hdrlen_rsvd_flags;
  _109 = lwip_htons (8);
  _110 = seg->tcphdr;
  _111 = _108 | _109;
  _110->_hdrlen_rsvd_flags = _111;

  <bb 100> :
  D.8047 = 0;
  goto <bb 110>; [INV]

  <bb 101> :
memerr:
  _112 = pcb->flags;
  _113 = _112 | 128;
  pcb->flags = _113;
  _114 = lwip_stats.tcp.memerr;
  _115 = _114 + 1;
  lwip_stats.tcp.memerr = _115;
  if (concat_p != 0B)
    goto <bb 102>; [INV]
  else
    goto <bb 103>; [INV]

  <bb 102> :
  pbuf_free (concat_p);

  <bb 103> :
  if (queue != 0B)
    goto <bb 104>; [INV]
  else
    goto <bb 105>; [INV]

  <bb 104> :
  tcp_segs_free (queue);

  <bb 105> :
  _116 = pcb->snd_queuelen;
  if (_116 != 0)
    goto <bb 106>; [INV]
  else
    goto <bb 109>; [INV]

  <bb 106> :
  _117 = pcb->unacked;
  if (_117 == 0B)
    goto <bb 107>; [INV]
  else
    goto <bb 109>; [INV]

  <bb 107> :
  _118 = pcb->unsent;
  if (_118 == 0B)
    goto <bb 108>; [INV]
  else
    goto <bb 109>; [INV]

  <bb 108> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 108>; [INV]

  <bb 109> :
  D.8047 = -1;

  <bb 110> :
  oversize = {CLOBBER};

  <bb 111> :
<L133>:
  return D.8047;

}


tcp_write_checks (struct tcp_pcb * pcb, u16_t len)
{
  err_t D.8027;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  _1 = pcb->state;
  if (_1 != 4)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _2 = pcb->state;
  if (_2 != 7)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _3 = pcb->state;
  if (_3 != 2)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _4 = pcb->state;
  if (_4 != 3)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.8027 = -11;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 9> :
  if (len == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.8027 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 11> :
  _5 = pcb->snd_buf;
  if (len > _5)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _6 = pcb->flags;
  _7 = _6 | 128;
  pcb->flags = _7;
  D.8027 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 13> :
  _8 = pcb->snd_queuelen;
  if (_8 > 19)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _9 = lwip_stats.tcp.memerr;
  _10 = _9 + 1;
  lwip_stats.tcp.memerr = _10;
  _11 = pcb->flags;
  _12 = _11 | 128;
  pcb->flags = _12;
  D.8027 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 15> :
  _13 = pcb->snd_queuelen;
  if (_13 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 16> :
  _14 = pcb->unacked;
  if (_14 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 17> :
  _15 = pcb->unsent;
  if (_15 == 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 18> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 18>; [INV]

  <bb 19> :
  _16 = pcb->unacked;
  if (_16 != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  _17 = pcb->unsent;
  if (_17 != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 21>; [INV]

  <bb 22> :
  D.8027 = 0;

  <bb 23> :
<L26>:
  return D.8027;

}


tcp_pbuf_prealloc (pbuf_layer layer, u16_t length, u16_t max_length, u16_t * oversize, const struct tcp_pcb * pcb, u8_t apiflags, u8_t first_seg)
{
  u16_t alloc;
  struct pbuf * p;
  struct pbuf * D.8016;

  <bb 2> :
  alloc = length;
  if (oversize == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (pcb == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  if (length < max_length)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 7> :
  _1 = (int) apiflags;
  _2 = _1 & 2;
  if (_2 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _3 = pcb->flags;
  _4 = (unsigned int) _3;
  _5 = _4 & 64;
  if (_5 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  if (first_seg == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _6 = pcb->unsent;
  if (_6 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _7 = pcb->unacked;
  if (_7 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _8 = (unsigned int) length;
  _9 = _8 + 1467;
  _10 = _9 & 4294967288;
  _11 = (unsigned int) max_length;
  _12 = MIN_EXPR <_10, _11>;
  alloc = (u16_t) _12;

  <bb 13> :
  p = pbuf_alloc (layer, alloc, 640);
  if (p == 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  D.8016 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 15> :
  _13 = p->next;
  if (_13 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 16>; [INV]

  <bb 17> :
  _14 = p->len;
  _15 = _14 - length;
  *oversize = _15;
  p->tot_len = length;
  _16 = p->tot_len;
  p->len = _16;
  D.8016 = p;

  <bb 18> :
<L19>:
  return D.8016;

}


tcp_create_segment (const struct tcp_pcb * pcb, struct pbuf * p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
  u8_t optlen;
  struct tcp_seg * seg;
  struct tcp_seg * D.7996;

  <bb 2> :
  if (pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (p == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = (int) optflags;
  _2 = _1 << 2;
  _3 = (unsigned char) _2;
  optlen = _3 & 4;
  seg = memp_malloc (4);
  if (seg == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  pbuf_free (p);
  D.7996 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 8> :
  seg->flags = optflags;
  seg->next = 0B;
  seg->p = p;
  _4 = p->tot_len;
  _5 = (short unsigned int) optlen;
  if (_4 < _5)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  _6 = p->tot_len;
  _7 = (short unsigned int) optlen;
  _8 = _6 - _7;
  seg->len = _8;
  _9 = pbuf_add_header (p, 20);
  if (_9 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _10 = lwip_stats.tcp.err;
  _11 = _10 + 1;
  lwip_stats.tcp.err = _11;
  tcp_seg_free (seg);
  D.7996 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 12> :
  _12 = seg->p;
  _13 = _12->payload;
  seg->tcphdr = _13;
  _14 = pcb->local_port;
  _15 = seg->tcphdr;
  _16 = lwip_htons (_14);
  _15->src = _16;
  _17 = pcb->remote_port;
  _18 = seg->tcphdr;
  _19 = lwip_htons (_17);
  _18->dest = _19;
  _20 = seg->tcphdr;
  _21 = lwip_htonl (seqno);
  _20->seqno = _21;
  _22 = optlen / 4;
  _23 = (short unsigned int) _22;
  _24 = _23 + 5;
  _25 = _24 << 12;
  _26 = (short unsigned int) hdrflags;
  _27 = _25 | _26;
  _28 = seg->tcphdr;
  _29 = lwip_htons (_27);
  _28->_hdrlen_rsvd_flags = _29;
  _30 = seg->tcphdr;
  _30->urgp = 0;
  D.7996 = seg;

  <bb 13> :
<L13>:
  return D.7996;

}


tcp_route (const struct tcp_pcb * pcb, const struct ip_addr_t * src, const struct ip_addr_t * dst)
{
  struct netif * iftmp.0;
  struct netif * D.7983;

  <bb 2> :
  if (pcb != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _1 = pcb->netif_idx;
  if (_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _2 = pcb->netif_idx;
  D.7983 = netif_get_by_index (_2);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 5> :
  if (dst != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _3 = dst->type;
  if (_3 == 6)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _4 = &src->u_addr.ip6;
  _5 = &dst->u_addr.ip6;
  iftmp.0 = ip6_route (_4, _5);
  goto <bb 9>; [INV]

  <bb 8> :
  _6 = &dst->u_addr.ip4;
  iftmp.0 = ip4_route (_6);

  <bb 9> :
  D.7983 = iftmp.0;
  // predicted unlikely by early return (on trees) predictor.

  <bb 10> :
<L7>:
  return D.7983;

}


