snmp_init ()
{
  struct udp_pcb * snmp_pcb;
  err_t err;

  <bb 2> :
  snmp_pcb = udp_new_ip_type (46);
  if (snmp_pcb == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  snmp_traps_handle = snmp_pcb;
  udp_recv (snmp_pcb, snmp_recv, 0B);
  err = udp_bind (snmp_pcb, &ip_addr_any_type, 161);
  if (err != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by early return (on trees) predictor.

  <bb 6> :
<L4>:
  return;

}


snmp_get_local_ip_for_dst (void * handle, const struct ip_addr_t * dst, struct ip_addr_t * result)
{
  const struct ip_addr_t * dst_ip;
  struct netif * dst_if;
  struct udp_pcb * udp_pcb;
  u8_t D.7688;
  const struct ip_addr_t * iftmp.3;
  const struct ip_addr_t * iftmp.2;
  const struct ip_addr_t * iftmp.1;
  struct netif * iftmp.0;

  <bb 2> :
  udp_pcb = handle;
  if (dst != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _1 = dst->type;
  if (_1 == 6)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _2 = &udp_pcb->local_ip.u_addr.ip6;
  _3 = &dst->u_addr.ip6;
  iftmp.0 = ip6_route (_2, _3);
  goto <bb 6>; [INV]

  <bb 5> :
  _4 = &dst->u_addr.ip4;
  iftmp.0 = ip4_route (_4);

  <bb 6> :
  dst_if = iftmp.0;
  if (dst != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 7> :
  _5 = dst->type;
  if (_5 == 6)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  if (dst_if != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = &dst->u_addr.ip6;
  iftmp.2 = ip6_select_source_address (dst_if, _6);
  goto <bb 11>; [INV]

  <bb 10> :
  iftmp.2 = 0B;

  <bb 11> :
  iftmp.1 = iftmp.2;
  goto <bb 16>; [INV]

  <bb 12> :
  if (dst_if != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  iftmp.3 = &dst_if->ip_addr;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.3 = 0B;

  <bb 15> :
  iftmp.1 = iftmp.3;

  <bb 16> :
  dst_ip = iftmp.1;
  if (dst_if != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 17> :
  if (dst_ip != 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 18> :
  _7 = dst_ip->type;
  result->type = _7;
  _8 = dst_ip->type;
  if (_8 == 6)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _9 = dst_ip->u_addr.ip6.addr[0];
  result->u_addr.ip6.addr[0] = _9;
  _10 = dst_ip->u_addr.ip6.addr[1];
  result->u_addr.ip6.addr[1] = _10;
  _11 = dst_ip->u_addr.ip6.addr[2];
  result->u_addr.ip6.addr[2] = _11;
  _12 = dst_ip->u_addr.ip6.addr[3];
  result->u_addr.ip6.addr[3] = _12;
  _13 = dst_ip->u_addr.ip6.zone;
  result->u_addr.ip6.zone = _13;
  goto <bb 21>; [INV]

  <bb 20> :
  _14 = dst_ip->u_addr.ip4.addr;
  result->u_addr.ip4.addr = _14;
  result->u_addr.ip6.addr[3] = 0;
  _15 = result->u_addr.ip6.addr[3];
  result->u_addr.ip6.addr[2] = _15;
  _16 = result->u_addr.ip6.addr[2];
  result->u_addr.ip6.addr[1] = _16;
  result->u_addr.ip6.zone = 0;

  <bb 21> :
  D.7688 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 22> :
  D.7688 = 0;
  // predicted unlikely by early return (on trees) predictor.

  <bb 23> :
<L20>:
  return D.7688;

}


snmp_sendto (void * handle, struct pbuf * p, const struct ip_addr_t * dst, u16_t port)
{
  err_t D.7662;

  <bb 2> :
  D.7662 = udp_sendto (handle, p, dst, port);

  <bb 3> :
<L0>:
  return D.7662;

}


snmp_recv (void * arg, struct udp_pcb * pcb, struct pbuf * p, const struct ip_addr_t * addr, u16_t port)
{
  <bb 2> :
  snmp_receive (pcb, p, addr, port);
  pbuf_free (p);
  return;

}


