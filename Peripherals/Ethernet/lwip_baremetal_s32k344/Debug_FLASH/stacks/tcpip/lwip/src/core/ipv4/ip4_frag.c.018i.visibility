
Marking local functions:


Marking externally visible functions: ip4_frag/13 ip4_reass/9 ip_reass_tmr/3


Marking externally visible variables:


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

pbuf_ref/28 (pbuf_ref) @06caf620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 
  Calls: 
pbuf_alloced_custom/27 (pbuf_alloced_custom) @06caf540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 
  Calls: 
pbuf_alloc/26 (pbuf_alloc) @06caf460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 
  Calls: 
pbuf_cat/25 (pbuf_cat) @06c4ee00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 ip4_reass/9 
  Calls: 
pbuf_remove_header/24 (pbuf_remove_header) @06c4ec40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_reass/9 
  Calls: 
inet_chksum/23 (inet_chksum) @06c4eb60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 ip4_reass/9 
  Calls: 
lwip_htons/22 (lwip_htons) @06c4ed20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 ip4_frag/13 ip4_frag/13 ip4_reass/9 ip4_reass/9 ip4_reass/9 ip4_reass/9 ip4_reass/9 ip_reass_chain_frag_into_datagram_and_validate/8 ip_reass_chain_frag_into_datagram_and_validate/8 
  Calls: 
memp_free/21 (memp_free) @06c4e9a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip_frag_free_pbuf_custom_ref/11 ip_reass_dequeue_datagram/7 
  Calls: 
memset/20 (memset) @06c4e7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip_reass_enqueue_new_datagram/6 
  Calls: 
memp_malloc/19 (memp_malloc) @06c4e700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip_frag_alloc_pbuf_custom_ref/10 ip_reass_enqueue_new_datagram/6 ip_reass_enqueue_new_datagram/6 
  Calls: 
pbuf_free/18 (pbuf_free) @06c4e380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 ip4_frag/13 ip4_frag/13 ipfrag_free_pbuf_custom/12 ip4_reass/9 ip_reass_free_complete_datagram/4 ip_reass_free_complete_datagram/4 
  Calls: 
pbuf_clen/17 (pbuf_clen) @06c4e2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_reass/9 ip4_reass/9 ip_reass_free_complete_datagram/4 ip_reass_free_complete_datagram/4 
  Calls: 
icmp_time_exceeded/16 (icmp_time_exceeded) @06c4e1c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip_reass_free_complete_datagram/4 
  Calls: 
memcpy/15 (memcpy) @06c4e0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: ip4_frag/13 ip4_reass/9 ip4_reass/9 ip_reass_enqueue_new_datagram/6 ip_reass_free_complete_datagram/4 
  Calls: 
lwip_stats/14 (lwip_stats) @06c42d80
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: ip_reass_free_complete_datagram/4 (read) ip_reass_free_complete_datagram/4 (write) ip_reass_enqueue_new_datagram/6 (read) ip_reass_enqueue_new_datagram/6 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (write) ip4_frag/13 (read) ip4_frag/13 (write) ip4_frag/13 (read) ip4_frag/13 (write) ip4_frag/13 (read) ip4_frag/13 (write) 
  Availability: not_available
  Varpool flags:
ip4_frag/13 (ip4_frag) @06c3eb60
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: ipfrag_free_pbuf_custom/12 (addr) lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: pbuf_free/18 inet_chksum/23 lwip_htons/22 lwip_htons/22 pbuf_cat/25 pbuf_ref/28 pbuf_free/18 ip_frag_free_pbuf_custom_ref/11 pbuf_alloced_custom/27 pbuf_free/18 ip_frag_alloc_pbuf_custom_ref/10 memcpy/15 pbuf_alloc/26 lwip_htons/22 
   Indirect call Num speculative call targets: 0
ipfrag_free_pbuf_custom/12 (ipfrag_free_pbuf_custom) @06c3e540
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  Address is taken.
  References: 
  Referring: ip4_frag/13 (addr) 
  Availability: available
  Function flags: body
  Called by: 
  Calls: ip_frag_free_pbuf_custom_ref/11 pbuf_free/18 
ip_frag_free_pbuf_custom_ref/11 (ip_frag_free_pbuf_custom_ref) @06c3e2a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip4_frag/13 ipfrag_free_pbuf_custom/12 
  Calls: memp_free/21 
ip_frag_alloc_pbuf_custom_ref/10 (ip_frag_alloc_pbuf_custom_ref) @06c3e000
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip4_frag/13 
  Calls: memp_malloc/19 
ip4_reass/9 (ip4_reass) @06c29ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (write) lwip_stats/14 (read) lwip_stats/14 (write) ip_reass_pbufcount/2 (read) ip_reass_pbufcount/2 (read) lwip_stats/14 (read) lwip_stats/14 (write) reassdatagrams/1 (read) lwip_stats/14 (read) lwip_stats/14 (write) ip_reass_pbufcount/2 (read) ip_reass_pbufcount/2 (write) reassdatagrams/1 (read) reassdatagrams/1 (read) ip_reass_pbufcount/2 (read) ip_reass_pbufcount/2 (read) ip_reass_pbufcount/2 (write) lwip_stats/14 (read) lwip_stats/14 (write) reassdatagrams/1 (read) lwip_stats/14 (read) lwip_stats/14 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: pbuf_free/18 ip_reass_dequeue_datagram/7 pbuf_clen/17 ip_reass_dequeue_datagram/7 pbuf_cat/25 pbuf_remove_header/24 inet_chksum/23 lwip_htons/22 memcpy/15 ip_reass_chain_frag_into_datagram_and_validate/8 memcpy/15 lwip_htons/22 lwip_htons/22 ip_reass_enqueue_new_datagram/6 ip_reass_remove_oldest_datagram/5 pbuf_clen/17 lwip_htons/22 lwip_htons/22 
ip_reass_chain_frag_into_datagram_and_validate/8 (ip_reass_chain_frag_into_datagram_and_validate) @06c29620
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip4_reass/9 
  Calls: lwip_htons/22 lwip_htons/22 
ip_reass_dequeue_datagram/7 (ip_reass_dequeue_datagram) @06c292a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: reassdatagrams/1 (read) reassdatagrams/1 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip4_reass/9 ip4_reass/9 ip_reass_free_complete_datagram/4 
  Calls: memp_free/21 
ip_reass_enqueue_new_datagram/6 (ip_reass_enqueue_new_datagram) @06c29000
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: lwip_stats/14 (read) lwip_stats/14 (write) reassdatagrams/1 (read) reassdatagrams/1 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip4_reass/9 
  Calls: memcpy/15 memset/20 memp_malloc/19 ip_reass_remove_oldest_datagram/5 memp_malloc/19 
ip_reass_remove_oldest_datagram/5 (ip_reass_remove_oldest_datagram) @06c1be00
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: reassdatagrams/1 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip4_reass/9 ip_reass_enqueue_new_datagram/6 
  Calls: ip_reass_free_complete_datagram/4 
ip_reass_free_complete_datagram/4 (ip_reass_free_complete_datagram) @06c1bb60
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: lwip_stats/14 (read) lwip_stats/14 (write) ip_reass_pbufcount/2 (read) ip_reass_pbufcount/2 (read) ip_reass_pbufcount/2 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ip_reass_remove_oldest_datagram/5 ip_reass_tmr/3 
  Calls: ip_reass_dequeue_datagram/7 pbuf_free/18 pbuf_clen/17 pbuf_free/18 pbuf_clen/17 icmp_time_exceeded/16 memcpy/15 
ip_reass_tmr/3 (ip_reass_tmr) @06c1b620
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: reassdatagrams/1 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: ip_reass_free_complete_datagram/4 
ip_reass_pbufcount/2 (ip_reass_pbufcount) @06c1a8b8
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: ip_reass_free_complete_datagram/4 (read) ip_reass_free_complete_datagram/4 (read) ip_reass_free_complete_datagram/4 (write) ip4_reass/9 (read) ip4_reass/9 (read) ip4_reass/9 (read) ip4_reass/9 (write) ip4_reass/9 (read) ip4_reass/9 (read) ip4_reass/9 (write) 
  Availability: available
  Varpool flags:
reassdatagrams/1 (reassdatagrams) @06c1a828
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: ip_reass_tmr/3 (read) ip_reass_remove_oldest_datagram/5 (read) ip_reass_enqueue_new_datagram/6 (read) ip_reass_enqueue_new_datagram/6 (write) ip_reass_dequeue_datagram/7 (read) ip_reass_dequeue_datagram/7 (write) ip4_reass/9 (read) ip4_reass/9 (read) ip4_reass/9 (read) ip4_reass/9 (read) 
  Availability: available
  Varpool flags:
ip4_frag (struct pbuf * p, struct netif * netif, const struct ip4_addr_t * dest)
{
  u16_t plen;
  struct pbuf_custom_ref * pcr;
  int mf_set;
  u16_t tmp;
  u16_t poff;
  int last;
  u16_t ofo;
  u16_t fragsize;
  u16_t left;
  const u16_t nfb;
  struct ip_hdr * iphdr;
  struct ip_hdr * original_iphdr;
  u16_t left_to_copy;
  u16_t newpbuflen;
  struct pbuf * newpbuf;
  struct pbuf * rambuf;
  err_t D.7718;

  <bb 2> :
  newpbuflen = 0;
  _1 = netif->mtu;
  _2 = (int) _1;
  _3 = _2 + -20;
  _4 = _3 / 8;
  nfb = (const u16_t) _4;
  poff = 20;
  original_iphdr = p->payload;
  iphdr = original_iphdr;
  _5 = iphdr->_v_hl;
  _6 = _5 & 15;
  _7 = _6 * 4;
  if (_7 != 20)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7718 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 4> :
  _8 = p->len;
  if (_8 <= 19)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7718 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 6> :
  _9 = iphdr->_offset;
  tmp = lwip_htons (_9);
  ofo = tmp & 8191;
  _10 = (int) tmp;
  mf_set = _10 & 8192;
  _11 = p->tot_len;
  left = _11 + 65516;
  goto <bb 27>; [INV]

  <bb 7> :
  _12 = nfb * 8;
  fragsize = MIN_EXPR <left, _12>;
  rambuf = pbuf_alloc (14, 20, 640);
  if (rambuf == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  // predicted unlikely by goto predictor.
  goto <bb 29>; [INV]

  <bb 9> :
  _13 = rambuf->len;
  if (_13 <= 19)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 10>; [INV]

  <bb 11> :
  _14 = rambuf->payload;
  memcpy (_14, original_iphdr, 20);
  iphdr = rambuf->payload;
  left_to_copy = fragsize;
  goto <bb 22>; [INV]

  <bb 12> :
  _15 = p->len;
  plen = _15 - poff;
  _16 = p->len;
  if (poff > _16)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 13>; [INV]

  <bb 14> :
  newpbuflen = MIN_EXPR <plen, left_to_copy>;
  if (newpbuflen == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  poff = 0;
  p = p->next;
  // predicted unlikely by continue predictor.
  goto <bb 22>; [INV]

  <bb 16> :
  pcr = ip_frag_alloc_pbuf_custom_ref ();
  if (pcr == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  pbuf_free (rambuf);
  // predicted unlikely by goto predictor.
  goto <bb 29>; [INV]

  <bb 18> :
  _17 = &pcr->pc;
  _18 = p->payload;
  _19 = (sizetype) poff;
  _20 = _18 + _19;
  newpbuf = pbuf_alloced_custom (0, newpbuflen, 65, _17, _20, newpbuflen);
  if (newpbuf == 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  ip_frag_free_pbuf_custom_ref (pcr);
  pbuf_free (rambuf);
  // predicted unlikely by goto predictor.
  goto <bb 29>; [INV]

  <bb 20> :
  pbuf_ref (p);
  pcr->original = p;
  pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
  pbuf_cat (rambuf, newpbuf);
  left_to_copy = left_to_copy - newpbuflen;
  if (left_to_copy != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  poff = 0;
  p = p->next;

  <bb 22> :
  if (left_to_copy != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  poff = poff + newpbuflen;
  _21 = netif->mtu;
  _22 = (int) _21;
  _23 = _22 + -19;
  _24 = (int) left;
  _25 = _23 > _24;
  last = (int) _25;
  tmp = ofo & 8191;
  if (last == 0)
    goto <bb 25>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  if (mf_set != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  tmp = tmp | 8192;

  <bb 26> :
  _26 = lwip_htons (tmp);
  iphdr->_offset = _26;
  _27 = fragsize + 20;
  _28 = lwip_htons (_27);
  iphdr->_len = _28;
  iphdr->_chksum = 0;
  _29 = inet_chksum (iphdr, 20);
  iphdr->_chksum = _29;
  _30 = netif->output;
  _30 (netif, rambuf, dest);
  _31 = lwip_stats.ip_frag.xmit;
  _32 = _31 + 1;
  lwip_stats.ip_frag.xmit = _32;
  pbuf_free (rambuf);
  left = left - fragsize;
  ofo = ofo + nfb;

  <bb 27> :
  if (left != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  _33 = lwip_stats.mib2.ipfragoks;
  _34 = _33 + 1;
  lwip_stats.mib2.ipfragoks = _34;
  D.7718 = 0;
  goto <bb 30>; [INV]

  <bb 29> :
memerr:
  _35 = lwip_stats.mib2.ipfragfails;
  _36 = _35 + 1;
  lwip_stats.mib2.ipfragfails = _36;
  D.7718 = -1;

  <bb 30> :
<L30>:
  return D.7718;

}


ipfrag_free_pbuf_custom (struct pbuf * p)
{
  struct pbuf_custom_ref * pcr;

  <bb 2> :
  pcr = p;
  if (pcr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (pcr != p)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _1 = pcr->original;
  if (_1 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _2 = pcr->original;
  pbuf_free (_2);

  <bb 8> :
  ip_frag_free_pbuf_custom_ref (pcr);
  return;

}


ip_frag_free_pbuf_custom_ref (struct pbuf_custom_ref * p)
{
  <bb 2> :
  if (p == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  memp_free (6, p);
  return;

}


ip_frag_alloc_pbuf_custom_ref ()
{
  struct pbuf_custom_ref * D.7706;

  <bb 2> :
  D.7706 = memp_malloc (6);

  <bb 3> :
<L0>:
  return D.7706;

}


ip4_reass (struct pbuf * p)
{
  u16_t datagram_len;
  struct ip_reassdata * ipr_prev;
  u16_t datagram_len;
  u16_t datagram_len;
  int is_last;
  int valid;
  u8_t hlen;
  u16_t clen;
  u16_t len;
  u16_t offset;
  struct ip_reass_helper * iprh;
  struct ip_reassdata * ipr;
  struct ip_hdr * fraghdr;
  struct pbuf * r;
  struct pbuf * D.7698;

  <bb 2> :
  _1 = lwip_stats.ip_frag.recv;
  _2 = _1 + 1;
  lwip_stats.ip_frag.recv = _2;
  _3 = lwip_stats.mib2.ipreasmreqds;
  _4 = _3 + 1;
  lwip_stats.mib2.ipreasmreqds = _4;
  fraghdr = p->payload;
  _5 = fraghdr->_v_hl;
  _6 = _5 & 15;
  _7 = _6 * 4;
  if (_7 != 20)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _8 = lwip_stats.ip_frag.err;
  _9 = _8 + 1;
  lwip_stats.ip_frag.err = _9;
  // predicted unlikely by goto predictor.
  goto <bb 52>; [INV]

  <bb 4> :
  _10 = fraghdr->_offset;
  _11 = lwip_htons (_10);
  _12 = _11 & 8191;
  offset = _12 * 8;
  _13 = fraghdr->_len;
  len = lwip_htons (_13);
  _14 = fraghdr->_v_hl;
  _15 = _14 & 15;
  hlen = _15 * 4;
  _16 = (short unsigned int) hlen;
  if (len < _16)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by goto predictor.
  goto <bb 52>; [INV]

  <bb 6> :
  _17 = (short unsigned int) hlen;
  len = len - _17;
  clen = pbuf_clen (p);
  ip_reass_pbufcount.4_18 = ip_reass_pbufcount;
  _19 = (int) ip_reass_pbufcount.4_18;
  _20 = (int) clen;
  _21 = _19 + _20;
  if (_21 > 10)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _22 = (int) clen;
  _23 = ip_reass_remove_oldest_datagram (fraghdr, _22);
  if (_23 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  ip_reass_pbufcount.5_24 = ip_reass_pbufcount;
  _25 = (int) ip_reass_pbufcount.5_24;
  _26 = (int) clen;
  _27 = _25 + _26;
  if (_27 > 10)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _28 = lwip_stats.ip_frag.memerr;
  _29 = _28 + 1;
  lwip_stats.ip_frag.memerr = _29;
  // predicted unlikely by goto predictor.
  goto <bb 52>; [INV]

  <bb 10> :
  ipr = reassdatagrams;
  goto <bb 16>; [INV]

  <bb 11> :
  _30 = ipr->iphdr.src.addr;
  _31 = fraghdr->src.addr;
  if (_30 == _31)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _32 = ipr->iphdr.dest.addr;
  _33 = fraghdr->dest.addr;
  if (_32 == _33)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _34 = ipr->iphdr._id;
  _35 = fraghdr->_id;
  if (_34 == _35)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _36 = lwip_stats.ip_frag.cachehit;
  _37 = _36 + 1;
  lwip_stats.ip_frag.cachehit = _37;
  goto <bb 17>; [INV]

  <bb 15> :
  ipr = ipr->next;

  <bb 16> :
  if (ipr != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  if (ipr == 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  _38 = (int) clen;
  ipr = ip_reass_enqueue_new_datagram (fraghdr, _38);
  if (ipr == 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  // predicted unlikely by goto predictor.
  goto <bb 52>; [INV]

  <bb 20> :
  _39 = fraghdr->_offset;
  _40 = lwip_htons (_39);
  _41 = (unsigned int) _40;
  _42 = _41 & 8191;
  if (_42 == 0)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 21> :
  _43 = ipr->iphdr._offset;
  _44 = lwip_htons (_43);
  _45 = (unsigned int) _44;
  _46 = _45 & 8191;
  if (_46 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _47 = &ipr->iphdr;
  memcpy (_47, fraghdr, 20);

  <bb 23> :
  _48 = fraghdr->_offset;
  _49 = (int) _48;
  _50 = _49 & 32;
  _51 = _50 == 0;
  is_last = (int) _51;
  if (is_last != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 24> :
  datagram_len = offset + len;
  if (datagram_len < offset)
    goto <bb 26>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  if (datagram_len > 65515)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  // predicted unlikely by goto predictor.
  goto <bb 46>; [INV]

  <bb 27> :
  valid = ip_reass_chain_frag_into_datagram_and_validate (ipr, p, is_last);
  if (valid == -1)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 46>; [INV]

  <bb 29> :
  ip_reass_pbufcount.6_52 = ip_reass_pbufcount;
  _53 = clen + ip_reass_pbufcount.6_52;
  ip_reass_pbufcount = _53;
  if (is_last != 0)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  datagram_len = offset + len;
  ipr->datagram_len = datagram_len;
  _54 = ipr->flags;
  _55 = _54 | 1;
  ipr->flags = _55;

  <bb 31> :
  if (valid == 1)
    goto <bb 32>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 32> :
  _56 = ipr->datagram_len;
  datagram_len = _56 + 20;
  _57 = ipr->p;
  _58 = _57->payload;
  r = MEM[(struct ip_reass_helper *)_58].next_pbuf;
  _59 = ipr->p;
  fraghdr = _59->payload;
  _60 = &ipr->iphdr;
  memcpy (fraghdr, _60, 20);
  _61 = lwip_htons (datagram_len);
  fraghdr->_len = _61;
  fraghdr->_offset = 0;
  fraghdr->_chksum = 0;
  _62 = inet_chksum (fraghdr, 20);
  fraghdr->_chksum = _62;
  p = ipr->p;
  goto <bb 34>; [INV]

  <bb 33> :
  iprh = r->payload;
  pbuf_remove_header (r, 20);
  pbuf_cat (p, r);
  r = iprh->next_pbuf;

  <bb 34> :
  if (r != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 35> :
  reassdatagrams.7_63 = reassdatagrams;
  if (ipr == reassdatagrams.7_63)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  ipr_prev = 0B;
  goto <bb 42>; [INV]

  <bb 37> :
  ipr_prev = reassdatagrams;
  goto <bb 41>; [INV]

  <bb 38> :
  _64 = ipr_prev->next;
  if (ipr == _64)
    goto <bb 39>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 39> :
  goto <bb 42>; [INV]

  <bb 40> :
  ipr_prev = ipr_prev->next;

  <bb 41> :
  if (ipr_prev != 0B)
    goto <bb 38>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 42> :
  ip_reass_dequeue_datagram (ipr, ipr_prev);
  clen = pbuf_clen (p);
  ip_reass_pbufcount.8_65 = ip_reass_pbufcount;
  if (clen > ip_reass_pbufcount.8_65)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 43>; [INV]

  <bb 44> :
  ip_reass_pbufcount.9_66 = ip_reass_pbufcount;
  _67 = ip_reass_pbufcount.9_66 - clen;
  ip_reass_pbufcount = _67;
  _68 = lwip_stats.mib2.ipreasmoks;
  _69 = _68 + 1;
  lwip_stats.mib2.ipreasmoks = _69;
  D.7698 = p;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 53>; [INV]

  <bb 45> :
  D.7698 = 0B;
  goto <bb 53>; [INV]

  <bb 46> :
nullreturn_ipr:
  if (ipr == 0B)
    goto <bb 47>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 47> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 47>; [INV]

  <bb 48> :
  _70 = ipr->p;
  if (_70 == 0B)
    goto <bb 49>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 49> :
  reassdatagrams.10_71 = reassdatagrams;
  if (ipr != reassdatagrams.10_71)
    goto <bb 50>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 50> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 50>; [INV]

  <bb 51> :
  ip_reass_dequeue_datagram (ipr, 0B);

  <bb 52> :
nullreturn:
  _72 = lwip_stats.ip_frag.drop;
  _73 = _72 + 1;
  lwip_stats.ip_frag.drop = _73;
  pbuf_free (p);
  D.7698 = 0B;

  <bb 53> :
<L62>:
  return D.7698;

}


ip_reass_chain_frag_into_datagram_and_validate (struct ip_reassdata * ipr, struct pbuf * new_p, int is_last)
{
  int valid;
  struct ip_hdr * fraghdr;
  u8_t hlen;
  u16_t len;
  u16_t offset;
  struct pbuf * q;
  struct ip_reass_helper * iprh_prev;
  struct ip_reass_helper * iprh_tmp;
  struct ip_reass_helper * iprh;
  int D.7600;

  <bb 2> :
  iprh_prev = 0B;
  valid = 1;
  fraghdr = new_p->payload;
  _1 = fraghdr->_len;
  len = lwip_htons (_1);
  _2 = fraghdr->_v_hl;
  _3 = _2 & 15;
  hlen = _3 * 4;
  _4 = (short unsigned int) hlen;
  if (len < _4)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7600 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 4> :
  _5 = (short unsigned int) hlen;
  len = len - _5;
  _6 = fraghdr->_offset;
  _7 = lwip_htons (_6);
  _8 = _7 & 8191;
  offset = _8 * 8;

  <bb 5> :
  iprh = new_p->payload;
  iprh->next_pbuf = 0B;
  iprh->start = offset;
  _9 = offset + len;
  iprh->end = _9;
  _10 = iprh->end;
  if (offset > _10)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.7600 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 7> :
  q = ipr->p;
  goto <bb 27>; [INV]

  <bb 8> :
  iprh_tmp = q->payload;
  _11 = iprh->start;
  _12 = iprh_tmp->start;
  if (_11 < _12)
    goto <bb 9>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 9> :
  iprh->next_pbuf = q;
  if (iprh_prev != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 10> :
  _13 = iprh->start;
  _14 = iprh_prev->end;
  if (_13 < _14)
    goto <bb 12>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _15 = iprh->end;
  _16 = iprh_tmp->start;
  if (_15 > _16)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  D.7600 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 13> :
  iprh_prev->next_pbuf = new_p;
  _17 = iprh_prev->end;
  _18 = iprh->start;
  if (_17 != _18)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 14> :
  valid = 0;
  goto <bb 18>; [INV]

  <bb 15> :
  _19 = iprh->end;
  _20 = iprh_tmp->start;
  if (_19 > _20)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  D.7600 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 17> :
  ipr->p = new_p;

  <bb 18> :
  goto <bb 28>; [INV]

  <bb 19> :
  _21 = iprh->start;
  _22 = iprh_tmp->start;
  if (_21 == _22)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  D.7600 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 21> :
  _23 = iprh->start;
  _24 = iprh_tmp->end;
  if (_23 < _24)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  D.7600 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 23> :
  if (iprh_prev != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 24> :
  _25 = iprh_prev->end;
  _26 = iprh_tmp->start;
  if (_25 != _26)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  valid = 0;

  <bb 26> :
  q = iprh_tmp->next_pbuf;
  iprh_prev = iprh_tmp;

  <bb 27> :
  if (q != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  if (q == 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 29> :
  if (iprh_prev != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 30> :
  _27 = iprh_prev->end;
  _28 = iprh->start;
  if (_27 > _28)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 31>; [INV]

  <bb 32> :
  iprh_prev->next_pbuf = new_p;
  _29 = iprh_prev->end;
  _30 = iprh->start;
  if (_29 != _30)
    goto <bb 33>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 33> :
  valid = 0;
  goto <bb 37>; [INV]

  <bb 34> :
  _31 = ipr->p;
  if (_31 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 35> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 35>; [INV]

  <bb 36> :
  ipr->p = new_p;

  <bb 37> :
  if (is_last != 0)
    goto <bb 39>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  _32 = ipr->flags;
  _33 = (int) _32;
  _34 = _33 & 1;
  if (_34 != 0)
    goto <bb 39>; [INV]
  else
    goto <bb 56>; [INV]

  <bb 39> :
  if (valid != 0)
    goto <bb 40>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 40> :
  _35 = ipr->p;
  if (_35 == 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 41> :
  _36 = ipr->p;
  _37 = _36->payload;
  _38 = MEM[(struct ip_reass_helper *)_37].start;
  if (_38 != 0)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  valid = 0;
  goto <bb 55>; [INV]

  <bb 43> :
  iprh_prev = iprh;
  q = iprh->next_pbuf;
  goto <bb 47>; [INV]

  <bb 44> :
  iprh = q->payload;
  _39 = iprh_prev->end;
  _40 = iprh->start;
  if (_39 != _40)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  valid = 0;
  goto <bb 48>; [INV]

  <bb 46> :
  iprh_prev = iprh;
  q = iprh->next_pbuf;

  <bb 47> :
  if (q != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 48> :
  if (valid != 0)
    goto <bb 49>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 49> :
  _41 = ipr->p;
  if (_41 == 0B)
    goto <bb 50>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 50> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 50>; [INV]

  <bb 51> :
  _42 = ipr->p;
  _43 = _42->payload;
  if (iprh == _43)
    goto <bb 52>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 52> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 52>; [INV]

  <bb 53> :
  _44 = iprh->next_pbuf;
  if (_44 != 0B)
    goto <bb 54>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 54> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 54>; [INV]

  <bb 55> :
  _45 = valid != 0;
  D.7600 = (int) _45;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 57>; [INV]

  <bb 56> :
  D.7600 = 0;

  <bb 57> :
<L68>:
  return D.7600;

}


ip_reass_dequeue_datagram (struct ip_reassdata * ipr, struct ip_reassdata * prev)
{
  <bb 2> :
  reassdatagrams.3_1 = reassdatagrams;
  if (ipr == reassdatagrams.3_1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = ipr->next;
  reassdatagrams = _2;
  goto <bb 7>; [INV]

  <bb 4> :
  if (prev == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 5>; [INV]

  <bb 6> :
  _3 = ipr->next;
  prev->next = _3;

  <bb 7> :
  memp_free (5, ipr);
  return;

}


ip_reass_enqueue_new_datagram (struct ip_hdr * fraghdr, int clen)
{
  struct ip_reassdata * ipr;
  struct ip_reassdata * D.7591;

  <bb 2> :
  ipr = memp_malloc (5);
  if (ipr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _1 = ip_reass_remove_oldest_datagram (fraghdr, clen);
  if (clen <= _1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  ipr = memp_malloc (5);

  <bb 5> :
  if (ipr == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _2 = lwip_stats.ip_frag.memerr;
  _3 = _2 + 1;
  lwip_stats.ip_frag.memerr = _3;
  D.7591 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  memset (ipr, 0, 32);
  ipr->timer = 15;
  reassdatagrams.2_4 = reassdatagrams;
  ipr->next = reassdatagrams.2_4;
  reassdatagrams = ipr;
  _5 = &ipr->iphdr;
  memcpy (_5, fraghdr, 20);
  D.7591 = ipr;

  <bb 8> :
<L6>:
  return D.7591;

}


ip_reass_remove_oldest_datagram (struct ip_hdr * fraghdr, int pbufs_needed)
{
  int other_datagrams;
  int pbufs_freed_current;
  int pbufs_freed;
  struct ip_reassdata * oldest_prev;
  struct ip_reassdata * prev;
  struct ip_reassdata * oldest;
  struct ip_reassdata * r;
  int D.7583;

  <bb 2> :
  pbufs_freed = 0;

  <bb 3> :
  oldest = 0B;
  prev = 0B;
  oldest_prev = 0B;
  other_datagrams = 0;
  r = reassdatagrams;
  goto <bb 14>; [INV]

  <bb 4> :
  _1 = r->iphdr.src.addr;
  _2 = fraghdr->src.addr;
  if (_1 != _2)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _3 = r->iphdr.dest.addr;
  _4 = fraghdr->dest.addr;
  if (_3 != _4)
    goto <bb 7>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _5 = r->iphdr._id;
  _6 = fraghdr->_id;
  if (_5 != _6)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  other_datagrams = other_datagrams + 1;
  if (oldest == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  oldest = r;
  oldest_prev = prev;
  goto <bb 11>; [INV]

  <bb 9> :
  _7 = r->timer;
  _8 = oldest->timer;
  if (_7 <= _8)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  oldest = r;
  oldest_prev = prev;

  <bb 11> :
  _9 = r->next;
  if (_9 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  prev = r;

  <bb 13> :
  r = r->next;

  <bb 14> :
  if (r != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  if (oldest != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  pbufs_freed_current = ip_reass_free_complete_datagram (oldest, oldest_prev);
  pbufs_freed = pbufs_freed + pbufs_freed_current;

  <bb 17> :
  if (pbufs_freed < pbufs_needed)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  if (other_datagrams > 1)
    goto <bb 3>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  D.7583 = pbufs_freed;

  <bb 20> :
<L19>:
  return D.7583;

}


ip_reass_free_complete_datagram (struct ip_reassdata * ipr, struct ip_reassdata * prev)
{
  struct pbuf * pcur;
  struct ip_reass_helper * iprh;
  struct pbuf * p;
  u16_t clen;
  u16_t pbufs_freed;
  int D.7567;

  <bb 2> :
  pbufs_freed = 0;
  if (prev == ipr)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (prev != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _1 = prev->next;
  if (ipr != _1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 6>; [INV]

  <bb 7> :
  _2 = lwip_stats.mib2.ipreasmfails;
  _3 = _2 + 1;
  lwip_stats.mib2.ipreasmfails = _3;
  _4 = ipr->p;
  iprh = _4->payload;
  _5 = iprh->start;
  if (_5 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  p = ipr->p;
  _6 = iprh->next_pbuf;
  ipr->p = _6;
  _7 = p->payload;
  _8 = &ipr->iphdr;
  memcpy (_7, _8, 20);
  icmp_time_exceeded (p, 1);
  clen = pbuf_clen (p);
  _9 = (int) pbufs_freed;
  _10 = (int) clen;
  _11 = _9 + _10;
  if (_11 > 65535)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 9>; [INV]

  <bb 10> :
  pbufs_freed = pbufs_freed + clen;
  pbuf_free (p);

  <bb 11> :
  p = ipr->p;
  goto <bb 15>; [INV]

  <bb 12> :
  iprh = p->payload;
  pcur = p;
  p = iprh->next_pbuf;
  clen = pbuf_clen (pcur);
  _12 = (int) pbufs_freed;
  _13 = (int) clen;
  _14 = _12 + _13;
  if (_14 > 65535)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 13>; [INV]

  <bb 14> :
  pbufs_freed = pbufs_freed + clen;
  pbuf_free (pcur);

  <bb 15> :
  if (p != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  ip_reass_dequeue_datagram (ipr, prev);
  ip_reass_pbufcount.0_15 = ip_reass_pbufcount;
  if (pbufs_freed > ip_reass_pbufcount.0_15)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 17>; [INV]

  <bb 18> :
  ip_reass_pbufcount.1_16 = ip_reass_pbufcount;
  _17 = ip_reass_pbufcount.1_16 - pbufs_freed;
  ip_reass_pbufcount = _17;
  D.7567 = (int) pbufs_freed;

  <bb 19> :
<L22>:
  return D.7567;

}


ip_reass_tmr ()
{
  struct ip_reassdata * tmp;
  struct ip_reassdata * prev;
  struct ip_reassdata * r;

  <bb 2> :
  prev = 0B;
  r = reassdatagrams;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = r->timer;
  if (_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _2 = r->timer;
  _3 = _2;
  _4 = _3 + 255;
  r->timer = _4;
  prev = r;
  r = r->next;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = r;
  r = r->next;
  ip_reass_free_complete_datagram (tmp, prev);

  <bb 6> :
  if (r != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}


