udp_Table_get_next_cell_instance_and_value (const u32_t * column, struct snmp_obj_id * row_oid, union snmp_variant_value * value, u32_t * value_len)
{
  u32_t test_oid[5];
  u32_t result_temp[5];
  struct snmp_next_oid_state state;
  struct udp_pcb * pcb;
  snmp_err_t D.7959;

  <bb 2> :
  _1 = &row_oid->id;
  _2 = row_oid->len;
  snmp_next_oid_init (&state, _1, _2, &result_temp, 5);
  pcb = udp_pcbs;
  goto <bb 6>; [INV]

  <bb 3> :
  _3 = pcb->local_ip.type;
  if (_3 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _4 = &pcb->local_ip.u_addr.ip4;
  snmp_ip4_to_oid (_4, &test_oid[0]);
  _5 = pcb->local_port;
  _6 = (long unsigned int) _5;
  test_oid[4] = _6;
  snmp_next_oid_check (&state, &test_oid, 5, pcb);

  <bb 5> :
  pcb = pcb->next;
  test_oid = {CLOBBER};

  <bb 6> :
  if (pcb != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _7 = state.status;
  if (_7 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _8 = state.next_oid;
  _9 = state.next_oid_len;
  snmp_oid_assign (row_oid, _8, _9);
  _10 = state.reference;
  D.7959 = udp_Table_get_cell_value_core (_10, column, value, value_len);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 9> :
  D.7959 = 241;
  // predicted unlikely by early return (on trees) predictor.

  <bb 10> :
  state = {CLOBBER};
  result_temp = {CLOBBER};

  <bb 11> :
<L8>:
  return D.7959;

}


udp_Table_get_cell_value (const u32_t * column, const u32_t * row_oid, u8_t row_oid_len, union snmp_variant_value * value, u32_t * value_len)
{
  struct udp_pcb * pcb;
  u16_t port;
  struct ip4_addr_t ip;
  snmp_err_t D.7946;

  <bb 2> :
  _1 = snmp_oid_in_range (row_oid, row_oid_len, &udp_Table_oid_ranges, 5);
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7946 = 241;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  snmp_oid_to_ip4 (row_oid, &ip);
  _2 = row_oid + 16;
  _3 = *_2;
  port = (u16_t) _3;
  pcb = udp_pcbs;
  goto <bb 10>; [INV]

  <bb 5> :
  _4 = pcb->local_ip.type;
  if (_4 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _5 = ip.addr;
  _6 = pcb->local_ip.u_addr.ip4.addr;
  if (_5 == _6)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _7 = pcb->local_port;
  if (port == _7)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.7946 = udp_Table_get_cell_value_core (pcb, column, value, value_len);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 9> :
  pcb = pcb->next;

  <bb 10> :
  if (pcb != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  D.7946 = 241;

  <bb 12> :
  ip = {CLOBBER};

  <bb 13> :
<L12>:
  return D.7946;

}


udp_Table_get_cell_value_core (struct udp_pcb * pcb, const u32_t * column, union snmp_variant_value * value, u32_t * value_len)
{
  snmp_err_t D.7942;

  <bb 2> :
  _1 = *column;
  switch (_1) <default: <L2> [INV], case 1: <L0> [INV], case 2: <L1> [INV]>

  <bb 3> :
<L0>:
  _2 = pcb->local_ip.u_addr.ip4.addr;
  value->u32 = _2;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  _3 = pcb->local_port;
  _4 = (long unsigned int) _3;
  value->u32 = _4;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:
  D.7942 = 241;
  goto <bb 7>; [INV]

  <bb 6> :
  D.7942 = 0;

  <bb 7> :
<L4>:
  return D.7942;

}


udp_endpointTable_get_next_cell_instance_and_value (const u32_t * column, struct snmp_obj_id * row_oid, union snmp_variant_value * value, u32_t * value_len)
{
  u8_t idx;
  u32_t test_oid[39];
  u32_t result_temp[39];
  struct snmp_next_oid_state state;
  struct udp_pcb * pcb;
  snmp_err_t D.7939;
  unsigned char D.7936;
  unsigned char D.7935;

  <bb 2> :
  _1 = &row_oid->id;
  _2 = row_oid->len;
  snmp_next_oid_init (&state, _1, _2, &result_temp, 39);
  pcb = udp_pcbs;
  goto <bb 4>; [INV]

  <bb 3> :
  idx = 0;
  _3 = &pcb->local_ip;
  _4 = pcb->local_port;
  _5 = (int) idx;
  _6 = &test_oid[_5];
  D.7935 = snmp_ip_port_to_oid (_3, _4, _6);
  idx = D.7935 + idx;
  _7 = &pcb->remote_ip;
  _8 = pcb->remote_port;
  _9 = (int) idx;
  _10 = &test_oid[_9];
  D.7936 = snmp_ip_port_to_oid (_7, _8, _10);
  idx = D.7936 + idx;
  _11 = (int) idx;
  test_oid[_11] = 0;
  idx.8_12 = idx;
  idx = idx.8_12 + 1;
  snmp_next_oid_check (&state, &test_oid, idx, 0B);
  pcb = pcb->next;
  test_oid = {CLOBBER};

  <bb 4> :
  if (pcb != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _13 = state.status;
  if (_13 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _14 = state.next_oid;
  _15 = state.next_oid_len;
  snmp_oid_assign (row_oid, _14, _15);
  D.7939 = udp_endpointTable_get_cell_value_core (column, value);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  D.7939 = 241;
  // predicted unlikely by early return (on trees) predictor.

  <bb 8> :
  state = {CLOBBER};
  result_temp = {CLOBBER};

  <bb 9> :
<L6>:
  return D.7939;

}


udp_endpointTable_get_cell_value (const u32_t * column, const u32_t * row_oid, u8_t row_oid_len, union snmp_variant_value * value, u32_t * value_len)
{
  u8_t idx;
  struct udp_pcb * pcb;
  u16_t remote_port;
  u16_t local_port;
  struct ip_addr_t remote_ip;
  struct ip_addr_t local_ip;
  int iftmp.6;
  _Bool iftmp.5;
  _Bool iftmp.4;
  int iftmp.2;
  _Bool iftmp.1;
  _Bool iftmp.0;
  unsigned char D.7886;
  snmp_err_t D.7885;
  unsigned char D.7882;

  <bb 2> :
  idx = 0;
  _1 = (unsigned int) idx;
  _2 = _1 * 4;
  _3 = row_oid + _2;
  _4 = row_oid_len - idx;
  D.7882 = snmp_oid_to_ip_port (_3, _4, &local_ip, &local_port);
  idx = D.7882 + idx;
  if (idx == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.7885 = 241;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 4> :
  _5 = (unsigned int) idx;
  _6 = _5 * 4;
  _7 = row_oid + _6;
  _8 = row_oid_len - idx;
  D.7886 = snmp_oid_to_ip_port (_7, _8, &remote_ip, &remote_port);
  idx = D.7886 + idx;
  if (idx == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.7885 = 241;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 6> :
  if (idx >= row_oid_len)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.7885 = 241;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 8> :
  _9 = (unsigned int) idx;
  _10 = _9 * 4;
  _11 = row_oid + _10;
  _12 = *_11;
  if (_12 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.7885 = 241;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 10> :
  pcb = udp_pcbs;
  goto <bb 43>; [INV]

  <bb 11> :
  _13 = local_ip.type;
  _14 = pcb->local_ip.type;
  if (_13 == _14)
    goto <bb 12>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 12> :
  _15 = local_ip.type;
  if (_15 == 6)
    goto <bb 13>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 13> :
  _16 = local_ip.u_addr.ip6.addr[0];
  _17 = pcb->local_ip.u_addr.ip6.addr[0];
  if (_16 == _17)
    goto <bb 14>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 14> :
  _18 = local_ip.u_addr.ip6.addr[1];
  _19 = pcb->local_ip.u_addr.ip6.addr[1];
  if (_18 == _19)
    goto <bb 15>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 15> :
  _20 = local_ip.u_addr.ip6.addr[2];
  _21 = pcb->local_ip.u_addr.ip6.addr[2];
  if (_20 == _21)
    goto <bb 16>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 16> :
  _22 = local_ip.u_addr.ip6.addr[3];
  _23 = pcb->local_ip.u_addr.ip6.addr[3];
  if (_22 == _23)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 17> :
  _24 = local_ip.u_addr.ip6.zone;
  _25 = pcb->local_ip.u_addr.ip6.zone;
  if (_24 == _25)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  iftmp.2 = 1;
  goto <bb 20>; [INV]

  <bb 19> :
  iftmp.2 = 0;

  <bb 20> :
  iftmp.1 = (_Bool) iftmp.2;
  goto <bb 22>; [INV]

  <bb 21> :
  _26 = local_ip.u_addr.ip4.addr;
  _27 = pcb->local_ip.u_addr.ip4.addr;
  iftmp.1 = _26 == _27;

  <bb 22> :
  iftmp.0 = iftmp.1;
  goto <bb 24>; [INV]

  <bb 23> :
  iftmp.0 = 0;

  <bb 24> :
  if (iftmp.0 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 25> :
  _28 = pcb->local_port;
  local_port.3_29 = local_port;
  if (_28 == local_port.3_29)
    goto <bb 26>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 26> :
  _30 = remote_ip.type;
  _31 = pcb->remote_ip.type;
  if (_30 == _31)
    goto <bb 27>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 27> :
  _32 = remote_ip.type;
  if (_32 == 6)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  _33 = remote_ip.u_addr.ip6.addr[0];
  _34 = pcb->remote_ip.u_addr.ip6.addr[0];
  if (_33 == _34)
    goto <bb 29>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 29> :
  _35 = remote_ip.u_addr.ip6.addr[1];
  _36 = pcb->remote_ip.u_addr.ip6.addr[1];
  if (_35 == _36)
    goto <bb 30>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 30> :
  _37 = remote_ip.u_addr.ip6.addr[2];
  _38 = pcb->remote_ip.u_addr.ip6.addr[2];
  if (_37 == _38)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _39 = remote_ip.u_addr.ip6.addr[3];
  _40 = pcb->remote_ip.u_addr.ip6.addr[3];
  if (_39 == _40)
    goto <bb 32>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 32> :
  _41 = remote_ip.u_addr.ip6.zone;
  _42 = pcb->remote_ip.u_addr.ip6.zone;
  if (_41 == _42)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  iftmp.6 = 1;
  goto <bb 35>; [INV]

  <bb 34> :
  iftmp.6 = 0;

  <bb 35> :
  iftmp.5 = (_Bool) iftmp.6;
  goto <bb 37>; [INV]

  <bb 36> :
  _43 = remote_ip.u_addr.ip4.addr;
  _44 = pcb->remote_ip.u_addr.ip4.addr;
  iftmp.5 = _43 == _44;

  <bb 37> :
  iftmp.4 = iftmp.5;
  goto <bb 39>; [INV]

  <bb 38> :
  iftmp.4 = 0;

  <bb 39> :
  if (iftmp.4 != 0)
    goto <bb 40>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 40> :
  _45 = pcb->remote_port;
  remote_port.7_46 = remote_port;
  if (_45 == remote_port.7_46)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  D.7885 = udp_endpointTable_get_cell_value_core (column, value);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 42> :
  pcb = pcb->next;

  <bb 43> :
  if (pcb != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 44> :
  D.7885 = 241;

  <bb 45> :
  local_ip = {CLOBBER};
  remote_ip = {CLOBBER};
  local_port = {CLOBBER};
  remote_port = {CLOBBER};

  <bb 46> :
<L46>:
  return D.7885;

}


udp_endpointTable_get_cell_value_core (const u32_t * column, union snmp_variant_value * value)
{
  snmp_err_t D.7880;

  <bb 2> :
  _1 = *column;
  if (_1 == 8)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
<L0>:
  value->u32 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
<L1>:
  D.7880 = 241;
  goto <bb 6>; [INV]

  <bb 5> :
  D.7880 = 0;

  <bb 6> :
<L3>:
  return D.7880;

}


udp_get_value (struct snmp_node_instance * instance, void * value)
{
  u64_t val64;
  u64_t val64;
  u32_t * uint_ptr;
  s16_t D.7878;

  <bb 2> :
  uint_ptr = value;
  _1 = instance->node;
  _2 = _1->oid;
  switch (_2) <default: <L6> [INV], case 1: <L0> [INV], case 2: <L1> [INV], case 3: <L2> [INV], case 4: <L3> [INV], case 8: <L4> [INV], case 9: <L5> [INV]>

  <bb 3> :
<L0>:
  _3 = lwip_stats.mib2.udpindatagrams;
  *uint_ptr = _3;
  D.7878 = 4;
  goto <bb 11>; [INV]

  <bb 4> :
<L1>:
  _4 = lwip_stats.mib2.udpnoports;
  *uint_ptr = _4;
  D.7878 = 4;
  goto <bb 11>; [INV]

  <bb 5> :
<L2>:
  _5 = lwip_stats.mib2.udpinerrors;
  *uint_ptr = _5;
  D.7878 = 4;
  goto <bb 11>; [INV]

  <bb 6> :
<L3>:
  _6 = lwip_stats.mib2.udpoutdatagrams;
  *uint_ptr = _6;
  D.7878 = 4;
  goto <bb 11>; [INV]

  <bb 7> :
<L4>:
  _7 = lwip_stats.mib2.udpindatagrams;
  val64 = (u64_t) _7;
  MEM[(u64_t *)value] = val64;
  D.7878 = 8;
  goto <bb 11>; [INV]

  <bb 8> :
<L5>:
  _8 = lwip_stats.mib2.udpoutdatagrams;
  val64 = (u64_t) _8;
  MEM[(u64_t *)value] = val64;
  D.7878 = 8;
  goto <bb 11>; [INV]

  <bb 9> :
<L6>:

  <bb 10> :
  D.7878 = 0;

  <bb 11> :
<L8>:
  return D.7878;

}


