ip6_options_add_hbh_ra (struct pbuf * p, u8_t nexth, u8_t value)
{
  const u8_t hlen;
  struct ip6_opt_hdr * opt_hdr;
  struct ip6_hbh_hdr * hbh_hdr;
  u32_t offset;
  u8_t * opt_data;
  err_t D.8304;

  <bb 2> :
  offset = 0;
  hlen = 6;
  _1 = (unsigned int) hlen;
  _2 = _1 + 2;
  _3 = pbuf_add_header (p, _2);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = lwip_stats.ip6.err;
  _5 = _4 + 1;
  lwip_stats.ip6.err = _5;
  D.8304 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  hbh_hdr = p->payload;
  hbh_hdr->_nexth = nexth;
  hbh_hdr->_hlen = 0;
  offset = 2;
  opt_hdr = hbh_hdr + offset;
  opt_hdr->_opt_type = 5;
  opt_hdr->_opt_dlen = 2;
  offset = offset + 2;
  opt_data = hbh_hdr + offset;
  *opt_data = value;
  _6 = opt_data + 1;
  *_6 = 0;
  _7 = opt_hdr->_opt_dlen;
  _8 = (long unsigned int) _7;
  offset = offset + _8;
  opt_hdr = hbh_hdr + offset;
  opt_hdr->_opt_type = 1;
  opt_hdr->_opt_dlen = 0;
  D.8304 = 0;

  <bb 5> :
<L2>:
  return D.8304;

}


ip6_output (struct pbuf * p, const struct ip6_addr_t * src, const struct ip6_addr_t * dest, u8_t hl, u8_t tc, u8_t nexth)
{
  struct ip6_addr_t dest_addr;
  struct ip6_addr_t src_addr;
  struct ip6_hdr * ip6hdr;
  struct netif * netif;
  err_t D.8299;

  <bb 2> :
  _1 = p->ref;
  if (_1 != 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (dest != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  netif = ip6_route (src, dest);
  goto <bb 7>; [INV]

  <bb 6> :
  ip6hdr = p->payload;
  _2 = ip6hdr->src.addr[0];
  src_addr.addr[0] = _2;
  _3 = ip6hdr->src.addr[1];
  src_addr.addr[1] = _3;
  _4 = ip6hdr->src.addr[2];
  src_addr.addr[2] = _4;
  _5 = ip6hdr->src.addr[3];
  src_addr.addr[3] = _5;
  src_addr.zone = 0;
  _6 = ip6hdr->dest.addr[0];
  dest_addr.addr[0] = _6;
  _7 = ip6hdr->dest.addr[1];
  dest_addr.addr[1] = _7;
  _8 = ip6hdr->dest.addr[2];
  dest_addr.addr[2] = _8;
  _9 = ip6hdr->dest.addr[3];
  dest_addr.addr[3] = _9;
  dest_addr.zone = 0;
  netif = ip6_route (&src_addr, &dest_addr);
  dest = &dest_addr;

  <bb 7> :
  if (netif == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _10 = lwip_stats.ip6.rterr;
  _11 = _10 + 1;
  lwip_stats.ip6.rterr = _11;
  D.8299 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 9> :
  D.8299 = ip6_output_if (p, src, dest, hl, tc, nexth, netif);

  <bb 10> :
  src_addr = {CLOBBER};
  dest_addr = {CLOBBER};

  <bb 11> :
<L9>:
  return D.8299;

}


ip6_output_if_src (struct pbuf * p, const struct ip6_addr_t * src, const struct ip6_addr_t * dest, u8_t hl, u8_t tc, u8_t nexth, struct netif * netif)
{
  struct ip6_addr_t dest_addr;
  struct ip6_hdr * ip6hdr;
  u8_t iftmp.22;
  err_t D.8274;
  u8_t iftmp.21;

  <bb 2> :
  _1 = p->ref;
  if (_1 != 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 3>; [INV]

  <bb 4> :
  if (dest != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 5> :
  _2 = dest->zone;
  if (_2 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 6> :
  _3 = dest->addr[0];
  _4 = _3 & 49407;
  if (_4 == 33022)
    goto <bb 9>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = dest->addr[0];
  _6 = _5 & 36863;
  if (_6 == 511)
    goto <bb 9>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _7 = dest->addr[0];
  _8 = _7 & 36863;
  if (_8 == 767)
    goto <bb 9>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 9> :
  _9 = dest->addr[0];
  dest_addr.addr[0] = _9;
  _10 = dest->addr[1];
  dest_addr.addr[1] = _10;
  _11 = dest->addr[2];
  dest_addr.addr[2] = _11;
  _12 = dest->addr[3];
  dest_addr.addr[3] = _12;
  _13 = dest->zone;
  dest_addr.zone = _13;
  _14 = dest_addr.addr[0];
  _15 = _14 & 49407;
  if (_15 == 33022)
    goto <bb 12>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _16 = dest_addr.addr[0];
  _17 = _16 & 36863;
  if (_17 == 511)
    goto <bb 12>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _18 = dest_addr.addr[0];
  _19 = _18 & 36863;
  if (_19 == 767)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _20 = netif->num;
  iftmp.21 = _20 + 1;
  goto <bb 14>; [INV]

  <bb 13> :
  iftmp.21 = 0;

  <bb 14> :
  dest_addr.zone = iftmp.21;
  dest = &dest_addr;

  <bb 15> :
  _21 = pbuf_add_header (p, 40);
  if (_21 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _22 = lwip_stats.ip6.err;
  _23 = _22 + 1;
  lwip_stats.ip6.err = _23;
  D.8274 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 32>; [INV]

  <bb 17> :
  ip6hdr = p->payload;
  _24 = p->len;
  if (_24 <= 39)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  __asm__ __volatile__("BKPT #0
	");
  goto <bb 18>; [INV]

  <bb 19> :
  ip6hdr->_hoplim = hl;
  ip6hdr->_nexth = nexth;
  _25 = dest->addr[0];
  ip6hdr->dest.addr[0] = _25;
  _26 = dest->addr[1];
  ip6hdr->dest.addr[1] = _26;
  _27 = dest->addr[2];
  ip6hdr->dest.addr[2] = _27;
  _28 = dest->addr[3];
  ip6hdr->dest.addr[3] = _28;
  _29 = (long unsigned int) tc;
  _30 = _29 << 20;
  _31 = _30 | 1610612736;
  _32 = lwip_htonl (_31);
  ip6hdr->_v_tc_fl = _32;
  _33 = p->tot_len;
  _34 = _33 + 65496;
  _35 = lwip_htons (_34);
  ip6hdr->_plen = _35;
  if (src == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  src = &ip6_addr_any.u_addr.ip6;

  <bb 21> :
  _36 = src->addr[0];
  ip6hdr->src.addr[0] = _36;
  _37 = src->addr[1];
  ip6hdr->src.addr[1] = _37;
  _38 = src->addr[2];
  ip6hdr->src.addr[2] = _38;
  _39 = src->addr[3];
  ip6hdr->src.addr[3] = _39;
  goto <bb 28>; [INV]

  <bb 22> :
  ip6hdr = p->payload;
  _40 = ip6hdr->dest.addr[0];
  dest_addr.addr[0] = _40;
  _41 = ip6hdr->dest.addr[1];
  dest_addr.addr[1] = _41;
  _42 = ip6hdr->dest.addr[2];
  dest_addr.addr[2] = _42;
  _43 = ip6hdr->dest.addr[3];
  dest_addr.addr[3] = _43;
  dest_addr.zone = 0;
  _44 = dest_addr.addr[0];
  _45 = _44 & 49407;
  if (_45 == 33022)
    goto <bb 25>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  _46 = dest_addr.addr[0];
  _47 = _46 & 36863;
  if (_47 == 511)
    goto <bb 25>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  _48 = dest_addr.addr[0];
  _49 = _48 & 36863;
  if (_49 == 767)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  _50 = netif->num;
  iftmp.22 = _50 + 1;
  goto <bb 27>; [INV]

  <bb 26> :
  iftmp.22 = 0;

  <bb 27> :
  dest_addr.zone = iftmp.22;
  dest = &dest_addr;

  <bb 28> :
  _51 = lwip_stats.ip6.xmit;
  _52 = _51 + 1;
  lwip_stats.ip6.xmit = _52;
  _53 = netif->mtu6;
  if (_53 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 29> :
  _54 = p->tot_len;
  _55 = nd6_get_destination_mtu (dest, netif);
  if (_54 > _55)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  D.8274 = ip6_frag (p, netif, dest);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 32>; [INV]

  <bb 31> :
  _56 = netif->output_ip6;
  D.8274 = _56 (netif, p, dest);

  <bb 32> :
  dest_addr = {CLOBBER};

  <bb 33> :
<L34>:
  return D.8274;

}


ip6_output_if (struct pbuf * p, const struct ip6_addr_t * src, const struct ip6_addr_t * dest, u8_t hl, u8_t tc, u8_t nexth, struct netif * netif)
{
  const struct ip6_addr_t * src_used;
  err_t D.8254;

  <bb 2> :
  src_used = src;
  if (dest != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 3> :
  if (src != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 4> :
  if (src == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _1 = src->addr[0];
  if (_1 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 6> :
  _2 = src->addr[1];
  if (_2 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 7> :
  _3 = src->addr[2];
  if (_3 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  _4 = src->addr[3];
  if (_4 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 9> :
  _5 = ip6_select_source_address (netif, dest);
  src_used = &_5->u_addr.ip6;
  if (src_used == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  if (src_used == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _6 = src_used->addr[0];
  if (_6 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 12> :
  _7 = src_used->addr[1];
  if (_7 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 13> :
  _8 = src_used->addr[2];
  if (_8 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _9 = src_used->addr[3];
  if (_9 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _10 = lwip_stats.ip6.rterr;
  _11 = _10 + 1;
  lwip_stats.ip6.rterr = _11;
  D.8254 = -4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 16> :
  D.8254 = ip6_output_if_src (p, src_used, dest, hl, tc, nexth, netif);

  <bb 17> :
<L17>:
  return D.8254;

}


ip6_input (struct pbuf * p, struct netif * inp)
{
  struct ip6_frag_hdr * frag_hdr;
  struct ip6_rout_hdr * rout_hdr;
  s32_t opt_dlen;
  struct ip6_opt_hdr * opt_hdr;
  struct ip6_dest_hdr * dest_hdr;
  s32_t opt_offset;
  s32_t opt_dlen;
  struct ip6_opt_hdr * opt_hdr;
  struct ip6_hbh_hdr * hbh_hdr;
  s32_t opt_offset;
  raw_input_state_t raw_status;
  u16_t hlen_tot;
  u16_t hlen;
  const u8_t * nexth;
  struct netif * netif;
  struct ip6_hdr * ip6hdr;
  u8_t iftmp.18;
  u8_t iftmp.17;
  err_t D.8122;

  <bb 2> :
  _1 = lwip_stats.ip6.recv;
  _2 = _1 + 1;
  lwip_stats.ip6.recv = _2;
  ip6hdr = p->payload;
  _3 = ip6hdr->_v_tc_fl;
  _4 = lwip_htonl (_3);
  _5 = _4 >> 28;
  _6 = _5 & 15;
  if (_6 != 6)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  pbuf_free (p);
  _7 = lwip_stats.ip6.err;
  _8 = _7 + 1;
  lwip_stats.ip6.err = _8;
  _9 = lwip_stats.ip6.drop;
  _10 = _9 + 1;
  lwip_stats.ip6.drop = _10;
  D.8122 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 153>; [INV]

  <bb 4> :
  _11 = p->len;
  if (_11 <= 39)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _12 = p->tot_len;
  _13 = (int) _12;
  _14 = _13 + -39;
  _15 = ip6hdr->_plen;
  _16 = lwip_htons (_15);
  _17 = (int) _16;
  if (_14 <= _17)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _18 = p->len;

  <bb 7> :
  _19 = ip6hdr->_plen;
  _20 = lwip_htons (_19);
  _21 = (int) _20;
  _22 = _21 + 39;
  _23 = p->tot_len;
  _24 = (int) _23;

  <bb 8> :
  pbuf_free (p);
  _25 = lwip_stats.ip6.lenerr;
  _26 = _25 + 1;
  lwip_stats.ip6.lenerr = _26;
  _27 = lwip_stats.ip6.drop;
  _28 = _27 + 1;
  lwip_stats.ip6.drop = _28;
  D.8122 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 153>; [INV]

  <bb 9> :
  _29 = ip6hdr->_plen;
  _30 = lwip_htons (_29);
  _31 = _30 + 40;
  pbuf_realloc (p, _31);
  _32 = ip6hdr->dest.addr[0];
  ip_data.current_iphdr_dest.u_addr.ip6.addr[0] = _32;
  _33 = ip6hdr->dest.addr[1];
  ip_data.current_iphdr_dest.u_addr.ip6.addr[1] = _33;
  _34 = ip6hdr->dest.addr[2];
  ip_data.current_iphdr_dest.u_addr.ip6.addr[2] = _34;
  _35 = ip6hdr->dest.addr[3];
  ip_data.current_iphdr_dest.u_addr.ip6.addr[3] = _35;
  ip_data.current_iphdr_dest.u_addr.ip6.zone = 0;
  ip_data.current_iphdr_dest.type = 6;
  _36 = ip6hdr->src.addr[0];
  ip_data.current_iphdr_src.u_addr.ip6.addr[0] = _36;
  _37 = ip6hdr->src.addr[1];
  ip_data.current_iphdr_src.u_addr.ip6.addr[1] = _37;
  _38 = ip6hdr->src.addr[2];
  ip_data.current_iphdr_src.u_addr.ip6.addr[2] = _38;
  _39 = ip6hdr->src.addr[3];
  ip_data.current_iphdr_src.u_addr.ip6.addr[3] = _39;
  ip_data.current_iphdr_src.u_addr.ip6.zone = 0;
  ip_data.current_iphdr_src.type = 6;
  _40 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  if (_40 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _41 = ip_data.current_iphdr_dest.u_addr.ip6.addr[1];
  if (_41 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _42 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  if (_42 == 4294901760)
    goto <bb 16>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  _43 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  if (_43 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _44 = ip_data.current_iphdr_src.u_addr.ip6.addr[1];
  if (_44 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _45 = ip_data.current_iphdr_src.u_addr.ip6.addr[2];
  if (_45 == 4294901760)
    goto <bb 16>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  _46 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  _47 = _46 & 255;
  if (_47 == 255)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  pbuf_free (p);
  _48 = lwip_stats.ip6.err;
  _49 = _48 + 1;
  lwip_stats.ip6.err = _49;
  _50 = lwip_stats.ip6.drop;
  _51 = _50 + 1;
  lwip_stats.ip6.drop = _51;
  D.8122 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 153>; [INV]

  <bb 17> :
  _52 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _53 = _52 & 49407;
  if (_53 == 33022)
    goto <bb 20>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  _54 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _55 = _54 & 36863;
  if (_55 == 511)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _56 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _57 = _56 & 36863;
  if (_57 == 767)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _58 = inp->num;
  iftmp.17 = _58 + 1;
  goto <bb 22>; [INV]

  <bb 21> :
  iftmp.17 = 0;

  <bb 22> :
  ip_data.current_iphdr_dest.u_addr.ip6.zone = iftmp.17;
  _59 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  _60 = _59 & 49407;
  if (_60 == 33022)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _61 = inp->num;
  iftmp.18 = _61 + 1;
  goto <bb 25>; [INV]

  <bb 24> :
  iftmp.18 = 0;

  <bb 25> :
  ip_data.current_iphdr_src.u_addr.ip6.zone = iftmp.18;
  ip_data.current_ip6_header = ip6hdr;
  ip_data.current_netif = inp;
  ip_data.current_input_netif = inp;
  _62 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _63 = _62 & 255;
  if (_63 == 255)
    goto <bb 26>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 26> :
  _64 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  if (_64 == 511)
    goto <bb 27>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 27> :
  _65 = ip_data.current_iphdr_dest.u_addr.ip6.addr[1];
  if (_65 == 0)
    goto <bb 28>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 28> :
  _66 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  if (_66 == 0)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _67 = ip_data.current_iphdr_dest.u_addr.ip6.addr[3];
  if (_67 == 16777216)
    goto <bb 34>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 30> :
  _68 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  if (_68 == 767)
    goto <bb 31>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 31> :
  _69 = ip_data.current_iphdr_dest.u_addr.ip6.addr[1];
  if (_69 == 0)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _70 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  if (_70 == 0)
    goto <bb 33>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 33> :
  _71 = ip_data.current_iphdr_dest.u_addr.ip6.addr[3];
  if (_71 == 16777216)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  netif = inp;
  goto <bb 38>; [INV]

  <bb 35> :
  _72 = mld6_lookfor_group (inp, &ip_data.current_iphdr_dest.u_addr.ip6);
  if (_72 != 0B)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  netif = inp;
  goto <bb 38>; [INV]

  <bb 37> :
  netif = 0B;

  <bb 38> :
  goto <bb 61>; [INV]

  <bb 39> :
  _73 = ip6_input_accept (inp);
  if (_73 != 0)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  netif = inp;
  goto <bb 60>; [INV]

  <bb 41> :
  netif = 0B;
  _74 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _75 = _74 & 49407;
  if (_75 == 33022)
    goto <bb 43>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 42> :
  _76 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  _77 = _76 & 49407;
  if (_77 == 33022)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 44> :
  _78 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  if (_78 == 0)
    goto <bb 45>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 45> :
  _79 = ip_data.current_iphdr_dest.u_addr.ip6.addr[1];
  if (_79 == 0)
    goto <bb 46>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 46> :
  _80 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  if (_80 == 0)
    goto <bb 47>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 47> :
  _81 = ip_data.current_iphdr_dest.u_addr.ip6.addr[3];
  if (_81 == 16777216)
    goto <bb 52>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 48> :
  _82 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  if (_82 == 0)
    goto <bb 49>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 49> :
  _83 = ip_data.current_iphdr_src.u_addr.ip6.addr[1];
  if (_83 == 0)
    goto <bb 50>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 50> :
  _84 = ip_data.current_iphdr_src.u_addr.ip6.addr[2];
  if (_84 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 51> :
  _85 = ip_data.current_iphdr_src.u_addr.ip6.addr[3];
  if (_85 == 16777216)
    goto <bb 52>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 52> :
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 53> :
  netif = netif_list;
  goto <bb 59>; [INV]

  <bb 54> :
  if (netif == inp)
    goto <bb 55>; [INV]
  else
    goto <bb 56>; [INV]

  <bb 55> :
  // predicted unlikely by continue predictor.
  goto <bb 58>; [INV]

  <bb 56> :
  _86 = ip6_input_accept (netif);
  if (_86 != 0)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  goto <bb 60>; [INV]

  <bb 58> :
  netif = netif->next;

  <bb 59> :
  if (netif != 0B)
    goto <bb 54>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 60> :
netif_found:

  <bb 61> :
  _87 = ip_data.current_iphdr_src.u_addr.ip6.addr[0];
  if (_87 == 0)
    goto <bb 62>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 62> :
  _88 = ip_data.current_iphdr_src.u_addr.ip6.addr[1];
  if (_88 == 0)
    goto <bb 63>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 63> :
  _89 = ip_data.current_iphdr_src.u_addr.ip6.addr[2];
  if (_89 == 0)
    goto <bb 64>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 64> :
  _90 = ip_data.current_iphdr_src.u_addr.ip6.addr[3];
  if (_90 == 0)
    goto <bb 65>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 65> :
  _91 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  if (_91 != 767)
    goto <bb 68>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 66> :
  _92 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  if (_92 != 16777216)
    goto <bb 68>; [INV]
  else
    goto <bb 67>; [INV]

  <bb 67> :
  _93 = ip_data.current_iphdr_dest.u_addr.ip6.addr[3];
  _94 = _93 & 255;
  if (_94 != 255)
    goto <bb 68>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 68> :
  pbuf_free (p);
  _95 = lwip_stats.ip6.drop;
  _96 = _95 + 1;
  lwip_stats.ip6.drop = _96;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 69> :
  if (netif == 0B)
    goto <bb 70>; [INV]
  else
    goto <bb 71>; [INV]

  <bb 70> :
  pbuf_free (p);
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 71> :
  ip_data.current_netif = netif;
  nexth = &ip6hdr->_nexth;
  hlen_tot = 40;
  hlen = hlen_tot;
  pbuf_remove_header (p, 40);
  goto <bb 139>; [INV]

  <bb 72> :
  _97 = *nexth;
  _98 = (int) _97;
  switch (_98) <default: <L145> [INV], case 0: <L80> [INV], case 43: <L121> [INV], case 44: <L133> [INV], case 60: <L100> [INV]>

  <bb 73> :
<L80>:
  hbh_hdr = p->payload;
  nexth = &hbh_hdr->_nexth;
  _99 = hbh_hdr->_hlen;
  _100 = (int) _99;
  _101 = _100 + 1;
  _102 = (short unsigned int) _101;
  hlen = _102 * 8;
  _103 = p->len;
  if (_103 <= 7)
    goto <bb 75>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 74> :
  _104 = p->len;
  if (hlen > _104)
    goto <bb 75>; [INV]
  else
    goto <bb 76>; [INV]

  <bb 75> :
  pbuf_free (p);
  _105 = lwip_stats.ip6.lenerr;
  _106 = _105 + 1;
  lwip_stats.ip6.lenerr = _106;
  _107 = lwip_stats.ip6.drop;
  _108 = _107 + 1;
  lwip_stats.ip6.drop = _108;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 76> :
  hlen_tot = hlen_tot + hlen;
  opt_offset = 2;
  goto <bb 91>; [INV]

  <bb 77> :
  opt_dlen = 0;
  opt_offset.19_109 = (sizetype) opt_offset;
  opt_hdr = hbh_hdr + opt_offset.19_109;
  _110 = opt_hdr->_opt_type;
  _111 = (int) _110;
  switch (_111) <default: <L89> [INV], case 0: <L85> [INV], case 1: <L86> [INV], case 5: <L87> [INV], case 194: <L88> [INV]>

  <bb 78> :
<L85>:
  opt_dlen = -1;
  goto <bb 90>; [INV]

  <bb 79> :
<L86>:
  _112 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _112;
  goto <bb 90>; [INV]

  <bb 80> :
<L87>:
  _113 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _113;
  goto <bb 90>; [INV]

  <bb 81> :
<L88>:
  _114 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _114;
  goto <bb 90>; [INV]

  <bb 82> :
<L89>:
  _115 = opt_hdr->_opt_type;
  _116 = _115 >> 6;
  _117 = (int) _116;
  _118 = _117 & 3;
  switch (_118) <default: <L95> [INV], case 1: <L90> [INV], case 2: <L91> [INV], case 3: <L92> [INV]>

  <bb 83> :
<L90>:
  pbuf_free (p);
  _119 = lwip_stats.ip6.drop;
  _120 = _119 + 1;
  lwip_stats.ip6.drop = _120;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 84> :
<L91>:
  icmp6_param_problem (p, 2, opt_hdr);
  pbuf_free (p);
  _121 = lwip_stats.ip6.drop;
  _122 = _121 + 1;
  lwip_stats.ip6.drop = _122;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 85> :
<L92>:
  _123 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _124 = _123 & 255;
  if (_124 != 255)
    goto <bb 86>; [INV]
  else
    goto <bb 87>; [INV]

  <bb 86> :
  icmp6_param_problem (p, 2, opt_hdr);

  <bb 87> :
  pbuf_free (p);
  _125 = lwip_stats.ip6.drop;
  _126 = _125 + 1;
  lwip_stats.ip6.drop = _126;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 88> :
<L95>:
  _127 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _127;

  <bb 89> :

  <bb 90> :
  _128 = opt_offset + 2;
  opt_offset = opt_dlen + _128;

  <bb 91> :
  _129 = (long int) hlen;
  if (opt_offset < _129)
    goto <bb 77>; [INV]
  else
    goto <bb 92>; [INV]

  <bb 92> :
  _130 = (unsigned int) hlen;
  pbuf_remove_header (p, _130);
  goto <bb 137>; [INV]

  <bb 93> :
<L100>:
  dest_hdr = p->payload;
  nexth = &dest_hdr->_nexth;
  _131 = dest_hdr->_hlen;
  _132 = (int) _131;
  _133 = _132 + 1;
  _134 = (short unsigned int) _133;
  hlen = _134 * 8;
  _135 = p->len;
  if (_135 <= 7)
    goto <bb 95>; [INV]
  else
    goto <bb 94>; [INV]

  <bb 94> :
  _136 = p->len;
  if (hlen > _136)
    goto <bb 95>; [INV]
  else
    goto <bb 96>; [INV]

  <bb 95> :
  pbuf_free (p);
  _137 = lwip_stats.ip6.lenerr;
  _138 = _137 + 1;
  lwip_stats.ip6.lenerr = _138;
  _139 = lwip_stats.ip6.drop;
  _140 = _139 + 1;
  lwip_stats.ip6.drop = _140;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 96> :
  hlen_tot = hlen_tot + hlen;
  opt_offset = 2;
  goto <bb 112>; [INV]

  <bb 97> :
  opt_dlen = 0;
  opt_offset.20_141 = (sizetype) opt_offset;
  opt_hdr = dest_hdr + opt_offset.20_141;
  _142 = opt_hdr->_opt_type;
  _143 = (int) _142;
  switch (_143) <default: <L110> [INV], case 0: <L105> [INV], case 1: <L106> [INV], case 5: <L107> [INV], case 194: <L108> [INV], case 201: <L109> [INV]>

  <bb 98> :
<L105>:
  opt_dlen = -1;
  goto <bb 111>; [INV]

  <bb 99> :
<L106>:
  _144 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _144;
  goto <bb 111>; [INV]

  <bb 100> :
<L107>:
  _145 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _145;
  goto <bb 111>; [INV]

  <bb 101> :
<L108>:
  _146 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _146;
  goto <bb 111>; [INV]

  <bb 102> :
<L109>:
  _147 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _147;
  goto <bb 111>; [INV]

  <bb 103> :
<L110>:
  _148 = opt_hdr->_opt_type;
  _149 = _148 >> 6;
  _150 = (int) _149;
  _151 = _150 & 3;
  switch (_151) <default: <L116> [INV], case 1: <L111> [INV], case 2: <L112> [INV], case 3: <L113> [INV]>

  <bb 104> :
<L111>:
  pbuf_free (p);
  _152 = lwip_stats.ip6.drop;
  _153 = _152 + 1;
  lwip_stats.ip6.drop = _153;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 105> :
<L112>:
  icmp6_param_problem (p, 2, opt_hdr);
  pbuf_free (p);
  _154 = lwip_stats.ip6.drop;
  _155 = _154 + 1;
  lwip_stats.ip6.drop = _155;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 106> :
<L113>:
  _156 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _157 = _156 & 255;
  if (_157 != 255)
    goto <bb 107>; [INV]
  else
    goto <bb 108>; [INV]

  <bb 107> :
  icmp6_param_problem (p, 2, opt_hdr);

  <bb 108> :
  pbuf_free (p);
  _158 = lwip_stats.ip6.drop;
  _159 = _158 + 1;
  lwip_stats.ip6.drop = _159;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 109> :
<L116>:
  _160 = opt_hdr->_opt_dlen;
  opt_dlen = (s32_t) _160;

  <bb 110> :

  <bb 111> :
  _161 = opt_offset + 2;
  opt_offset = opt_dlen + _161;

  <bb 112> :
  _162 = (long int) hlen;
  if (opt_offset < _162)
    goto <bb 97>; [INV]
  else
    goto <bb 113>; [INV]

  <bb 113> :
  _163 = (unsigned int) hlen;
  pbuf_remove_header (p, _163);
  goto <bb 137>; [INV]

  <bb 114> :
<L121>:
  rout_hdr = p->payload;
  nexth = &rout_hdr->_nexth;
  _164 = rout_hdr->_hlen;
  _165 = (int) _164;
  _166 = _165 + 1;
  _167 = (short unsigned int) _166;
  hlen = _167 * 8;
  _168 = p->len;
  if (_168 <= 7)
    goto <bb 116>; [INV]
  else
    goto <bb 115>; [INV]

  <bb 115> :
  _169 = p->len;
  if (hlen > _169)
    goto <bb 116>; [INV]
  else
    goto <bb 117>; [INV]

  <bb 116> :
  pbuf_free (p);
  _170 = lwip_stats.ip6.lenerr;
  _171 = _170 + 1;
  lwip_stats.ip6.lenerr = _171;
  _172 = lwip_stats.ip6.drop;
  _173 = _172 + 1;
  lwip_stats.ip6.drop = _173;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 117> :
  hlen_tot = hlen_tot + hlen;
  _174 = rout_hdr->_segments_left;
  if (_174 != 0)
    goto <bb 118>; [INV]
  else
    goto <bb 124>; [INV]

  <bb 118> :
  _175 = rout_hdr->_hlen;
  _176 = (int) _175;
  _177 = _176 & 1;
  if (_177 != 0)
    goto <bb 119>; [INV]
  else
    goto <bb 120>; [INV]

  <bb 119> :
  _178 = &rout_hdr->_hlen;
  icmp6_param_problem (p, 0, _178);
  pbuf_free (p);
  _179 = lwip_stats.ip6.drop;
  _180 = _179 + 1;
  lwip_stats.ip6.drop = _180;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 120> :
  _181 = rout_hdr->_routing_type;
  _182 = (int) _181;
  switch (_182) <default: <L130> [INV], case 2: <L128> [INV], case 3: <L129> [INV]>

  <bb 121> :
<L128>:
  goto <bb 124>; [INV]

  <bb 122> :
<L129>:
  goto <bb 124>; [INV]

  <bb 123> :
<L130>:
  _183 = &rout_hdr->_routing_type;
  icmp6_param_problem (p, 0, _183);
  pbuf_free (p);
  _184 = lwip_stats.ip6.drop;
  _185 = _184 + 1;
  lwip_stats.ip6.drop = _185;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 124> :
  _186 = (unsigned int) hlen;
  pbuf_remove_header (p, _186);
  goto <bb 137>; [INV]

  <bb 125> :
<L133>:
  frag_hdr = p->payload;
  nexth = &frag_hdr->_nexth;
  hlen = 8;
  _187 = p->len;
  if (hlen > _187)
    goto <bb 126>; [INV]
  else
    goto <bb 127>; [INV]

  <bb 126> :
  pbuf_free (p);
  _188 = lwip_stats.ip6_frag.lenerr;
  _189 = _188 + 1;
  lwip_stats.ip6_frag.lenerr = _189;
  _190 = lwip_stats.ip6_frag.drop;
  _191 = _190 + 1;
  lwip_stats.ip6_frag.drop = _191;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 127> :
  hlen_tot = hlen_tot + hlen;
  _192 = frag_hdr->_fragment_offset;
  _193 = lwip_htons (_192);
  _194 = (int) _193;
  _195 = _194 & 1;
  if (_195 != 0)
    goto <bb 128>; [INV]
  else
    goto <bb 130>; [INV]

  <bb 128> :
  _196 = ip6hdr->_plen;
  _197 = lwip_htons (_196);
  _198 = (int) _197;
  _199 = _198 & 7;
  if (_199 != 0)
    goto <bb 129>; [INV]
  else
    goto <bb 130>; [INV]

  <bb 129> :
  _200 = &ip6hdr->_plen;
  icmp6_param_problem (p, 0, _200);
  pbuf_free (p);
  _201 = lwip_stats.ip6.drop;
  _202 = _201 + 1;
  lwip_stats.ip6.drop = _202;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 130> :
  _203 = frag_hdr->_fragment_offset;
  _204 = (int) _203;
  _205 = _204 & 63999;
  if (_205 == 0)
    goto <bb 131>; [INV]
  else
    goto <bb 132>; [INV]

  <bb 131> :
  _206 = (unsigned int) hlen;
  pbuf_remove_header (p, _206);
  goto <bb 135>; [INV]

  <bb 132> :
  ip_data.current_ip_header_tot_len = hlen_tot;
  p = ip6_reass (p);
  if (p == 0B)
    goto <bb 133>; [INV]
  else
    goto <bb 134>; [INV]

  <bb 133> :
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 134> :
  ip6hdr = p->payload;
  nexth = &ip6hdr->_nexth;
  hlen_tot = 40;
  hlen = hlen_tot;
  pbuf_remove_header (p, 40);

  <bb 135> :
  goto <bb 137>; [INV]

  <bb 136> :
<L145>:
  // predicted unlikely by goto predictor.
  goto <bb 140>; [INV]

  <bb 137> :
  _207 = *nexth;
  if (_207 == 0)
    goto <bb 138>; [INV]
  else
    goto <bb 139>; [INV]

  <bb 138> :
  icmp6_param_problem (p, 1, nexth);
  pbuf_free (p);
  _208 = lwip_stats.ip6.drop;
  _209 = _208 + 1;
  lwip_stats.ip6.drop = _209;
  // predicted unlikely by goto predictor.
  goto <bb 152>; [INV]

  <bb 139> :
  _210 = *nexth;
  if (_210 != 59)
    goto <bb 72>; [INV]
  else
    goto <bb 140>; [INV]

  <bb 140> :
options_done:
  ip_data.current_ip_header_tot_len = hlen_tot;
  _211 = (unsigned int) hlen_tot;
  pbuf_add_header_force (p, _211);
  raw_status = raw_input (p, inp);
  if (raw_status != 1)
    goto <bb 141>; [INV]
  else
    goto <bb 152>; [INV]

  <bb 141> :
  _212 = (unsigned int) hlen_tot;
  pbuf_remove_header (p, _212);
  _213 = *nexth;
  _214 = (int) _213;
  switch (_214) <default: <L158> [INV], case 6: <L156> [INV], case 17: <L154> [INV], case 58: <L157> [INV], case 59: <L153> [INV], case 136: <L154> [INV]>

  <bb 142> :
<L153>:
  pbuf_free (p);
  goto <bb 152>; [INV]

  <bb 143> :
<L154>:
  udp_input (p, inp);
  goto <bb 152>; [INV]

  <bb 144> :
<L156>:
  tcp_input (p, inp);
  goto <bb 152>; [INV]

  <bb 145> :
<L157>:
  icmp6_input (p, inp);
  goto <bb 152>; [INV]

  <bb 146> :
<L158>:
  if (raw_status == 2)
    goto <bb 151>; [INV]
  else
    goto <bb 147>; [INV]

  <bb 147> :
  _215 = (unsigned int) hlen_tot;
  pbuf_add_header_force (p, _215);
  _216 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _217 = _216 & 255;
  if (_217 != 255)
    goto <bb 148>; [INV]
  else
    goto <bb 150>; [INV]

  <bb 148> :
  _218 = ip6hdr->_nexth;
  if (_218 != 58)
    goto <bb 149>; [INV]
  else
    goto <bb 150>; [INV]

  <bb 149> :
  icmp6_param_problem (p, 1, nexth);

  <bb 150> :
  _219 = lwip_stats.ip6.proterr;
  _220 = _219 + 1;
  lwip_stats.ip6.proterr = _220;
  _221 = lwip_stats.ip6.drop;
  _222 = _221 + 1;
  lwip_stats.ip6.drop = _222;

  <bb 151> :
  pbuf_free (p);

  <bb 152> :
ip6_input_cleanup:
  ip_data.current_netif = 0B;
  ip_data.current_input_netif = 0B;
  ip_data.current_ip6_header = 0B;
  ip_data.current_ip_header_tot_len = 0;
  ip_data.current_iphdr_src.u_addr.ip6.addr[0] = 0;
  ip_data.current_iphdr_src.u_addr.ip6.addr[1] = 0;
  ip_data.current_iphdr_src.u_addr.ip6.addr[2] = 0;
  ip_data.current_iphdr_src.u_addr.ip6.addr[3] = 0;
  ip_data.current_iphdr_src.u_addr.ip6.zone = 0;
  ip_data.current_iphdr_dest.u_addr.ip6.addr[0] = 0;
  ip_data.current_iphdr_dest.u_addr.ip6.addr[1] = 0;
  ip_data.current_iphdr_dest.u_addr.ip6.addr[2] = 0;
  ip_data.current_iphdr_dest.u_addr.ip6.addr[3] = 0;
  ip_data.current_iphdr_dest.u_addr.ip6.zone = 0;
  D.8122 = 0;

  <bb 153> :
<L169>:
  return D.8122;

}


ip6_input_accept (struct netif * netif)
{
  u8_t i;
  int D.8118;

  <bb 2> :
  _1 = netif->flags;
  _2 = (_Bool) _1;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 3> :
  i = 0;
  goto <bb 12>; [INV]

  <bb 4> :
  _3 = (int) i;
  _4 = netif->ip6_addr_state[_3];
  _5 = (int) _4;
  _6 = _5 & 16;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  _7 = ip_data.current_iphdr_dest.u_addr.ip6.addr[0];
  _8 = (int) i;
  _9 = &netif->ip6_addr[_8].u_addr.ip6;
  _10 = MEM[(const struct ip6_addr_t *)_9].addr[0];
  if (_7 == _10)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  _11 = ip_data.current_iphdr_dest.u_addr.ip6.addr[1];
  _12 = (int) i;
  _13 = &netif->ip6_addr[_12].u_addr.ip6;
  _14 = MEM[(const struct ip6_addr_t *)_13].addr[1];
  if (_11 == _14)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  _15 = ip_data.current_iphdr_dest.u_addr.ip6.addr[2];
  _16 = (int) i;
  _17 = &netif->ip6_addr[_16].u_addr.ip6;
  _18 = MEM[(const struct ip6_addr_t *)_17].addr[2];
  if (_15 == _18)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _19 = ip_data.current_iphdr_dest.u_addr.ip6.addr[3];
  _20 = (int) i;
  _21 = &netif->ip6_addr[_20].u_addr.ip6;
  _22 = MEM[(const struct ip6_addr_t *)_21].addr[3];
  if (_19 == _22)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _23 = ip_data.current_iphdr_dest.u_addr.ip6.zone;
  _24 = (int) i;
  _25 = &netif->ip6_addr[_24].u_addr.ip6;
  _26 = MEM[(const struct ip6_addr_t *)_25].zone;
  if (_23 == _26)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.8118 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 11> :
  i.16_27 = i;
  i = i.16_27 + 1;

  <bb 12> :
  if (i <= 2)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  D.8118 = 0;

  <bb 14> :
<L17>:
  return D.8118;

}


ip6_select_source_address (struct netif * netif, const struct ip6_addr_t * dest)
{
  u8_t best_bits;
  u8_t best_pref;
  u8_t cand_bits;
  u8_t cand_pref;
  u8_t i;
  s8_t best_scope;
  s8_t cand_scope;
  s8_t dest_scope;
  const struct ip6_addr_t * cand_addr;
  const struct ip_addr_t * best_addr;
  const struct ip_addr_t * D.8092;
  int iftmp.14;

  <bb 2> :
  best_scope = 0;
  best_pref = 0;
  best_bits = 0;
  _1 = dest->addr[0];
  _2 = _1 & 224;
  if (_2 == 32)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  dest_scope = 14;
  goto <bb 17>; [INV]

  <bb 4> :
  _3 = dest->addr[0];
  _4 = _3 & 49407;
  if (_4 == 33022)
    goto <bb 9>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _5 = dest->addr[0];
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _6 = dest->addr[1];
  if (_6 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _7 = dest->addr[2];
  if (_7 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _8 = dest->addr[3];
  if (_8 == 16777216)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  dest_scope = 2;
  goto <bb 17>; [INV]

  <bb 10> :
  _9 = dest->addr[0];
  _10 = _9 & 254;
  if (_10 == 252)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  dest_scope = 8;
  goto <bb 17>; [INV]

  <bb 12> :
  _11 = dest->addr[0];
  _12 = _11 & 255;
  if (_12 == 255)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _13 = dest->addr[0];
  _14 = lwip_htonl (_13);
  _15 = _14 >> 16;
  _16 = (signed char) _15;
  dest_scope = _16 & 15;
  goto <bb 17>; [INV]

  <bb 14> :
  _17 = dest->addr[0];
  _18 = _17 & 49407;
  if (_18 == 49406)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  dest_scope = 5;
  goto <bb 17>; [INV]

  <bb 16> :
  dest_scope = 14;

  <bb 17> :
  best_addr = 0B;
  i = 0;
  goto <bb 48>; [INV]

  <bb 18> :
  _19 = (int) i;
  _20 = netif->ip6_addr_state[_19];
  _21 = (int) _20;
  _22 = _21 & 16;
  if (_22 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  // predicted unlikely by continue predictor.
  goto <bb 47>; [INV]

  <bb 20> :
  _23 = (int) i;
  cand_addr = &netif->ip6_addr[_23].u_addr.ip6;
  _24 = cand_addr->addr[0];
  _25 = _24 & 224;
  if (_25 == 32)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  cand_scope = 14;
  goto <bb 29>; [INV]

  <bb 22> :
  _26 = cand_addr->addr[0];
  _27 = _26 & 49407;
  if (_27 == 33022)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  cand_scope = 2;
  goto <bb 29>; [INV]

  <bb 24> :
  _28 = cand_addr->addr[0];
  _29 = _28 & 254;
  if (_29 == 252)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  cand_scope = 8;
  goto <bb 29>; [INV]

  <bb 26> :
  _30 = cand_addr->addr[0];
  _31 = _30 & 49407;
  if (_31 == 49406)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  cand_scope = 5;
  goto <bb 29>; [INV]

  <bb 28> :
  cand_scope = 15;

  <bb 29> :
  _32 = (int) i;
  _33 = netif->ip6_addr_state[_32];
  _34 = _33 == 48;
  cand_pref = (u8_t) _34;
  _35 = cand_addr->addr[0];
  _36 = dest->addr[0];
  if (_35 == _36)
    goto <bb 30>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 30> :
  _37 = cand_addr->addr[1];
  _38 = dest->addr[1];
  if (_37 == _38)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  iftmp.14 = 1;
  goto <bb 33>; [INV]

  <bb 32> :
  iftmp.14 = 0;

  <bb 33> :
  cand_bits = (u8_t) iftmp.14;
  if (cand_bits != 0)
    goto <bb 34>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 34> :
  _39 = cand_addr->addr[2];
  _40 = dest->addr[2];
  if (_39 == _40)
    goto <bb 35>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 35> :
  _41 = cand_addr->addr[3];
  _42 = dest->addr[3];
  if (_41 == _42)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _43 = (int) i;
  D.8092 = &netif->ip6_addr[_43];
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 50>; [INV]

  <bb 37> :
  if (best_addr == 0B)
    goto <bb 46>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  if (cand_scope < best_scope)
    goto <bb 39>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 39> :
  if (cand_scope >= dest_scope)
    goto <bb 46>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 40> :
  if (cand_scope > best_scope)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  if (best_scope < dest_scope)
    goto <bb 46>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 42> :
  if (cand_scope == best_scope)
    goto <bb 43>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 43> :
  if (cand_pref > best_pref)
    goto <bb 46>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 44> :
  if (cand_pref == best_pref)
    goto <bb 45>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 45> :
  if (cand_bits > best_bits)
    goto <bb 46>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 46> :
  _44 = (int) i;
  best_addr = &netif->ip6_addr[_44];
  best_scope = cand_scope;
  best_pref = cand_pref;
  best_bits = cand_bits;

  <bb 47> :
  i.15_45 = i;
  i = i.15_45 + 1;

  <bb 48> :
  if (i <= 2)
    goto <bb 18>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 49> :
  D.8092 = best_addr;

  <bb 50> :
<L57>:
  return D.8092;

}


ip6_route (const struct ip6_addr_t * src, const struct ip6_addr_t * dest)
{
  s8_t i;
  struct netif * netif;
  struct netif * D.7964;

  <bb 2> :
  netif_list.0_1 = netif_list;
  if (netif_list.0_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 3> :
  netif_list.1_2 = netif_list;
  _3 = netif_list.1_2->next;
  if (_3 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  netif_list.2_4 = netif_list;
  _5 = netif_list.2_4->flags;
  _6 = (unsigned int) _5;
  _7 = _6 & 1;
  if (_7 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  netif_list.3_8 = netif_list;
  _9 = netif_list.3_8->flags;
  _10 = (unsigned int) _9;
  _11 = _10 & 4;
  if (_11 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _12 = dest->zone;
  if (_12 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _13 = dest->zone;
  netif_list.4_14 = netif_list;
  _15 = netif_list.4_14->num;
  _16 = _15 + 1;
  if (_13 != _16)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.7964 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 9> :
  D.7964 = netif_list;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 10> :
  _17 = dest->zone;
  if (_17 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 11> :
  netif = netif_list;
  goto <bb 17>; [INV]

  <bb 12> :
  _18 = dest->zone;
  _19 = netif->num;
  _20 = _19 + 1;
  if (_18 == _20)
    goto <bb 13>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 13> :
  _21 = netif->flags;
  _22 = (_Bool) _21;
  if (_22 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _23 = netif->flags;
  _24 = (unsigned int) _23;
  _25 = _24 >> 2;
  _26 = (_Bool) _25;
  if (_26 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  D.7964 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 16> :
  netif = netif->next;

  <bb 17> :
  if (netif != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  D.7964 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 19> :
  _27 = dest->addr[0];
  _28 = _27 & 49407;
  if (_28 == 33022)
    goto <bb 27>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  _29 = dest->addr[0];
  _30 = _29 & 36863;
  if (_30 == 511)
    goto <bb 27>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  _31 = dest->addr[0];
  _32 = _31 & 36863;
  if (_32 == 767)
    goto <bb 27>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 22> :
  _33 = src->addr[0];
  _34 = _33 & 49407;
  if (_34 == 33022)
    goto <bb 27>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  _35 = src->addr[0];
  if (_35 == 0)
    goto <bb 24>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 24> :
  _36 = src->addr[1];
  if (_36 == 0)
    goto <bb 25>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 25> :
  _37 = src->addr[2];
  if (_37 == 0)
    goto <bb 26>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 26> :
  _38 = src->addr[3];
  if (_38 == 16777216)
    goto <bb 27>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 27> :
  _39 = src->zone;
  if (_39 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 28> :
  netif = netif_list;
  goto <bb 34>; [INV]

  <bb 29> :
  _40 = netif->flags;
  _41 = (_Bool) _40;
  if (_41 != 0)
    goto <bb 30>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 30> :
  _42 = netif->flags;
  _43 = (unsigned int) _42;
  _44 = _43 >> 2;
  _45 = (_Bool) _44;
  if (_45 != 0)
    goto <bb 31>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 31> :
  _46 = src->zone;
  _47 = netif->num;
  _48 = _47 + 1;
  if (_46 == _48)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  D.7964 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 33> :
  netif = netif->next;

  <bb 34> :
  if (netif != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 35> :
  netif = netif_list;
  goto <bb 49>; [INV]

  <bb 36> :
  _49 = netif->flags;
  _50 = (unsigned int) _49;
  _51 = _50 & 1;
  if (_51 == 0)
    goto <bb 38>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 37> :
  _52 = netif->flags;
  _53 = (unsigned int) _52;
  _54 = _53 & 4;
  if (_54 == 0)
    goto <bb 38>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 38> :
  // predicted unlikely by continue predictor.
  goto <bb 48>; [INV]

  <bb 39> :
  i = 0;
  goto <bb 47>; [INV]

  <bb 40> :
  _55 = (int) i;
  _56 = netif->ip6_addr_state[_55];
  _57 = (int) _56;
  _58 = _57 & 16;
  if (_58 != 0)
    goto <bb 41>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 41> :
  _59 = src->addr[0];
  _60 = (int) i;
  _61 = &netif->ip6_addr[_60].u_addr.ip6;
  _62 = MEM[(const struct ip6_addr_t *)_61].addr[0];
  if (_59 == _62)
    goto <bb 42>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 42> :
  _63 = src->addr[1];
  _64 = (int) i;
  _65 = &netif->ip6_addr[_64].u_addr.ip6;
  _66 = MEM[(const struct ip6_addr_t *)_65].addr[1];
  if (_63 == _66)
    goto <bb 43>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 43> :
  _67 = src->addr[2];
  _68 = (int) i;
  _69 = &netif->ip6_addr[_68].u_addr.ip6;
  _70 = MEM[(const struct ip6_addr_t *)_69].addr[2];
  if (_67 == _70)
    goto <bb 44>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 44> :
  _71 = src->addr[3];
  _72 = (int) i;
  _73 = &netif->ip6_addr[_72].u_addr.ip6;
  _74 = MEM[(const struct ip6_addr_t *)_73].addr[3];
  if (_71 == _74)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  D.7964 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 46> :
  i.5_75 = i;
  i.6_76 = (unsigned char) i.5_75;
  _77 = i.6_76 + 1;
  i = (s8_t) _77;

  <bb 47> :
  if (i <= 2)
    goto <bb 40>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 48> :
  netif = netif->next;

  <bb 49> :
  if (netif != 0B)
    goto <bb 36>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  D.7964 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 51> :
  netif = netif_list;
  goto <bb 68>; [INV]

  <bb 52> :
  _78 = netif->flags;
  _79 = (unsigned int) _78;
  _80 = _79 & 1;
  if (_80 == 0)
    goto <bb 54>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 53> :
  _81 = netif->flags;
  _82 = (unsigned int) _81;
  _83 = _82 & 4;
  if (_83 == 0)
    goto <bb 54>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 54> :
  // predicted unlikely by continue predictor.
  goto <bb 67>; [INV]

  <bb 55> :
  i = 0;
  goto <bb 66>; [INV]

  <bb 56> :
  _84 = (int) i;
  _85 = netif->ip6_addr_state[_84];
  _86 = (int) _85;
  _87 = _86 & 16;
  if (_87 != 0)
    goto <bb 57>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 57> :
  _88 = dest->addr[0];
  _89 = (int) i;
  _90 = &netif->ip6_addr[_89].u_addr.ip6;
  _91 = MEM[(const struct ip6_addr_t *)_90].addr[0];
  if (_88 == _91)
    goto <bb 58>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 58> :
  _92 = dest->addr[1];
  _93 = (int) i;
  _94 = &netif->ip6_addr[_93].u_addr.ip6;
  _95 = MEM[(const struct ip6_addr_t *)_94].addr[1];
  if (_92 == _95)
    goto <bb 59>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 59> :
  _96 = dest->zone;
  _97 = (int) i;
  _98 = &netif->ip6_addr[_97].u_addr.ip6;
  _99 = MEM[(const struct ip6_addr_t *)_98].zone;
  if (_96 == _99)
    goto <bb 60>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 60> :
  if (netif == 0B)
    goto <bb 64>; [INV]
  else
    goto <bb 61>; [INV]

  <bb 61> :
  _100 = (int) i;
  _101 = netif->ip6_addr_valid_life[_100];
  if (_101 == 0)
    goto <bb 64>; [INV]
  else
    goto <bb 62>; [INV]

  <bb 62> :
  _102 = dest->addr[2];
  _103 = (int) i;
  _104 = &netif->ip6_addr[_103].u_addr.ip6;
  _105 = MEM[(const struct ip6_addr_t *)_104].addr[2];
  if (_102 == _105)
    goto <bb 63>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 63> :
  _106 = dest->addr[3];
  _107 = (int) i;
  _108 = &netif->ip6_addr[_107].u_addr.ip6;
  _109 = MEM[(const struct ip6_addr_t *)_108].addr[3];
  if (_106 == _109)
    goto <bb 64>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 64> :
  D.7964 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 65> :
  i.7_110 = i;
  i.8_111 = (unsigned char) i.7_110;
  _112 = i.8_111 + 1;
  i = (s8_t) _112;

  <bb 66> :
  if (i <= 2)
    goto <bb 56>; [INV]
  else
    goto <bb 67>; [INV]

  <bb 67> :
  netif = netif->next;

  <bb 68> :
  if (netif != 0B)
    goto <bb 52>; [INV]
  else
    goto <bb 69>; [INV]

  <bb 69> :
  netif = nd6_find_route (dest);
  if (netif != 0B)
    goto <bb 70>; [INV]
  else
    goto <bb 71>; [INV]

  <bb 70> :
  D.7964 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 71> :
  if (src != 0B)
    goto <bb 72>; [INV]
  else
    goto <bb 92>; [INV]

  <bb 72> :
  _113 = src->addr[0];
  if (_113 != 0)
    goto <bb 76>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 73> :
  _114 = src->addr[1];
  if (_114 != 0)
    goto <bb 76>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 74> :
  _115 = src->addr[2];
  if (_115 != 0)
    goto <bb 76>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 75> :
  _116 = src->addr[3];
  if (_116 != 0)
    goto <bb 76>; [INV]
  else
    goto <bb 92>; [INV]

  <bb 76> :
  netif = netif_list;
  goto <bb 91>; [INV]

  <bb 77> :
  _117 = netif->flags;
  _118 = (unsigned int) _117;
  _119 = _118 & 1;
  if (_119 == 0)
    goto <bb 79>; [INV]
  else
    goto <bb 78>; [INV]

  <bb 78> :
  _120 = netif->flags;
  _121 = (unsigned int) _120;
  _122 = _121 & 4;
  if (_122 == 0)
    goto <bb 79>; [INV]
  else
    goto <bb 80>; [INV]

  <bb 79> :
  // predicted unlikely by continue predictor.
  goto <bb 90>; [INV]

  <bb 80> :
  i = 0;
  goto <bb 89>; [INV]

  <bb 81> :
  _123 = (int) i;
  _124 = netif->ip6_addr_state[_123];
  _125 = (int) _124;
  _126 = _125 & 16;
  if (_126 != 0)
    goto <bb 82>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 82> :
  _127 = src->addr[0];
  _128 = (int) i;
  _129 = &netif->ip6_addr[_128].u_addr.ip6;
  _130 = MEM[(const struct ip6_addr_t *)_129].addr[0];
  if (_127 == _130)
    goto <bb 83>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 83> :
  _131 = src->addr[1];
  _132 = (int) i;
  _133 = &netif->ip6_addr[_132].u_addr.ip6;
  _134 = MEM[(const struct ip6_addr_t *)_133].addr[1];
  if (_131 == _134)
    goto <bb 84>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 84> :
  _135 = src->addr[2];
  _136 = (int) i;
  _137 = &netif->ip6_addr[_136].u_addr.ip6;
  _138 = MEM[(const struct ip6_addr_t *)_137].addr[2];
  if (_135 == _138)
    goto <bb 85>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 85> :
  _139 = src->addr[3];
  _140 = (int) i;
  _141 = &netif->ip6_addr[_140].u_addr.ip6;
  _142 = MEM[(const struct ip6_addr_t *)_141].addr[3];
  if (_139 == _142)
    goto <bb 86>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 86> :
  _143 = src->zone;
  _144 = (int) i;
  _145 = &netif->ip6_addr[_144].u_addr.ip6;
  _146 = MEM[(const struct ip6_addr_t *)_145].zone;
  if (_143 == _146)
    goto <bb 87>; [INV]
  else
    goto <bb 88>; [INV]

  <bb 87> :
  D.7964 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 88> :
  i.9_147 = i;
  i.10_148 = (unsigned char) i.9_147;
  _149 = i.10_148 + 1;
  i = (s8_t) _149;

  <bb 89> :
  if (i <= 2)
    goto <bb 81>; [INV]
  else
    goto <bb 90>; [INV]

  <bb 90> :
  netif = netif->next;

  <bb 91> :
  if (netif != 0B)
    goto <bb 77>; [INV]
  else
    goto <bb 92>; [INV]

  <bb 92> :
  netif_default.11_150 = netif_default;
  if (netif_default.11_150 == 0B)
    goto <bb 95>; [INV]
  else
    goto <bb 93>; [INV]

  <bb 93> :
  netif_default.12_151 = netif_default;
  _152 = netif_default.12_151->flags;
  _153 = (unsigned int) _152;
  _154 = _153 & 1;
  if (_154 == 0)
    goto <bb 95>; [INV]
  else
    goto <bb 94>; [INV]

  <bb 94> :
  netif_default.13_155 = netif_default;
  _156 = netif_default.13_155->flags;
  _157 = (unsigned int) _156;
  _158 = _157 & 4;
  if (_158 == 0)
    goto <bb 95>; [INV]
  else
    goto <bb 96>; [INV]

  <bb 95> :
  D.7964 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 97>; [INV]

  <bb 96> :
  D.7964 = netif_default;

  <bb 97> :
<L118>:
  return D.7964;

}


