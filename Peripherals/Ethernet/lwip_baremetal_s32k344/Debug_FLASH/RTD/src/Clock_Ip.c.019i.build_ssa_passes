Clock_Ip_TimeoutExpired (uint32 * StartTimeInOut, uint32 * ElapsedTimeInOut, uint32 TimeoutTicks)
{
  boolean RetVal;
  boolean D.6824;
  long unsigned int D.6821;

  <bb 2> :
  RetVal = 0;
  D.6821 = OsIf_GetElapsed (StartTimeInOut, 0);
  _1 = *ElapsedTimeInOut;
  _2 = D.6821 + _1;
  *ElapsedTimeInOut = _2;
  _3 = *ElapsedTimeInOut;
  if (TimeoutTicks <= _3)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  RetVal = 1;

  <bb 4> :
  D.6824 = RetVal;

  <bb 5> :
<L2>:
  return D.6824;

}


Clock_Ip_StartTimeout (uint32 * StartTimeOut, uint32 * ElapsedTimeOut, uint32 * TimeoutTicksOut, uint32 TimeoutUs)
{
  <bb 2> :
  _1 = OsIf_GetCounter (0);
  *StartTimeOut = _1;
  *ElapsedTimeOut = 0;
  _2 = OsIf_MicrosToTicks (TimeoutUs, 0);
  *TimeoutTicksOut = _2;
  return;

}


Clock_Ip_ReportClockErrors (Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
  <bb 2> :
  Clock_Ip_pfkNotificationsCallback.25_1 = Clock_Ip_pfkNotificationsCallback;
  Clock_Ip_pfkNotificationsCallback.25_1 (Error, ClockName);
  return;

}


Clock_Ip_EnableSircInStandby ()
{
  <bb 2> :
  Clock_Ip_pxConfig.24_1 = Clock_Ip_pxConfig;
  Clock_Ip_Command (Clock_Ip_pxConfig.24_1, 2);
  EnableSircInStandbyMode ();
  return;

}


Clock_Ip_DisableSircInStandby ()
{
  <bb 2> :
  Clock_Ip_pxConfig.23_1 = Clock_Ip_pxConfig;
  Clock_Ip_Command (Clock_Ip_pxConfig.23_1, 2);
  DisableSircInStandbyMode ();
  return;

}


Clock_Ip_EnableFircInStandby ()
{
  <bb 2> :
  Clock_Ip_pxConfig.22_1 = Clock_Ip_pxConfig;
  Clock_Ip_Command (Clock_Ip_pxConfig.22_1, 2);
  EnableFircInStandbyMode ();
  return;

}


Clock_Ip_DisableFircInStandby ()
{
  <bb 2> :
  Clock_Ip_pxConfig.21_1 = Clock_Ip_pxConfig;
  Clock_Ip_Command (Clock_Ip_pxConfig.21_1, 2);
  DisableFircInStandbyMode ();
  return;

}


Clock_Ip_SetWaitStates ()
{
  <bb 2> :
  Clock_Ip_pfkNotificationsCallback.17_1 = Clock_Ip_pfkNotificationsCallback;
  Clock_Ip_pfkNotificationsCallback.17_1 (4, 140);
  Clock_Ip_SetRamWaitStates ();
  Clock_Ip_pfkNotificationsCallback.18_2 = Clock_Ip_pfkNotificationsCallback;
  Clock_Ip_pfkNotificationsCallback.18_2 (5, 140);
  Clock_Ip_pfkNotificationsCallback.19_3 = Clock_Ip_pfkNotificationsCallback;
  Clock_Ip_pfkNotificationsCallback.19_3 (6, 140);
  Clock_Ip_SetFlashWaitStates ();
  Clock_Ip_pfkNotificationsCallback.20_4 = Clock_Ip_pfkNotificationsCallback;
  Clock_Ip_pfkNotificationsCallback.20_4 (7, 140);
  return;

}


Clock_Ip_GetClockFrequency (Clock_Ip_NameType ClockName)
{
  uint32 D.6819;

  <bb 2> :
  D.6819 = Clock_Ip_GetFreq (ClockName);

  <bb 3> :
<L0>:
  return D.6819;

}


Clock_Ip_EnableModuleClock (Clock_Ip_NameType ClockName)
{
  uint32 CallbackIndex;

  <bb 2> :
  _1 = Clock_Ip_au8ClockFeatures[ClockName][1];
  _2 = (int) _1;
  _3 = Clock_Ip_au8GateCallbackIndex[_2];
  CallbackIndex = (uint32) _3;
  _4 = Clock_Ip_axGateCallbacks[CallbackIndex].Update;
  _4 (ClockName, 0);
  return;

}


Clock_Ip_DisableModuleClock (Clock_Ip_NameType ClockName)
{
  uint32 CallbackIndex;

  <bb 2> :
  _1 = Clock_Ip_au8ClockFeatures[ClockName][1];
  _2 = (int) _1;
  _3 = Clock_Ip_au8GateCallbackIndex[_2];
  CallbackIndex = (uint32) _3;
  _4 = Clock_Ip_axGateCallbacks[CallbackIndex].Update;
  _4 (ClockName, 1);
  return;

}


Clock_Ip_InstallNotificationsCallback (void (*Clock_Ip_NotificationsCallbackType) (Clock_Ip_NotificationType, Clock_Ip_NameType) Callback)
{
  <bb 2> :
  Clock_Ip_pfkNotificationsCallback = Callback;
  return;

}


Clock_Ip_DisableClockMonitor (Clock_Ip_NameType ClockName)
{
  uint32 CallbackIndex;

  <bb 2> :
  _1 = Clock_Ip_au8ClockFeatures[ClockName][1];
  _2 = (int) _1;
  _3 = Clock_Ip_au8CmuCallbackIndex[_2];
  CallbackIndex = (uint32) _3;
  _4 = Clock_Ip_axCmuCallbacks[CallbackIndex].Disable;
  _4 (ClockName);
  return;

}


Clock_Ip_DistributePll ()
{
  uint32 CallbackIndex;
  uint32 Index;

  <bb 2> :
  Clock_Ip_pxConfig.5_1 = Clock_Ip_pxConfig;
  if (Clock_Ip_pxConfig.5_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 3> :
  Index = 0;
  goto <bb 7>; [INV]

  <bb 4> :
  Clock_Ip_pxConfig.6_2 = Clock_Ip_pxConfig;
  _3 = Clock_Ip_pxConfig.6_2->Selectors;
  _4 = (*_3)[Index].Value;
  _5 = Clock_Ip_aeSourceTypeClockName[_4];
  if (_5 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Clock_Ip_pxConfig.7_6 = Clock_Ip_pxConfig;
  _7 = Clock_Ip_pxConfig.7_6->Selectors;
  _8 = (*_7)[Index].Name;
  _9 = Clock_Ip_au8ClockFeatures[_8][1];
  _10 = (int) _9;
  _11 = Clock_Ip_au8SelectorCallbackIndex[_10];
  CallbackIndex = (uint32) _11;
  _12 = Clock_Ip_axSelectorCallbacks[CallbackIndex].Set;
  Clock_Ip_pxConfig.8_13 = Clock_Ip_pxConfig;
  _14 = Clock_Ip_pxConfig.8_13->Selectors;
  _15 = &(*_14)[Index];
  _12 (_15);

  <bb 6> :
  Index = Index + 1;

  <bb 7> :
  Clock_Ip_pxConfig.9_16 = Clock_Ip_pxConfig;
  _17 = Clock_Ip_pxConfig.9_16->SelectorsCount;
  _18 = (long unsigned int) _17;
  if (Index < _18)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _19 = DriverContext.ClockTreeIsConsumingPll;
  if (_19 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 9> :
  Index = 0;
  goto <bb 11>; [INV]

  <bb 10> :
  Clock_Ip_pxConfig.10_20 = Clock_Ip_pxConfig;
  _21 = Clock_Ip_pxConfig.10_20->Gates;
  _22 = (*_21)[Index].Name;
  _23 = Clock_Ip_au8ClockFeatures[_22][1];
  _24 = (int) _23;
  _25 = Clock_Ip_au8GateCallbackIndex[_24];
  CallbackIndex = (uint32) _25;
  _26 = Clock_Ip_axGateCallbacks[CallbackIndex].Set;
  Clock_Ip_pxConfig.11_27 = Clock_Ip_pxConfig;
  _28 = Clock_Ip_pxConfig.11_27->Gates;
  _29 = &(*_28)[Index];
  _26 (_29);
  Index = Index + 1;

  <bb 11> :
  Clock_Ip_pxConfig.12_30 = Clock_Ip_pxConfig;
  _31 = Clock_Ip_pxConfig.12_30->GatesCount;
  _32 = (long unsigned int) _31;
  if (Index < _32)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  Index = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  Clock_Ip_pxConfig.13_33 = Clock_Ip_pxConfig;
  _34 = Clock_Ip_pxConfig.13_33->Cmus;
  _35 = (*_34)[Index].Name;
  _36 = Clock_Ip_au8ClockFeatures[_35][1];
  _37 = (int) _36;
  _38 = Clock_Ip_au8CmuCallbackIndex[_37];
  CallbackIndex = (uint32) _38;
  _39 = Clock_Ip_axCmuCallbacks[CallbackIndex].Enable;
  Clock_Ip_pxConfig.14_40 = Clock_Ip_pxConfig;
  _41 = Clock_Ip_pxConfig.14_40->Cmus;
  _42 = &(*_41)[Index];
  _39 (_42);
  Index = Index + 1;

  <bb 14> :
  Clock_Ip_pxConfig.15_43 = Clock_Ip_pxConfig;
  _44 = Clock_Ip_pxConfig.15_43->CmusCount;
  _45 = (long unsigned int) _44;
  if (Index < _45)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  Clock_Ip_pxConfig.16_46 = Clock_Ip_pxConfig;
  Clock_Ip_Command (Clock_Ip_pxConfig.16_46, 4);

  <bb 16> :
  return;

}


Clock_Ip_GetPllStatus ()
{
  uint32 CallbackIndex;
  uint32 Index;
  Clock_Ip_DfsStatusType DfsStatus;
  Clock_Ip_PllStatusReturnType PllStatus;
  Clock_Ip_PllStatusType RetValue;
  Clock_Ip_PllStatusType D.6811;

  <bb 2> :
  RetValue = 2;
  Index = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  _1 = Clock_Ip_aeHwPllName[Index];
  _2 = Clock_Ip_au8ClockFeatures[_1][1];
  _3 = (int) _2;
  _4 = Clock_Ip_au8PllCallbackIndex[_3];
  CallbackIndex = (uint32) _4;
  _5 = Clock_Ip_axPllCallbacks[CallbackIndex].Complete;
  _6 = Clock_Ip_aeHwPllName[Index];
  PllStatus = _5 (_6);
  if (PllStatus == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  RetValue = 1;
  goto <bb 9>; [INV]

  <bb 5> :
  if (PllStatus == 2)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  RetValue = 0;

  <bb 7> :
  Index = Index + 1;

  <bb 8> :
  _7 = DriverContext.HwPllsNo;
  _8 = (long unsigned int) _7;
  if (Index < _8)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  if (RetValue == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 10> :
  Index = 0;
  goto <bb 14>; [INV]

  <bb 11> :
  _9 = Clock_Ip_aeHwDfsName[Index];
  _10 = Clock_Ip_au8ClockFeatures[_9][1];
  _11 = (int) _10;
  _12 = Clock_Ip_au8FractionalDividerCallbackIndex[_11];
  CallbackIndex = (uint32) _12;
  _13 = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete;
  _14 = Clock_Ip_aeHwDfsName[Index];
  DfsStatus = _13 (_14);
  if (DfsStatus == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  RetValue = 1;
  goto <bb 15>; [INV]

  <bb 13> :
  Index = Index + 1;

  <bb 14> :
  _15 = DriverContext.HwDfsNo;
  _16 = (long unsigned int) _15;
  if (Index < _16)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  D.6811 = RetValue;

  <bb 16> :
<L14>:
  return D.6811;

}


Clock_Ip_InitClock (const struct Clock_Ip_ClockConfigType * Config)
{
  uint32 Index;
  uint32 CallbackIndex;

  <bb 2> :
  Clock_Ip_pxConfig = Config;
  Clock_Ip_Command (Config, 1);
  Clock_Ip_pxConfig.4_1 = Clock_Ip_pxConfig;
  if (Clock_Ip_pxConfig.4_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  Index = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  _2 = Config->Cmus;
  _3 = (*_2)[Index].Name;
  _4 = Clock_Ip_au8ClockFeatures[_3][1];
  _5 = (int) _4;
  _6 = Clock_Ip_au8CmuCallbackIndex[_5];
  CallbackIndex = (uint32) _6;
  _7 = Clock_Ip_axCmuCallbacks[CallbackIndex].Reset;
  _8 = Config->Cmus;
  _9 = &(*_8)[Index];
  _7 (_9);
  Index = Index + 1;

  <bb 5> :
  _10 = Config->CmusCount;
  _11 = (long unsigned int) _10;
  if (Index < _11)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  Clock_Ip_ResetClockConfiguration (Config);
  Index = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _12 = Config->Ircoscs;
  _13 = (*_12)[Index].Name;
  _14 = Clock_Ip_au8ClockFeatures[_13][1];
  _15 = (int) _14;
  _16 = Clock_Ip_au8IrcoscCallbackIndex[_15];
  CallbackIndex = (uint32) _16;
  _17 = Clock_Ip_axIntOscCallbacks[CallbackIndex].Set;
  _18 = Config->Ircoscs;
  _19 = &(*_18)[Index];
  _17 (_19);
  Index = Index + 1;

  <bb 8> :
  _20 = Config->IrcoscsCount;
  _21 = (long unsigned int) _20;
  if (Index < _21)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  Index = 0;
  goto <bb 11>; [INV]

  <bb 10> :
  _22 = Config->Xoscs;
  _23 = (*_22)[Index].Name;
  _24 = Clock_Ip_au8ClockFeatures[_23][1];
  _25 = (int) _24;
  _26 = Clock_Ip_au8XoscCallbackIndex[_25];
  CallbackIndex = (uint32) _26;
  _27 = Clock_Ip_axExtOscCallbacks[CallbackIndex].Set;
  _28 = Config->Xoscs;
  _29 = &(*_28)[Index];
  _27 (_29);
  Index = Index + 1;

  <bb 11> :
  _30 = Config->XoscsCount;
  _31 = (long unsigned int) _30;
  if (Index < _31)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  Clock_Ip_UpdateDriverContext (Config);
  Index = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  _32 = Config->Pcfs;
  _33 = (*_32)[Index].Name;
  _34 = Clock_Ip_au8ClockFeatures[_33][1];
  _35 = (int) _34;
  _36 = Clock_Ip_au8PcfsCallbackIndex[_35];
  CallbackIndex = (uint32) _36;
  _37 = Clock_Ip_axPcfsCallbacks[CallbackIndex].Set;
  _38 = Config->Pcfs;
  _39 = &(*_38)[Index];
  _37 (_39, Index);
  Index = Index + 1;

  <bb 14> :
  _40 = Config->PcfsCount;
  _41 = (long unsigned int) _40;
  if (Index < _41)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  Index = 0;
  goto <bb 17>; [INV]

  <bb 16> :
  _42 = Config->DividerTriggers;
  _43 = (*_42)[Index].Name;
  _44 = Clock_Ip_au8ClockFeatures[_43][1];
  _45 = (int) _44;
  _46 = Clock_Ip_au8DividerTriggerCallbackIndex[_45];
  CallbackIndex = (uint32) _46;
  _47 = Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure;
  _48 = Config->DividerTriggers;
  _49 = &(*_48)[Index];
  _47 (_49);
  Index = Index + 1;

  <bb 17> :
  _50 = Config->DividerTriggersCount;
  _51 = (long unsigned int) _50;
  if (Index < _51)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  Index = 0;
  goto <bb 20>; [INV]

  <bb 19> :
  _52 = Config->Dividers;
  _53 = (*_52)[Index].Name;
  _54 = Clock_Ip_au8ClockFeatures[_53][1];
  _55 = (int) _54;
  _56 = Clock_Ip_au8DividerCallbackIndex[_55];
  CallbackIndex = (uint32) _56;
  _57 = Clock_Ip_axDividerCallbacks[CallbackIndex].Set;
  _58 = Config->Dividers;
  _59 = &(*_58)[Index];
  _57 (_59);
  Index = Index + 1;

  <bb 20> :
  _60 = Config->DividersCount;
  _61 = (long unsigned int) _60;
  if (Index < _61)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  Index = 0;
  goto <bb 23>; [INV]

  <bb 22> :
  _62 = Config->DividerTriggers;
  _63 = (*_62)[Index].Name;
  _64 = Clock_Ip_au8ClockFeatures[_63][1];
  _65 = (int) _64;
  _66 = Clock_Ip_au8DividerTriggerCallbackIndex[_65];
  CallbackIndex = (uint32) _66;
  _67 = Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate;
  _68 = Config->DividerTriggers;
  _69 = &(*_68)[Index];
  _67 (_69);
  Index = Index + 1;

  <bb 23> :
  _70 = Config->DividerTriggersCount;
  _71 = (long unsigned int) _70;
  if (Index < _71)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  Index = 0;
  goto <bb 26>; [INV]

  <bb 25> :
  _72 = Config->Plls;
  _73 = (*_72)[Index].Name;
  _74 = Clock_Ip_au8ClockFeatures[_73][1];
  _75 = (int) _74;
  _76 = Clock_Ip_au8PllCallbackIndex[_75];
  CallbackIndex = (uint32) _76;
  _77 = Clock_Ip_axPllCallbacks[CallbackIndex].Set;
  _78 = Config->Plls;
  _79 = &(*_78)[Index];
  _77 (_79);
  Index = Index + 1;

  <bb 26> :
  _80 = Config->PllsCount;
  _81 = (long unsigned int) _80;
  if (Index < _81)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  Index = 0;
  goto <bb 29>; [INV]

  <bb 28> :
  _82 = Config->Cmus;
  _83 = (*_82)[Index].Name;
  _84 = Clock_Ip_au8ClockFeatures[_83][1];
  _85 = (int) _84;
  _86 = Clock_Ip_au8CmuCallbackIndex[_85];
  CallbackIndex = (uint32) _86;
  _87 = Clock_Ip_axCmuCallbacks[CallbackIndex].Set;
  _88 = Config->Cmus;
  _89 = &(*_88)[Index];
  _87 (_89, Index);
  Index = Index + 1;

  <bb 29> :
  _90 = Config->CmusCount;
  _91 = (long unsigned int) _90;
  if (Index < _91)
    goto <bb 28>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 30> :
  Index = 0;
  goto <bb 32>; [INV]

  <bb 31> :
  _92 = Config->Xoscs;
  _93 = (*_92)[Index].Name;
  _94 = Clock_Ip_au8ClockFeatures[_93][1];
  _95 = (int) _94;
  _96 = Clock_Ip_au8XoscCallbackIndex[_95];
  CallbackIndex = (uint32) _96;
  _97 = Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete;
  _98 = Config->Xoscs;
  _99 = &(*_98)[Index];
  _97 (_99);
  Index = Index + 1;

  <bb 32> :
  _100 = Config->XoscsCount;
  _101 = (long unsigned int) _100;
  if (Index < _101)
    goto <bb 31>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 33> :
  Index = 0;
  goto <bb 35>; [INV]

  <bb 34> :
  _102 = Config->Plls;
  _103 = (*_102)[Index].Name;
  _104 = Clock_Ip_au8ClockFeatures[_103][1];
  _105 = (int) _104;
  _106 = Clock_Ip_au8PllCallbackIndex[_105];
  CallbackIndex = (uint32) _106;
  _107 = Clock_Ip_axPllCallbacks[CallbackIndex].Enable;
  _108 = Config->Plls;
  _109 = &(*_108)[Index];
  _107 (_109);
  Index = Index + 1;

  <bb 35> :
  _110 = Config->PllsCount;
  _111 = (long unsigned int) _110;
  if (Index < _111)
    goto <bb 34>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 36> :
  Index = 0;
  goto <bb 38>; [INV]

  <bb 37> :
  _112 = Config->FracDivs;
  _113 = (*_112)[Index].Name;
  _114 = Clock_Ip_au8ClockFeatures[_113][1];
  _115 = (int) _114;
  _116 = Clock_Ip_au8FractionalDividerCallbackIndex[_115];
  CallbackIndex = (uint32) _116;
  _117 = Clock_Ip_axFracDivCallbacks[CallbackIndex].Set;
  _118 = Config->FracDivs;
  _119 = &(*_118)[Index];
  _117 (_119);
  Index = Index + 1;

  <bb 38> :
  _120 = Config->FracDivsCount;
  _121 = (long unsigned int) _120;
  if (Index < _121)
    goto <bb 37>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 39> :
  DriverContext.ClockTreeIsConsumingPll = 0;
  DriverContext.WaitStatesAreSupported = 0;
  DriverContext.HwPllsNo = 1;
  DriverContext.HwDfsNo = 0;
  Clock_Ip_SetWaitStates ();
  Index = 0;
  goto <bb 44>; [INV]

  <bb 40> :
  _122 = Config->Selectors;
  _123 = (*_122)[Index].Value;
  _124 = Clock_Ip_aeSourceTypeClockName[_123];
  if (_124 != 3)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  _125 = Config->Selectors;
  _126 = (*_125)[Index].Name;
  _127 = Clock_Ip_au8ClockFeatures[_126][1];
  _128 = (int) _127;
  _129 = Clock_Ip_au8SelectorCallbackIndex[_128];
  CallbackIndex = (uint32) _129;
  _130 = Clock_Ip_axSelectorCallbacks[CallbackIndex].Set;
  _131 = Config->Selectors;
  _132 = &(*_131)[Index];
  _130 (_132);
  goto <bb 43>; [INV]

  <bb 42> :
  DriverContext.ClockTreeIsConsumingPll = 1;

  <bb 43> :
  Index = Index + 1;

  <bb 44> :
  _133 = Config->SelectorsCount;
  _134 = (long unsigned int) _133;
  if (Index < _134)
    goto <bb 40>; [INV]
  else
    goto <bb 45>; [INV]

  <bb 45> :
  _135 = DriverContext.ClockTreeIsConsumingPll;
  _136 = ~_135;
  if (_136 != 0)
    goto <bb 46>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 46> :
  Index = 0;
  goto <bb 48>; [INV]

  <bb 47> :
  _137 = Config->Gates;
  _138 = (*_137)[Index].Name;
  _139 = Clock_Ip_au8ClockFeatures[_138][1];
  _140 = (int) _139;
  _141 = Clock_Ip_au8GateCallbackIndex[_140];
  CallbackIndex = (uint32) _141;
  _142 = Clock_Ip_axGateCallbacks[CallbackIndex].Set;
  _143 = Config->Gates;
  _144 = &(*_143)[Index];
  _142 (_144);
  Index = Index + 1;

  <bb 48> :
  _145 = Config->GatesCount;
  _146 = (long unsigned int) _145;
  if (Index < _146)
    goto <bb 47>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 49> :
  Index = 0;
  goto <bb 51>; [INV]

  <bb 50> :
  _147 = Config->Cmus;
  _148 = (*_147)[Index].Name;
  _149 = Clock_Ip_au8ClockFeatures[_148][1];
  _150 = (int) _149;
  _151 = Clock_Ip_au8CmuCallbackIndex[_150];
  CallbackIndex = (uint32) _151;
  _152 = Clock_Ip_axCmuCallbacks[CallbackIndex].Enable;
  _153 = Config->Cmus;
  _154 = &(*_153)[Index];
  _152 (_154);
  Index = Index + 1;

  <bb 51> :
  _155 = Config->CmusCount;
  _156 = (long unsigned int) _155;
  if (Index < _156)
    goto <bb 50>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  Clock_Ip_Command (Config, 4);

  <bb 53> :
  return;

}


Clock_Ip_Init (const struct Clock_Ip_ClockConfigType * Config)
{
  Clock_Ip_PllStatusType PllStatus;
  Clock_Ip_StatusType ClockStatus;
  Clock_Ip_StatusType D.6793;

  <bb 2> :
  ClockStatus = 1;
  Clock_Ip_InitClock (Config);
  _1 = DriverContext.ClockTreeIsConsumingPll;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  PllStatus = Clock_Ip_GetPllStatus ();
  if (PllStatus == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  Clock_Ip_DistributePll ();
  ClockStatus = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  ClockStatus = 0;

  <bb 6> :
  D.6793 = ClockStatus;

  <bb 7> :
<L5>:
  return D.6793;

}


Clock_Ip_ResetClockConfiguration (const struct Clock_Ip_ClockConfigType * Config)
{
  uint32 Index;
  uint32 CallbackIndex;

  <bb 2> :
  _1 = Config->SelectorsCount;
  Index = (uint32) _1;
  goto <bb 4>; [INV]

  <bb 3> :
  _2 = Config->Selectors;
  _3 = Index + 4294967295;
  _4 = (*_2)[_3].Name;
  _5 = Clock_Ip_au8ClockFeatures[_4][1];
  _6 = (int) _5;
  _7 = Clock_Ip_au8SelectorCallbackIndex[_6];
  CallbackIndex = (uint32) _7;
  _8 = Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset;
  _9 = Config->Selectors;
  _10 = Index + 4294967295;
  _11 = &(*_9)[_10];
  _8 (_11);
  Index = Index + 4294967295;

  <bb 4> :
  if (Index != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _12 = Config->FracDivsCount;
  Index = (uint32) _12;
  goto <bb 7>; [INV]

  <bb 6> :
  _13 = Config->FracDivs;
  _14 = Index + 4294967295;
  _15 = (*_13)[_14].Name;
  _16 = Clock_Ip_au8ClockFeatures[_15][1];
  _17 = (int) _16;
  _18 = Clock_Ip_au8FractionalDividerCallbackIndex[_17];
  CallbackIndex = (uint32) _18;
  _19 = Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset;
  _20 = Config->FracDivs;
  _21 = Index + 4294967295;
  _22 = &(*_20)[_21];
  _19 (_22);
  Index = Index + 4294967295;

  <bb 7> :
  if (Index != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _23 = Config->PllsCount;
  Index = (uint32) _23;
  goto <bb 10>; [INV]

  <bb 9> :
  _24 = Config->Plls;
  _25 = Index + 4294967295;
  _26 = (*_24)[_25].Name;
  _27 = Clock_Ip_au8ClockFeatures[_26][1];
  _28 = (int) _27;
  _29 = Clock_Ip_au8PllCallbackIndex[_28];
  CallbackIndex = (uint32) _29;
  _30 = Clock_Ip_axPllCallbacks[CallbackIndex].Reset;
  _31 = Config->Plls;
  _32 = Index + 4294967295;
  _33 = &(*_31)[_32];
  _30 (_33);
  Index = Index + 4294967295;

  <bb 10> :
  if (Index != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _34 = Config->XoscsCount;
  Index = (uint32) _34;
  goto <bb 13>; [INV]

  <bb 12> :
  _35 = Config->Xoscs;
  _36 = Index + 4294967295;
  _37 = (*_35)[_36].Name;
  _38 = Clock_Ip_au8ClockFeatures[_37][1];
  _39 = (int) _38;
  _40 = Clock_Ip_au8XoscCallbackIndex[_39];
  CallbackIndex = (uint32) _40;
  _41 = Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset;
  _42 = Config->Xoscs;
  _43 = Index + 4294967295;
  _44 = &(*_42)[_43];
  _41 (_44);
  Index = Index + 4294967295;

  <bb 13> :
  if (Index != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  return;

}


Clock_Ip_CallEmptyCallbacks ()
{
  <bb 2> :
  FunctionWasCalled.3_1 = FunctionWasCalled;
  _2 = ~FunctionWasCalled.3_1;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FunctionWasCalled = 1;
  _3 = Clock_Ip_axCmuCallbacks[0].Set;
  _3 (0B, 0);
  _4 = Clock_Ip_axCmuCallbacks[0].Disable;
  _4 (140);
  _5 = Clock_Ip_axDividerCallbacks[0].Set;
  _5 (0B);
  _6 = Clock_Ip_axDividerTriggerCallbacks[0].Configure;
  _6 (0B);
  _7 = Clock_Ip_axExtOscCallbacks[0].Reset;
  _7 (0B);
  _8 = Clock_Ip_axFracDivCallbacks[0].Set;
  _8 (0B);
  _9 = Clock_Ip_axFracDivCallbacks[0].Complete;
  _9 (0);
  _10 = Clock_Ip_axGateCallbacks[0].Set;
  _10 (0B);
  _11 = Clock_Ip_axGateCallbacks[0].Update;
  _11 (140, 0);
  _12 = Clock_Ip_axIntOscCallbacks[0].Set;
  _12 (0B);
  _13 = Clock_Ip_axPllCallbacks[0].Set;
  _13 (0B);
  _14 = Clock_Ip_axPllCallbacks[0].Complete;
  _14 (0);
  _15 = Clock_Ip_axSelectorCallbacks[0].Set;
  _15 (0B);
  _16 = Clock_Ip_axPcfsCallbacks[0].Set;
  _16 (0B, 0);

  <bb 4> :
  return;

}


Clock_Ip_UpdateDriverContext (const struct Clock_Ip_ClockConfigType * Config)
{
  uint8 Index;

  <bb 2> :
  Clock_Ip_pxConfig.0_1 = Clock_Ip_pxConfig;
  Clock_Ip_Command (Clock_Ip_pxConfig.0_1, 2);
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _2 = Config->ExtClks;
  _3 = (int) Index;
  _4 = (*_2)[_3].Name;
  _5 = Config->ExtClks;
  _6 = (int) Index;
  _7 = (*_5)[_6].Value;
  Clock_Ip_SetExternalSignalFrequency (_4, _7);
  Index.1_8 = Index;
  Index = Index.1_8 + 1;

  <bb 4> :
  _9 = Config->ExtClksCount;
  if (Index < _9)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  Clock_Ip_CallEmptyCallbacks ();
  Index = 1;
  goto <bb 7>; [INV]

  <bb 6> :
  _10 = Config->ConfiguredFrequencies;
  _11 = (int) Index;
  _12 = (*_10)[_11].Name;
  Clock_Ip_FreqIds[_12] = Index;
  Index.2_13 = Index;
  Index = Index.2_13 + 1;

  <bb 7> :
  _14 = Config->ConfigureFrequenciesCount;
  if (Index < _14)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  return;

}


Clock_Ip_NotificatonsEmptyCallback (Clock_Ip_NotificationType Notification, Clock_Ip_NameType ClockName)
{
  <bb 2> :
  return;

}


