
Marking local functions: FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_ProcessSpuriousInterruptMB/65 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_SetRegDefaultVal/48 FlexCAN_GetEnhancedRxFIFOIntStatusFlag/47 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 FlexCAN_SetEnhancedRxFifoIntAll/44 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_SetRxMaskType/42 FlexCAN_SetTxArbitrationStartDelay/41 FlexCAN_IsFreezeMode/40 FlexCAN_SetRxIndividualMask/39 FlexCAN_SetRxMsgBuffGlobalMask/38 FlexCAN_GetMsgBuffIntStatusFlag/37 RxFifoOcuppiedLastMsgBuff/29 FlexCAN_IsListenOnlyModeEnabled/28 FlexCAN_IsFDEnabled/27 FlexCAN_SetSelfReception/26 FlexCAN_EnableExtCbt/25 FlexCAN_EnhCbtEnable/24 FlexCAN_IsEnhCbtEnabled/23 FlexCAN_IsExCbtEnabled/22 FlexCAN_GetFDTimeSegments/21 FlexCAN_GetTimeSegments/20 FlexCAN_GetExtendedTimeSegments/19 FlexCAN_GetEnhancedDataTimeSegments/18 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_GetEnhancedNominalTimeSegments/16 FlexCAN_SetEnhancedNominalTimeSegments/15 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_SetTimeSegments/13 FlexCAN_SetFDTimeSegments/12 FlexCAN_GetBuffStatusImask/11 FlexCAN_GetBuffStatusFlag/10 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_SetListenOnlyMode/7 FlexCAN_SetFDEnabled/6 FlexCAN_DisableMemErrorDetection/5 FlexCAN_IsEnabled/4 FlexCAN_SetEnhancedTDCOffset/3 FlexCAN_SetTDCOffset/2 FlexCAN_SetRxFifoGlobalMask/1 DevAssert/0


Marking externally visible functions: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_GetListenOnlyMode/121 FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_AbortTransfer/117 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_GetTDCValue/107 FlexCAN_Ip_GetTDCFail/106 FlexCAN_Ip_ClearTDCFail/105 FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_SetStartMode_Privileged/100 FlexCAN_Ip_GetStartMode_Privileged/99 FlexCAN_Ip_GetStopMode_Privileged/98 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionBusOff_Privileged/96 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_ExitFreezeMode_Privileged/91 FlexCAN_Ip_EnterFreezeMode_Privileged/90 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_SendBlocking/88 FlexCAN_Busoff_Error_IRQHandler/87 FlexCAN_Ip_GetControllerRxErrorCounter/86 FlexCAN_Ip_GetControllerTxErrorCounter/85 FlexCAN_Ip_GetErrorStatus/84 FlexCAN_Ip_ClearErrorStatus/83 FlexCAN_IRQHandler/82 FlexCAN_Ip_GetTransferStatus/80 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_Send/71 FlexCAN_Ip_Init_Privileged/70


Marking externally visible variables:


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20/174 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20) @07f98700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20/173 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20) @07f98620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10/172 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10) @07f982a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10/171 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10) @07f981c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 
  Calls: 
FlexCAN_SetErrIntCmd/170 (FlexCAN_SetErrIntCmd) @07f83d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 
  Calls: 
FlexCAN_DisableInterrupts/169 (FlexCAN_DisableInterrupts) @07f83a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 
  Calls: 
FlexCAN_EnableInterrupts/168 (FlexCAN_EnableInterrupts) @07f838c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_EnableInterrupts_Privileged/114 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17/167 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17) @07f83460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17/166 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17) @07f83380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16/165 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16) @07f83000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16/164 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16) @07f71ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15/163 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15) @07f719a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15/162 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15) @07f718c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09/161 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09) @07f71540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ClearTDCFail/105 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09/160 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09) @07f71460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ClearTDCFail/105 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14/159 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14) @07f5ec40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14/158 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14) @07f5eb60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08/157 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08) @07f5e8c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/102 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08/156 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08) @07f5e7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/102 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07/155 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07) @07f5e540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/100 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07/154 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07) @07f5e460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/100 
  Calls: 
FlexCAN_GetMaxMbNum/153 (FlexCAN_GetMaxMbNum) @07f46d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_SetRegDefaultVal/48 FlexCAN_SetRegDefaultVal/48 
  Calls: 
FlexCAN_ExitFreezeMode/152 (FlexCAN_ExitFreezeMode) @07f46700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/100 FlexCAN_Ip_ExitFreezeMode_Privileged/91 
  Calls: 
FlexCAN_SetEnhancedRxFifoFilter/151 (FlexCAN_SetEnhancedRxFifoFilter) @07f260e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 
  Calls: 
FlexCAN_SetRxFifoFilter/150 (FlexCAN_SetRxFifoFilter) @07f10e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRxFifo_Privileged/77 
  Calls: 
FlexCAN_Enable/149 (FlexCAN_Enable) @07f10d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 
  Calls: 
FlexCAN_SetRxMsgBuff/148 (FlexCAN_SetRxMsgBuff) @07f10620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_ConfigRxMb/72 
  Calls: 
FlexCAN_SetOperationMode/147 (FlexCAN_SetOperationMode) @07f102a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_Init_Privileged/70 
  Calls: 
FLEXCAN_ClearMsgBuffIntCmd/146 (FLEXCAN_ClearMsgBuffIntCmd) @07f10000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_AbortTransfer/117 FlexCAN_AbortRxTransfer/69 
  Calls: 
FlexCAN_ReadEnhancedRxFifo/145 (FlexCAN_ReadEnhancedRxFifo) @07e3dc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerEnhancedRxFIFO/67 
  Calls: 
FlexCAN_GetMsgBuffTimestamp/144 (FlexCAN_GetMsgBuffTimestamp) @07e3da80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 
  Calls: 
FlexCAN_GetMsgBuff/143 (FlexCAN_GetMsgBuff) @07e3d7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 
  Calls: 
FlexCAN_LockRxMsgBuff/142 (FlexCAN_LockRxMsgBuff) @07e3d700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 
  Calls: 
FlexCAN_SetTxMsgBuff/141 (FlexCAN_SetTxMsgBuff) @07e3d460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_StartSendData/60 
  Calls: 
FlexCAN_GetMsgBuffRegion/140 (FlexCAN_GetMsgBuffRegion) @07e3d380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_AbortRxTransfer/69 FlexCAN_AbortRxTransfer/69 FlexCAN_AbortTxTransfer/68 FlexCAN_StartSendData/60 
  Calls: 
FlexCAN_GetMbPayloadSize/139 (FlexCAN_GetMbPayloadSize) @07e3d2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_StartSendData/60 
  Calls: 
FlexCAN_IsMbOutOfRange/138 (FlexCAN_IsMbOutOfRange) @07e3d0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_StartSendData/60 FlexCAN_StartRxMessageBufferData/59 
  Calls: 
FlexCAN_ReadRxFifo/137 (FlexCAN_ReadRxFifo) @07e2be00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerRxFIFO/64 
  Calls: 
FlexCAN_SetMsgBuffIntCmd/136 (FlexCAN_SetMsgBuffIntCmd) @07e2bb60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 FlexCAN_Ip_Send/71 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 FlexCAN_IRQHandlerRxMB/62 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageFifoData/61 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessLegacyRxFIFO/58 
  Calls: 
OsIf_GetElapsed/135 (OsIf_GetElapsed) @07e2b7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
OsIf_GetCounter/134 (OsIf_GetCounter) @07e2b700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
OsIf_MicrosToTicks/133 (OsIf_MicrosToTicks) @07e2b620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
FlexCAN_IsEnhancedRxFifoAvailable/132 (FlexCAN_IsEnhancedRxFifoAvailable) @07e2b1c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_SetRegDefaultVal/48 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 FlexCAN_CompleteRxMessageEnhancedFifoData/55 
  Calls: 
FlexCAN_ResetImaskBuff/131 (FlexCAN_ResetImaskBuff) @06635620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_ConfigCtrlOptions/130 (FlexCAN_ConfigCtrlOptions) @06635540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_Init/129 (FlexCAN_Init) @06635460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_SetMaxMsgBuffNum/128 (FlexCAN_SetMaxMsgBuffNum) @066351c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_SetPayloadSize/127 (FlexCAN_SetPayloadSize) @066350e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_Disable/126 (FlexCAN_Disable) @06635000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_InitController/53 FlexCAN_InitController/53 FlexCAN_InitCtroll/52 FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_EnterFreezeMode/125 (FlexCAN_EnterFreezeMode) @07dfba80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_EnterFreezeMode_Privileged/90 FlexCAN_InitController/53 FlexCAN_InitController/53 FlexCAN_InitCtroll/52 FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_EnableEnhancedRxFifo/124 (FlexCAN_EnableEnhancedRxFifo) @07dfb540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitRxFifo/51 
  Calls: 
FlexCAN_EnableRxFifo/123 (FlexCAN_EnableRxFifo) @07dfb2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitRxFifo/51 
  Calls: 
FlexCAN_Ip_ManualBusOffRecovery/122 (FlexCAN_Ip_ManualBusOffRecovery) @07dfbc40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: OsIf_GetElapsed/135 OsIf_GetCounter/134 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20/174 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20/173 DevAssert/0 OsIf_MicrosToTicks/133 
FlexCAN_Ip_GetListenOnlyMode/121 (FlexCAN_Ip_GetListenOnlyMode) @07dfb9a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsListenOnlyModeEnabled/28 
FlexCAN_Ip_SetListenOnlyMode_Privileged/120 (FlexCAN_Ip_SetListenOnlyMode_Privileged) @07dfb700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10/172 FlexCAN_SetListenOnlyMode/7 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10/171 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetRxMb15Mask_Privileged/119 (FlexCAN_Ip_SetRxMb15Mask_Privileged) @07dfb460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetRxMb14Mask_Privileged/118 (FlexCAN_Ip_SetRxMb14Mask_Privileged) @07dfb1c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_AbortTransfer/117 (FlexCAN_Ip_AbortTransfer) @07d6bd20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_AbortRxTransfer/69 FlexCAN_AbortTxTransfer/68 FLEXCAN_ClearMsgBuffIntCmd/146 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetErrorInt_Privileged/116 (FlexCAN_Ip_SetErrorInt_Privileged) @07d6b7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 DevAssert/0 FlexCAN_SetErrIntCmd/170 FlexCAN_IsFreezeMode/40 FlexCAN_SetErrIntCmd/170 FlexCAN_IsFreezeMode/40 FlexCAN_SetErrIntCmd/170 FlexCAN_SetErrIntCmd/170 FlexCAN_SetErrIntCmd/170 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_DisableInterrupts_Privileged/115 (FlexCAN_Ip_DisableInterrupts_Privileged) @07d6b2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 FlexCAN_DisableInterrupts/169 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_EnableInterrupts_Privileged/114 (FlexCAN_Ip_EnableInterrupts_Privileged) @07d6bee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 FlexCAN_EnableInterrupts/168 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_ClearBuffStatusFlag/113 (FlexCAN_Ip_ClearBuffStatusFlag) @07d6bc40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 DevAssert/0 
FlexCAN_Ip_GetBuffStatusFlag/112 (FlexCAN_Ip_GetBuffStatusFlag) @07d6b9a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetBuffStatusFlag/10 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 DevAssert/0 
FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 (FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged) @07d6b700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17/167 FlexCAN_SetTxArbitrationStartDelay/41 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17/166 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetTDCOffset_Privileged/110 (FlexCAN_Ip_SetTDCOffset_Privileged) @07d6b460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16/165 FlexCAN_SetTDCOffset/2 FlexCAN_SetEnhancedTDCOffset/3 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16/164 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_GetBitrateFD/109 (FlexCAN_Ip_GetBitrateFD) @07d6b1c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetFDTimeSegments/21 FlexCAN_GetEnhancedDataTimeSegments/18 FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetBitrateCbt_Privileged/108 (FlexCAN_Ip_SetBitrateCbt_Privileged) @07d62d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15/163 FlexCAN_SetFDTimeSegments/12 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_SetFDEnabled/6 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15/162 FlexCAN_IsEnhCbtEnabled/23 FlexCAN_Enable/149 FlexCAN_IsFDEnabled/27 DevAssert/0 DevAssert/0 
FlexCAN_Ip_GetTDCValue/107 (FlexCAN_Ip_GetTDCValue) @07d627e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 
FlexCAN_Ip_GetTDCFail/106 (FlexCAN_Ip_GetTDCFail) @07d622a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 
FlexCAN_Ip_ClearTDCFail/105 (FlexCAN_Ip_ClearTDCFail) @07d62ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09/161 FlexCAN_IsEnhCbtEnabled/23 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09/160 DevAssert/0 
FlexCAN_Ip_GetBitrate/104 (FlexCAN_Ip_GetBitrate) @07d62c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetTimeSegments/20 FlexCAN_GetExtendedTimeSegments/19 FlexCAN_IsExCbtEnabled/22 FlexCAN_GetEnhancedNominalTimeSegments/16 FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetBitrate_Privileged/103 (FlexCAN_Ip_SetBitrate_Privileged) @07d629a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14/159 FlexCAN_SetTimeSegments/13 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_IsExCbtEnabled/22 FlexCAN_SetEnhancedNominalTimeSegments/15 FlexCAN_EnhCbtEnable/24 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14/158 FlexCAN_Enable/149 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetRxMaskType_Privileged/102 (FlexCAN_Ip_SetRxMaskType_Privileged) @07d62700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08/157 FlexCAN_SetRxMaskType/42 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08/156 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetStopMode_Privileged/101 (FlexCAN_Ip_SetStopMode_Privileged) @07d62460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 DevAssert/0 
FlexCAN_Ip_SetStartMode_Privileged/100 (FlexCAN_Ip_SetStartMode_Privileged) @07d621c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ExitFreezeMode/152 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07/155 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07/154 DevAssert/0 
FlexCAN_Ip_GetStartMode_Privileged/99 (FlexCAN_Ip_GetStartMode_Privileged) @07d57d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
FlexCAN_Ip_GetStopMode_Privileged/98 (FlexCAN_Ip_GetStopMode_Privileged) @07d577e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
FlexCAN_Ip_MainFunctionWrite/97 (FlexCAN_Ip_MainFunctionWrite) @07d572a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuffTimestamp/144 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuff/143 FlexCAN_LockRxMsgBuff/142 FlexCAN_GetBuffStatusFlag/10 DevAssert/0 
   Indirect call Num speculative call targets: 0
FlexCAN_Ip_MainFunctionBusOff_Privileged/96 (FlexCAN_Ip_MainFunctionBusOff_Privileged) @07d57ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call Num speculative call targets: 0
FlexCAN_Ip_MainFunctionRead/95 (FlexCAN_Ip_MainFunctionRead) @07d57c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IRQHandlerRxMB/62 FlexCAN_GetBuffStatusFlag/10 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_GetBuffStatusFlag/10 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Deinit_Privileged/94 (FlexCAN_Ip_Deinit_Privileged) @07d579a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRegDefaultVal/48 FlexCAN_EnterFreezeMode/125 DevAssert/0 
FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 (FlexCAN_Ip_SetRxFifoGlobalMask_Privileged) @07d57700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxFifoGlobalMask/1 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetRxIndividualMask_Privileged/92 (FlexCAN_Ip_SetRxIndividualMask_Privileged) @07d57460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxIndividualMask/39 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_ExitFreezeMode_Privileged/91 (FlexCAN_Ip_ExitFreezeMode_Privileged) @07d571c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ExitFreezeMode/152 
FlexCAN_Ip_EnterFreezeMode_Privileged/90 (FlexCAN_Ip_EnterFreezeMode_Privileged) @07d45d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_EnterFreezeMode/125 
FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 (FlexCAN_Ip_SetRxMbGlobalMask_Privileged) @07d457e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxMsgBuffGlobalMask/38 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SendBlocking/88 (FlexCAN_Ip_SendBlocking) @07d452a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusFlag/10 OsIf_GetElapsed/135 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 FlexCAN_GetMsgBuffRegion/140 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusFlag/10 OsIf_GetElapsed/135 OsIf_GetCounter/134 FlexCAN_StartSendData/60 DevAssert/0 DevAssert/0 OsIf_MicrosToTicks/133 
FlexCAN_Busoff_Error_IRQHandler/87 (FlexCAN_Busoff_Error_IRQHandler) @07d45ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
FlexCAN_Ip_GetControllerRxErrorCounter/86 (FlexCAN_Ip_GetControllerRxErrorCounter) @07d45c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetControllerTxErrorCounter/85 (FlexCAN_Ip_GetControllerTxErrorCounter) @07d459a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetErrorStatus/84 (FlexCAN_Ip_GetErrorStatus) @07d45700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_ClearErrorStatus/83 (FlexCAN_Ip_ClearErrorStatus) @07d45460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_IRQHandler/82 (FlexCAN_IRQHandler) @07d451c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ProcessSpuriousInterruptMB/65 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetMsgBuffIntStatusFlag/37 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_GetMsgBuffIntStatusFlag/37 FlexCAN_GetMsgBuffIntStatusFlag/37 DevAssert/0 DevAssert/0 
FlexCAN_CompleteRxMessageFifoData/81 (FlexCAN_CompleteRxMessageFifoData) @07ef4d20
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandlerRxFIFO/64 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 DevAssert/0 
FlexCAN_Ip_GetTransferStatus/80 (FlexCAN_Ip_GetTransferStatus) @07ef47e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 DevAssert/0 
FlexCAN_Ip_ConfigRemoteResponseMb/79 (FlexCAN_Ip_ConfigRemoteResponseMb) @07ef42a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetTxMsgBuff/141 FlexCAN_GetMsgBuffRegion/140 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_IsMbOutOfRange/138 DevAssert/0 FlexCAN_GetMbPayloadSize/139 DevAssert/0 DevAssert/0 DevAssert/0 
FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 (FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged) @07ef4ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetEnhancedRxFifoFilter/151 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 DevAssert/0 DevAssert/0 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 FlexCAN_IsEnabled/4 
FlexCAN_Ip_ConfigRxFifo_Privileged/77 (FlexCAN_Ip_ConfigRxFifo_Privileged) @07ef4c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxFifoFilter/150 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_RxFifoBlocking/76 (FlexCAN_Ip_RxFifoBlocking) @07ef49a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_StartRxMessageFifoData/61 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_StartRxMessageFifoData/61 FlexCAN_ProccessEnhancedRxFifo/57 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 
FlexCAN_Ip_RxFifo/75 (FlexCAN_Ip_RxFifo) @07ef4700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 
FlexCAN_Ip_ReceiveBlocking/74 (FlexCAN_Ip_ReceiveBlocking) @07ef4460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 OsIf_GetElapsed/135 FlexCAN_IRQHandlerRxMB/62 FlexCAN_GetBuffStatusFlag/10 OsIf_GetCounter/134 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_StartRxMessageBufferData/59 DevAssert/0 OsIf_MicrosToTicks/133 
FlexCAN_Ip_Receive/73 (FlexCAN_Ip_Receive) @07ef41c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_StartRxMessageBufferData/59 DevAssert/0 
FlexCAN_Ip_ConfigRxMb/72 (FlexCAN_Ip_ConfigRxMb) @07edfd20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetRxMsgBuff/148 FlexCAN_SetRxMsgBuff/148 FlexCAN_SetRxMsgBuff/148 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_IsMbOutOfRange/138 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Send/71 (FlexCAN_Ip_Send) @07edf7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_StartSendData/60 FlexCAN_IsListenOnlyModeEnabled/28 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Init_Privileged/70 (FlexCAN_Ip_Init_Privileged) @07edf2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetOperationMode/147 FlexCAN_InitBaudrate/54 FlexCAN_InitController/53 DevAssert/0 DevAssert/0 
FlexCAN_AbortRxTransfer/69 (FlexCAN_AbortRxTransfer) @07edfee0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_AbortTransfer/117 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetMsgBuffRegion/140 FLEXCAN_ClearMsgBuffIntCmd/146 FlexCAN_GetMsgBuffRegion/140 RxFifoOcuppiedLastMsgBuff/29 
FlexCAN_AbortTxTransfer/68 (FlexCAN_AbortTxTransfer) @07edfc40
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_AbortTransfer/117 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusFlag/10 OsIf_GetElapsed/135 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 FlexCAN_GetMsgBuffRegion/140 
FlexCAN_IRQHandlerEnhancedRxFIFO/67 (FlexCAN_IRQHandlerEnhancedRxFIFO) @07edf9a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_MainFunctionRead/95 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ReadEnhancedRxFifo/145 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 (FlexCAN_ProcessIRQHandlerEnhancedRxFIFO) @07edf700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/82 
  Calls: FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_GetEnhancedRxFIFOIntStatusFlag/47 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 
FlexCAN_ProcessSpuriousInterruptMB/65 (FlexCAN_ProcessSpuriousInterruptMB) @07edf460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/82 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusImask/11 FlexCAN_GetBuffStatusFlag/10 
FlexCAN_IRQHandlerRxFIFO/64 (FlexCAN_IRQHandlerRxFIFO) @07edf1c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_MainFunctionRead/95 FlexCAN_IRQHandler/82 FlexCAN_ProccessLegacyRxFIFO/58 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ReadRxFifo/137 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
FlexCAN_IRQHandlerTxMB/63 (FlexCAN_IRQHandlerTxMB) @07ecdd20
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandler/82 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuffTimestamp/144 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuff/143 FlexCAN_LockRxMsgBuff/142 
   Indirect call Num speculative call targets: 0
FlexCAN_IRQHandlerRxMB/62 (FlexCAN_IRQHandlerRxMB) @07ecd7e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_MainFunctionRead/95 FlexCAN_IRQHandler/82 FlexCAN_Ip_ReceiveBlocking/74 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetMsgBuff/143 FlexCAN_LockRxMsgBuff/142 
   Indirect call Num speculative call targets: 0
FlexCAN_StartRxMessageFifoData/61 (FlexCAN_StartRxMessageFifoData) @07ecd2a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 FlexCAN_Ip_RxFifo/75 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 DevAssert/0 
FlexCAN_StartSendData/60 (FlexCAN_StartSendData) @07ecdee0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_Send/71 
  Calls: FlexCAN_SetTxMsgBuff/141 FlexCAN_GetMsgBuffRegion/140 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_IsMbOutOfRange/138 DevAssert/0 FlexCAN_GetMbPayloadSize/139 DevAssert/0 DevAssert/0 
FlexCAN_StartRxMessageBufferData/59 (FlexCAN_StartRxMessageBufferData) @07ecdc40
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 
  Calls: FlexCAN_IsMbOutOfRange/138 DevAssert/0 
FlexCAN_ProccessLegacyRxFIFO/58 (FlexCAN_ProccessLegacyRxFIFO) @07ecd9a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifoBlocking/76 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 OsIf_GetElapsed/135 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_GetBuffStatusFlag/10 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 
FlexCAN_ProccessEnhancedRxFifo/57 (FlexCAN_ProccessEnhancedRxFifo) @07ecd700
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 OsIf_GetElapsed/135 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 
FlexCAN_StartRxMessageEnhancedFifoData/56 (FlexCAN_StartRxMessageEnhancedFifoData) @07ecd460
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 DevAssert/0 
FlexCAN_CompleteRxMessageEnhancedFifoData/55 (FlexCAN_CompleteRxMessageEnhancedFifoData) @07ecd1c0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandlerEnhancedRxFIFO/67 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 DevAssert/0 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 
FlexCAN_InitBaudrate/54 (FlexCAN_InitBaudrate) @07c4fe00
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_Init_Privileged/70 
  Calls: FlexCAN_SetTimeSegments/13 FlexCAN_SetFDTimeSegments/12 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_SetEnhancedNominalTimeSegments/15 FlexCAN_EnableExtCbt/25 
FlexCAN_InitController/53 (FlexCAN_InitController) @07c4f8c0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_Init_Privileged/70 
  Calls: FlexCAN_InitCtroll/52 FlexCAN_ResetImaskBuff/131 FlexCAN_ConfigCtrlOptions/130 FlexCAN_SetFDEnabled/6 FlexCAN_DisableMemErrorDetection/5 FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_Init/129 FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_IsEnabled/4 
FlexCAN_InitCtroll/52 (FlexCAN_InitCtroll) @07c4fd20
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_InitController/53 
  Calls: FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_SetMaxMsgBuffNum/128 FlexCAN_SetPayloadSize/127 FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_InitRxFifo/51 FlexCAN_SetSelfReception/26 
FlexCAN_InitRxFifo/51 (FlexCAN_InitRxFifo) @07c4fa80
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_InitCtroll/52 
  Calls: FlexCAN_EnableEnhancedRxFifo/124 FlexCAN_EnableRxFifo/123 
Flexcan_Ip_apxState/50 (Flexcan_Ip_apxState) @07c49870
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: FlexCAN_CompleteRxMessageEnhancedFifoData/55 (read) FlexCAN_StartRxMessageEnhancedFifoData/56 (read) FlexCAN_ProccessEnhancedRxFifo/57 (read) FlexCAN_ProccessLegacyRxFIFO/58 (read) FlexCAN_IRQHandlerRxFIFO/64 (read) FlexCAN_StartRxMessageBufferData/59 (read) FlexCAN_StartSendData/60 (read) FlexCAN_StartRxMessageFifoData/61 (read) FlexCAN_IRQHandlerRxMB/62 (read) FlexCAN_IRQHandlerTxMB/63 (read) FlexCAN_IRQHandlerEnhancedRxFIFO/67 (read) FlexCAN_AbortTxTransfer/68 (read) FlexCAN_AbortRxTransfer/69 (read) FlexCAN_Ip_Init_Privileged/70 (write) FlexCAN_Ip_Send/71 (read) FlexCAN_Ip_ConfigRxMb/72 (read) FlexCAN_Ip_Receive/73 (read) FlexCAN_Ip_ReceiveBlocking/74 (read) FlexCAN_Ip_ConfigRemoteResponseMb/79 (read) FlexCAN_Ip_GetTransferStatus/80 (read) FlexCAN_CompleteRxMessageFifoData/81 (read) FlexCAN_IRQHandler/82 (read) FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 (read) FlexCAN_ProcessSpuriousInterruptMB/65 (read) FlexCAN_Busoff_Error_IRQHandler/87 (read) FlexCAN_Ip_SendBlocking/88 (read) FlexCAN_Ip_Deinit_Privileged/94 (write) FlexCAN_Ip_MainFunctionRead/95 (read) FlexCAN_Ip_MainFunctionBusOff_Privileged/96 (read) FlexCAN_Ip_MainFunctionWrite/97 (read) FlexCAN_Ip_EnableInterrupts_Privileged/114 (read) FlexCAN_Ip_DisableInterrupts_Privileged/115 (read) FlexCAN_Ip_AbortTransfer/117 (read) 
  Availability: available
  Varpool flags:
Flexcan_Ip_apxBase/49 (Flexcan_Ip_apxBase) @07c497e0
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: FlexCAN_CompleteRxMessageEnhancedFifoData/55 (read) FlexCAN_StartRxMessageEnhancedFifoData/56 (read) FlexCAN_ProccessEnhancedRxFifo/57 (read) FlexCAN_ProccessLegacyRxFIFO/58 (read) FlexCAN_IRQHandlerRxFIFO/64 (read) FlexCAN_StartRxMessageBufferData/59 (read) FlexCAN_StartSendData/60 (read) FlexCAN_StartRxMessageFifoData/61 (read) FlexCAN_IRQHandlerRxMB/62 (read) FlexCAN_IRQHandlerTxMB/63 (read) FlexCAN_IRQHandlerEnhancedRxFIFO/67 (read) FlexCAN_AbortTxTransfer/68 (read) FlexCAN_AbortRxTransfer/69 (read) FlexCAN_Ip_Init_Privileged/70 (read) FlexCAN_Ip_Send/71 (read) FlexCAN_Ip_ConfigRxMb/72 (read) FlexCAN_Ip_Receive/73 (read) FlexCAN_Ip_ReceiveBlocking/74 (read) FlexCAN_Ip_RxFifo/75 (read) FlexCAN_Ip_RxFifoBlocking/76 (read) FlexCAN_Ip_ConfigRxFifo_Privileged/77 (read) FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 (read) FlexCAN_Ip_ConfigRemoteResponseMb/79 (read) FlexCAN_CompleteRxMessageFifoData/81 (read) FlexCAN_IRQHandler/82 (read) FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 (read) FlexCAN_ProcessSpuriousInterruptMB/65 (read) FlexCAN_Ip_ClearErrorStatus/83 (read) FlexCAN_Ip_GetErrorStatus/84 (read) FlexCAN_Ip_GetControllerTxErrorCounter/85 (read) FlexCAN_Ip_GetControllerRxErrorCounter/86 (read) FlexCAN_Busoff_Error_IRQHandler/87 (read) FlexCAN_Ip_SendBlocking/88 (read) FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 (read) FlexCAN_Ip_EnterFreezeMode_Privileged/90 (read) FlexCAN_Ip_ExitFreezeMode_Privileged/91 (read) FlexCAN_Ip_SetRxIndividualMask_Privileged/92 (read) FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 (read) FlexCAN_Ip_Deinit_Privileged/94 (read) FlexCAN_Ip_MainFunctionRead/95 (read) FlexCAN_Ip_MainFunctionBusOff_Privileged/96 (read) FlexCAN_Ip_MainFunctionWrite/97 (read) FlexCAN_Ip_GetStopMode_Privileged/98 (read) FlexCAN_Ip_GetStartMode_Privileged/99 (read) FlexCAN_Ip_SetStartMode_Privileged/100 (read) FlexCAN_Ip_SetStopMode_Privileged/101 (read) FlexCAN_Ip_SetRxMaskType_Privileged/102 (read) FlexCAN_Ip_SetBitrate_Privileged/103 (read) FlexCAN_Ip_GetBitrate/104 (read) FlexCAN_Ip_ClearTDCFail/105 (read) FlexCAN_Ip_GetTDCFail/106 (read) FlexCAN_Ip_GetTDCValue/107 (read) FlexCAN_Ip_SetBitrateCbt_Privileged/108 (read) FlexCAN_Ip_GetBitrateFD/109 (read) FlexCAN_Ip_SetTDCOffset_Privileged/110 (read) FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 (read) FlexCAN_Ip_GetBuffStatusFlag/112 (read) FlexCAN_Ip_ClearBuffStatusFlag/113 (read) FlexCAN_Ip_EnableInterrupts_Privileged/114 (read) FlexCAN_Ip_DisableInterrupts_Privileged/115 (read) FlexCAN_Ip_SetErrorInt_Privileged/116 (read) FlexCAN_Ip_AbortTransfer/117 (read) FlexCAN_Ip_SetRxMb14Mask_Privileged/118 (read) FlexCAN_Ip_SetRxMb15Mask_Privileged/119 (read) FlexCAN_Ip_SetListenOnlyMode_Privileged/120 (read) FlexCAN_Ip_GetListenOnlyMode/121 (read) FlexCAN_Ip_ManualBusOffRecovery/122 (read) 
  Availability: available
  Varpool flags: initialized read-only const-value-known
FlexCAN_SetRegDefaultVal/48 (FlexCAN_SetRegDefaultVal) @07ddaee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_Deinit_Privileged/94 
  Calls: FlexCAN_GetMaxMbNum/153 FlexCAN_GetMaxMbNum/153 FlexCAN_IsEnhancedRxFifoAvailable/132 
FlexCAN_GetEnhancedRxFIFOIntStatusFlag/47 (FlexCAN_GetEnhancedRxFIFOIntStatusFlag) @07dda460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 
  Calls: 
FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 (FlexCAN_ClearEnhancedRxFifoIntStatusFlag) @07dda1c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 
  Calls: 
FlexCAN_GetEnhancedRxFIFOStatusFlag/45 (FlexCAN_GetEnhancedRxFIFOStatusFlag) @07dd6ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
FlexCAN_SetEnhancedRxFifoIntAll/44 (FlexCAN_SetEnhancedRxFifoIntAll) @07dd6c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_ProccessEnhancedRxFifo/57 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_CompleteRxMessageEnhancedFifoData/55 
  Calls: 
FlexCAN_IsEnhancedRxFifoEnabled/43 (FlexCAN_IsEnhancedRxFifoEnabled) @07dd69a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_IRQHandler/82 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 
  Calls: 
FlexCAN_SetRxMaskType/42 (FlexCAN_SetRxMaskType) @07dd6700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/102 
  Calls: 
FlexCAN_SetTxArbitrationStartDelay/41 (FlexCAN_SetTxArbitrationStartDelay) @07dd62a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 
  Calls: 
FlexCAN_IsFreezeMode/40 (FlexCAN_IsFreezeMode) @07dd2ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 
  Calls: 
FlexCAN_SetRxIndividualMask/39 (FlexCAN_SetRxIndividualMask) @07dd2c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxIndividualMask_Privileged/92 
  Calls: 
FlexCAN_SetRxMsgBuffGlobalMask/38 (FlexCAN_SetRxMsgBuffGlobalMask) @07dd29a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 
  Calls: 
FlexCAN_GetMsgBuffIntStatusFlag/37 (FlexCAN_GetMsgBuffIntStatusFlag) @07dd2700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 
  Calls: 
RxFifoOcuppiedLastMsgBuff/29 (RxFifoOcuppiedLastMsgBuff) @07d219a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_AbortRxTransfer/69 
  Calls: 
FlexCAN_IsListenOnlyModeEnabled/28 (FlexCAN_IsListenOnlyModeEnabled) @07d21700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetListenOnlyMode/121 FlexCAN_Ip_Send/71 
  Calls: 
FlexCAN_IsFDEnabled/27 (FlexCAN_IsFDEnabled) @07d21460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 
  Calls: 
FlexCAN_SetSelfReception/26 (FlexCAN_SetSelfReception) @07d211c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_EnableExtCbt/25 (FlexCAN_EnableExtCbt) @07d1dd20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitBaudrate/54 
  Calls: 
FlexCAN_EnhCbtEnable/24 (FlexCAN_EnhCbtEnable) @07d1d9a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
FlexCAN_IsEnhCbtEnabled/23 (FlexCAN_IsEnhCbtEnabled) @07d1d620
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_GetTDCValue/107 FlexCAN_Ip_GetTDCFail/106 FlexCAN_Ip_ClearTDCFail/105 FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_IsExCbtEnabled/22 (FlexCAN_IsExCbtEnabled) @07d1d380
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
FlexCAN_GetFDTimeSegments/21 (FlexCAN_GetFDTimeSegments) @07d1d0e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/109 
  Calls: 
FlexCAN_GetTimeSegments/20 (FlexCAN_GetTimeSegments) @07cf6e00
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_GetExtendedTimeSegments/19 (FlexCAN_GetExtendedTimeSegments) @07cf6b60
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_GetEnhancedDataTimeSegments/18 (FlexCAN_GetEnhancedDataTimeSegments) @07cf68c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/109 
  Calls: DevAssert/0 
FlexCAN_SetEnhancedDataTimeSegments/17 (FlexCAN_SetEnhancedDataTimeSegments) @07cf6620
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_GetEnhancedNominalTimeSegments/16 (FlexCAN_GetEnhancedNominalTimeSegments) @07cf60e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_SetEnhancedNominalTimeSegments/15 (FlexCAN_SetEnhancedNominalTimeSegments) @07cf2e00
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_SetExtendedTimeSegments/14 (FlexCAN_SetExtendedTimeSegments) @07cf28c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_SetTimeSegments/13 (FlexCAN_SetTimeSegments) @07cf21c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_SetFDTimeSegments/12 (FlexCAN_SetFDTimeSegments) @07ceda80
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_GetBuffStatusImask/11 (FlexCAN_GetBuffStatusImask) @07ced380
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_ProcessSpuriousInterruptMB/65 
  Calls: 
FlexCAN_GetBuffStatusFlag/10 (FlexCAN_GetBuffStatusFlag) @07ced0e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_ProcessSpuriousInterruptMB/65 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessLegacyRxFIFO/58 
  Calls: 
FlexCAN_ClearMsgBuffIntStatusFlag/9 (FlexCAN_ClearMsgBuffIntStatusFlag) @07ce7e00
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_ProcessSpuriousInterruptMB/65 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_AbortRxTransfer/69 FlexCAN_AbortTxTransfer/68 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 FlexCAN_StartSendData/60 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_IRQHandlerRxFIFO/64 
  Calls: 
FlexCAN_UnlockRxMsgBuff/8 (FlexCAN_UnlockRxMsgBuff) @07ce7b60
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 
  Calls: 
FlexCAN_SetListenOnlyMode/7 (FlexCAN_SetListenOnlyMode) @07ce77e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 
  Calls: 
FlexCAN_SetFDEnabled/6 (FlexCAN_SetFDEnabled) @07ce7460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_InitController/53 
  Calls: 
FlexCAN_DisableMemErrorDetection/5 (FlexCAN_DisableMemErrorDetection) @07ce7000
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_IsEnabled/4 (FlexCAN_IsEnabled) @07ce38c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_InitController/53 
  Calls: 
FlexCAN_SetEnhancedTDCOffset/3 (FlexCAN_SetEnhancedTDCOffset) @07ce3460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
FlexCAN_SetTDCOffset/2 (FlexCAN_SetTDCOffset) @07ce30e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
FlexCAN_SetRxFifoGlobalMask/1 (FlexCAN_SetRxFifoGlobalMask) @07cdcd20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 
  Calls: 
DevAssert/0 (DevAssert) @07dc1b60
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_AbortTransfer/117 FlexCAN_Ip_AbortTransfer/117 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_GetEnhancedDataTimeSegments/18 FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_GetTDCValue/107 FlexCAN_Ip_GetTDCFail/106 FlexCAN_Ip_ClearTDCFail/105 FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_SetStartMode_Privileged/100 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionBusOff_Privileged/96 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_Busoff_Error_IRQHandler/87 FlexCAN_Ip_GetControllerRxErrorCounter/86 FlexCAN_Ip_GetControllerTxErrorCounter/85 FlexCAN_Ip_GetErrorStatus/84 FlexCAN_Ip_ClearErrorStatus/83 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_Ip_GetTransferStatus/80 FlexCAN_Ip_GetTransferStatus/80 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_Send/71 FlexCAN_Ip_Send/71 FlexCAN_Ip_Init_Privileged/70 FlexCAN_Ip_Init_Privileged/70 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartSendData/60 FlexCAN_StartSendData/60 FlexCAN_StartSendData/60 FlexCAN_StartRxMessageBufferData/59 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_SetTimeSegments/13 FlexCAN_SetFDTimeSegments/12 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_SetEnhancedNominalTimeSegments/15 
  Calls: 
FlexCAN_Ip_ManualBusOffRecovery (uint8 Instance)
{
  Flexcan_Ip_StatusType RetVal;
  uint32 uS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * Base;
  Flexcan_Ip_StatusType D.11354;
  long unsigned int D.11351;

  <bb 2> :
  _1 = (int) Instance;
  Base = Flexcan_Ip_apxBase[_1];
  timeStart = 0;
  timeElapsed = 0;
  uS2Ticks = OsIf_MicrosToTicks (10000, 0);
  RetVal = 1;
  _2 = Instance <= 5;
  DevAssert (_2);
  _3 = Base->CTRL1;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  RetVal = 0;
  _5 = Base->ESR1;
  _6 = _5 & 32;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20 ();
  _7 = Base->CTRL1;
  _8 = _7 & 4294967231;
  Base->CTRL1 = _8;
  _9 = Base->CTRL1;
  _10 = _9 | 64;
  Base->CTRL1 = _10;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20 ();
  _11 = OsIf_GetCounter (0);
  timeStart = _11;
  goto <bb 7>; [INV]

  <bb 5> :
  D.11351 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.11351 + timeElapsed;
  if (timeElapsed >= uS2Ticks)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  RetVal = 3;
  goto <bb 8>; [INV]

  <bb 7> :
  _12 = Base->ESR1;
  _13 = _12 & 32;
  if (_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.11354 = RetVal;
  timeStart = {CLOBBER};

  <bb 9> :
<L10>:
  return D.11354;

}


FlexCAN_Ip_GetListenOnlyMode (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.11345;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  D.11345 = FlexCAN_IsListenOnlyModeEnabled (base);

  <bb 3> :
<L0>:
  return D.11345;

}


FlexCAN_Ip_SetListenOnlyMode_Privileged (uint8 instance, const boolean enable)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11339;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10 ();
  FlexCAN_SetListenOnlyMode (pBase, enable);
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10 ();

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11339 = result;

  <bb 13> :
<L12>:
  return D.11339;

}


FlexCAN_Ip_SetRxMb15Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11325;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  freeze = 0;
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  pBase->RX15MASK = mask;

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11325 = result;

  <bb 13> :
<L12>:
  return D.11325;

}


FlexCAN_Ip_SetRxMb14Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11311;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  freeze = 0;
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  pBase->RX14MASK = mask;

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11311 = result;

  <bb 13> :
<L12>:
  return D.11311;

}


FlexCAN_Ip_AbortTransfer (uint8 u8Instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType result;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11297;
  int iftmp.9;

  <bb 2> :
  _1 = u8Instance <= 5;
  DevAssert (_1);
  if (mb_idx <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.9 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.9 = 0;

  <bb 6> :
  _2 = (_Bool) iftmp.9;
  DevAssert (_2);
  _3 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_3];
  _4 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_4];
  result = 0;
  if (mb_idx <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 7> :
  _5 = (int) mb_idx;
  _6 = state->mbs[_5].state;
  if (_6 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  result = 5;
  goto <bb 13>; [INV]

  <bb 9> :
  _7 = (long unsigned int) mb_idx;
  _8 = state->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase, u8Instance, _7, _8);
  _9 = (int) mb_idx;
  _10 = state->mbs[_9].state;
  if (_10 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result = FlexCAN_AbortTxTransfer (u8Instance, mb_idx);

  <bb 11> :
  _11 = (int) mb_idx;
  _12 = state->mbs[_11].state;
  if (_12 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_AbortRxTransfer (u8Instance, mb_idx);

  <bb 13> :
  D.11297 = result;

  <bb 14> :
<L13>:
  return D.11297;

}


FlexCAN_Ip_SetErrorInt_Privileged (uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11281;

  <bb 2> :
  _1 = u8Instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  if (result == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 5> :
  switch (type) <default: <L14> [INV], case 0: <L6> [INV], case 1: <L10> [INV], case 2: <L4> [INV], case 3: <L5> [INV], case 4: <L3> [INV]>

  <bb 6> :
<L3>:
  FlexCAN_SetErrIntCmd (pBase, 32768, enable);
  goto <bb 18>; [INV]

  <bb 7> :
<L4>:
  FlexCAN_SetErrIntCmd (pBase, 16384, enable);
  goto <bb 18>; [INV]

  <bb 8> :
<L5>:
  FlexCAN_SetErrIntCmd (pBase, 16385, enable);
  goto <bb 18>; [INV]

  <bb 9> :
<L6>:
  _8 = FlexCAN_IsFreezeMode (pBase);
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetErrIntCmd (pBase, 1024, enable);

  <bb 12> :
  goto <bb 18>; [INV]

  <bb 13> :
<L10>:
  _10 = FlexCAN_IsFreezeMode (pBase);
  _11 = ~_10;
  if (_11 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result = 1;
  goto <bb 16>; [INV]

  <bb 15> :
  FlexCAN_SetErrIntCmd (pBase, 2048, enable);

  <bb 16> :
  goto <bb 18>; [INV]

  <bb 17> :
<L14>:
  DevAssert (0);

  <bb 18> :
  if (disabled != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  result = status;

  <bb 21> :
  D.11281 = result;

  <bb 22> :
<L21>:
  return D.11281;

}


FlexCAN_Ip_DisableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11265;

  <bb 2> :
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  result = 1;
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = u8Instance <= 5;
  DevAssert (_3);
  _4 = FlexCAN_IsEnabled (pBase);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  FlexCAN_DisableInterrupts (pBase);
  _5 = FlexCAN_IsEnhancedRxFifoAvailable (pBase);
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _6 = FlexCAN_IsEnhancedRxFifoEnabled (pBase);
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_SetEnhancedRxFifoIntAll (pBase, 0);

  <bb 6> :
  state->isIntActive = 0;
  result = 0;

  <bb 7> :
  D.11265 = result;

  <bb 8> :
<L6>:
  return D.11265;

}


FlexCAN_Ip_EnableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11257;

  <bb 2> :
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  result = 1;
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = u8Instance <= 5;
  DevAssert (_3);
  _4 = FlexCAN_IsEnabled (pBase);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  FlexCAN_EnableInterrupts (pBase, u8Instance);
  _5 = state->enhancedFifoOutput.isPolling;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _7 = FlexCAN_IsEnhancedRxFifoAvailable (pBase);
  if (_7 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _8 = FlexCAN_IsEnhancedRxFifoEnabled (pBase);
  if (_8 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_SetEnhancedRxFifoIntAll (pBase, 1);

  <bb 7> :
  state->isIntActive = 1;
  result = 0;

  <bb 8> :
  D.11257 = result;

  <bb 9> :
<L8>:
  return D.11257;

}


FlexCAN_Ip_ClearBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  if (msgBuffIdx == 255)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (pBase, 30);
  goto <bb 5>; [INV]

  <bb 4> :
  _3 = (long unsigned int) msgBuffIdx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _3);

  <bb 5> :
  return;

}


FlexCAN_Ip_GetBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  const struct FLEXCAN_Type * pBase;
  boolean returnResult;
  boolean D.11244;

  <bb 2> :
  returnResult = 1;
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  if (msgBuffIdx == 255)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetEnhancedRxFIFOStatusFlag (pBase, 30);
  returnResult = _3 == 1;
  goto <bb 5>; [INV]

  <bb 4> :
  _4 = (long unsigned int) msgBuffIdx;
  _5 = FlexCAN_GetBuffStatusFlag (pBase, _4);
  returnResult = _5 == 1;

  <bb 5> :
  D.11244 = returnResult;

  <bb 6> :
<L3>:
  return D.11244;

}


FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (uint8 instance, uint8 value)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11239;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17 ();
  FlexCAN_SetTxArbitrationStartDelay (pBase, value);
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17 ();

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11239 = result;

  <bb 13> :
<L12>:
  return D.11239;

}


FlexCAN_Ip_SetTDCOffset_Privileged (uint8 instance, boolean enable, uint8 offset)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11221;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16 ();
  _9 = pBase->CTRL2;
  _10 = _9 & 8192;
  if (_10 == 8192)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_SetEnhancedTDCOffset (pBase, enable, offset);
  goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_SetTDCOffset (pBase, enable, offset);

  <bb 11> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16 ();

  <bb 12> :
  if (disabled != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result = status;

  <bb 15> :
  D.11221 = result;

  <bb 16> :
<L15>:
  return D.11221;

}


FlexCAN_Ip_GetBitrateFD (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.11204;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = bitrate != 0B;
  DevAssert (_2);
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  enhCbt = 0;
  enhCbt = FlexCAN_IsEnhCbtEnabled (pBase);
  if (enhCbt != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_GetEnhancedDataTimeSegments (pBase, bitrate);
  goto <bb 5>; [INV]

  <bb 4> :
  FlexCAN_GetFDTimeSegments (pBase, bitrate);

  <bb 5> :
  D.11204 = enhCbt;

  <bb 6> :
<L3>:
  return D.11204;

}


FlexCAN_Ip_SetBitrateCbt_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
  boolean enhCbt;
  boolean freeze;
  boolean disabled;
  boolean fd_enable;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11197;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = bitrate != 0B;
  DevAssert (_2);
  result = 0;
  status = 0;
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  fd_enable = FlexCAN_IsFDEnabled (pBase);
  _4 = pBase->MCR;
  _5 = (signed int) _4;
  disabled = _5 < 0;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  _6 = pBase->MCR;
  _7 = _6 & 16777216;
  freeze = _7 != 0;
  _8 = ~fd_enable;
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _9 = ~freeze;
  if (_9 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (result == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  result = 1;

  <bb 8> :
  if (result == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  enhCbt = FlexCAN_IsEnhCbtEnabled (pBase);
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15 ();
  FlexCAN_SetFDEnabled (pBase, fd_enable, bitRateSwitch);
  if (enhCbt != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_SetEnhancedDataTimeSegments (pBase, bitrate);
  goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetFDTimeSegments (pBase, bitrate);

  <bb 12> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15 ();

  <bb 13> :
  if (disabled != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  result = status;

  <bb 16> :
  D.11197 = result;

  <bb 17> :
<L15>:
  return D.11197;

}


FlexCAN_Ip_GetTDCValue (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  uint8 value;
  uint8 D.11180;

  <bb 2> :
  value = 0;
  _1 = u8Instance <= 5;
  DevAssert (_1);
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnhCbtEnabled (pBase);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = pBase->ETDC;
  value = (uint8) _4;
  goto <bb 5>; [INV]

  <bb 4> :
  _5 = pBase->FDCTRL;
  _6 = (unsigned char) _5;
  value = _6 & 63;

  <bb 5> :
  D.11180 = value;

  <bb 6> :
<L3>:
  return D.11180;

}


FlexCAN_Ip_GetTDCFail (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  boolean value;
  boolean D.11175;

  <bb 2> :
  value = 0;
  _1 = u8Instance <= 5;
  DevAssert (_1);
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnhCbtEnabled (pBase);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = pBase->ETDC;
  _5 = _4 & 32768;
  value = _5 == 32768;
  goto <bb 5>; [INV]

  <bb 4> :
  _6 = pBase->FDCTRL;
  _7 = _6 & 16384;
  value = _7 == 16384;

  <bb 5> :
  D.11175 = value;

  <bb 6> :
<L3>:
  return D.11175;

}


FlexCAN_Ip_ClearTDCFail (uint8 u8Instance)
{
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  _1 = u8Instance <= 5;
  DevAssert (_1);
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09 ();
  _3 = FlexCAN_IsEnhCbtEnabled (pBase);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = pBase->ETDC;
  _5 = _4 | 32768;
  pBase->ETDC = _5;
  goto <bb 5>; [INV]

  <bb 4> :
  _6 = pBase->FDCTRL;
  _7 = _6 | 16384;
  pBase->FDCTRL = _7;

  <bb 5> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09 ();
  return;

}


FlexCAN_Ip_GetBitrate (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.11165;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = bitrate != 0B;
  DevAssert (_2);
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  enhCbt = 0;
  enhCbt = FlexCAN_IsEnhCbtEnabled (pBase);
  if (enhCbt != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_GetEnhancedNominalTimeSegments (pBase, bitrate);
  goto <bb 7>; [INV]

  <bb 4> :
  _4 = FlexCAN_IsExCbtEnabled (pBase);
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_GetExtendedTimeSegments (pBase, bitrate);
  goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_GetTimeSegments (pBase, bitrate);

  <bb 7> :
  D.11165 = enhCbt;

  <bb 8> :
<L6>:
  return D.11165;

}


FlexCAN_Ip_SetBitrate_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11151;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = bitrate != 0B;
  DevAssert (_2);
  result = 0;
  status = 0;
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  _4 = pBase->MCR;
  _5 = (signed int) _4;
  disabled = _5 < 0;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  _6 = pBase->MCR;
  _7 = _6 & 16777216;
  freeze = _7 != 0;
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14 ();
  FlexCAN_EnhCbtEnable (pBase, enhExt);
  if (enhExt != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_SetEnhancedNominalTimeSegments (pBase, bitrate);
  goto <bb 13>; [INV]

  <bb 10> :
  _9 = FlexCAN_IsExCbtEnabled (pBase);
  if (_9 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetExtendedTimeSegments (pBase, bitrate);
  goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_SetTimeSegments (pBase, bitrate);

  <bb 13> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14 ();

  <bb 14> :
  if (disabled != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  result = status;

  <bb 17> :
  D.11151 = result;

  <bb 18> :
<L18>:
  return D.11151;

}


FlexCAN_Ip_SetRxMaskType_Privileged (uint8 instance, Flexcan_Ip_RxMaskType type)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11128;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08 ();
  FlexCAN_SetRxMaskType (pBase, type);
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08 ();

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11128 = result;

  <bb 13> :
<L12>:
  return D.11128;

}


FlexCAN_Ip_SetStopMode_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType status;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11114;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  status = FlexCAN_EnterFreezeMode (pBase);
  if (status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  status = FlexCAN_Disable (pBase);

  <bb 4> :
  D.11114 = status;

  <bb 5> :
<L2>:
  return D.11114;

}


FlexCAN_Ip_SetStartMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11110;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07 ();
  _3 = pBase->MCR;
  _4 = _3 & 2147483647;
  pBase->MCR = _4;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07 ();
  D.11110 = FlexCAN_ExitFreezeMode (pBase);

  <bb 3> :
<L0>:
  return D.11110;

}


FlexCAN_Ip_GetStartMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.11108;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = base->MCR;
  _3 = _2 & 17825792;
  D.11108 = _3 == 0;

  <bb 3> :
<L0>:
  return D.11108;

}


FlexCAN_Ip_GetStopMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.11106;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = base->MCR;
  _3 = _2 & 1048576;
  D.11106 = _3 == 1048576;

  <bb 3> :
<L0>:
  return D.11106;

}


FlexCAN_Ip_MainFunctionWrite (uint8 instance, uint8 mb_idx)
{
  struct Flexcan_Ip_MsgBuffType mb;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = (long unsigned int) mb_idx;
  _5 = FlexCAN_GetBuffStatusFlag (base, _4);
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  _6 = (int) mb_idx;
  _7 = state->mbs[_6].state;
  if (_7 == 2)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  _8 = (int) mb_idx;
  _9 = state->mbs[_8].isRemote;
  if (_9 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _10 = (long unsigned int) mb_idx;
  FlexCAN_LockRxMsgBuff (base, _10);
  _11 = (long unsigned int) mb_idx;
  FlexCAN_GetMsgBuff (base, _11, &mb);
  FlexCAN_UnlockRxMsgBuff (base);
  _12 = (int) mb_idx;
  _13 = mb.time_stamp;
  state->mbs[_12].time_stamp = _13;
  _14 = mb.cs;
  _15 = _14 >> 24;
  _16 = _15 & 15;
  if (_16 == 4)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _17 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _17);

  <bb 7> :
  mb = {CLOBBER};
  goto <bb 9>; [INV]

  <bb 8> :
  _18 = (long unsigned int) mb_idx;
  _19 = (int) mb_idx;
  _20 = FlexCAN_GetMsgBuffTimestamp (base, _18);
  state->mbs[_19].time_stamp = _20;
  FlexCAN_UnlockRxMsgBuff (base);
  _21 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _21);

  <bb 9> :
  _22 = (int) mb_idx;
  state->mbs[_22].state = 0;
  _23 = state->callback;
  if (_23 != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _24 = state->callback;
  _25 = (long unsigned int) mb_idx;
  _24 (instance, 4, _25, state);

  <bb 11> :
  return;

}


FlexCAN_Ip_MainFunctionBusOff_Privileged (uint8 instance)
{
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType eRetVal;
  Flexcan_Ip_StatusType D.11093;

  <bb 2> :
  eRetVal = 1;
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  u32ErrStatus = 0;
  _3 = instance <= 5;
  DevAssert (_3);
  u32ErrStatus = base->ESR1;
  _4 = u32ErrStatus & 4;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _5 = state->error_callback;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = state->error_callback;
  _6 (instance, 11, u32ErrStatus, state);

  <bb 5> :
  base->ESR1 = 4;
  eRetVal = 0;

  <bb 6> :
  D.11093 = eRetVal;

  <bb 7> :
<L4>:
  return D.11093;

}


FlexCAN_Ip_MainFunctionRead (uint8 instance, uint8 mb_idx)
{
  const struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  int iftmp.7;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  if (mb_idx <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.7 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.7 = 0;

  <bb 6> :
  _4 = (_Bool) iftmp.7;
  DevAssert (_4);
  if (mb_idx == 255)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  _5 = FlexCAN_IsEnhancedRxFifoAvailable (base);
  if (_5 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 8> :
  _6 = FlexCAN_IsEnhancedRxFifoEnabled (base);
  if (_6 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 9> :
  _7 = FlexCAN_GetEnhancedRxFIFOStatusFlag (base, 28);
  if (_7 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 10> :
  FlexCAN_IRQHandlerEnhancedRxFIFO (instance, 28);
  goto <bb 20>; [INV]

  <bb 11> :
  _8 = state->bIsLegacyFifoEn;
  if (_8 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 12> :
  if (mb_idx <= 7)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  if (mb_idx == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _9 = FlexCAN_GetBuffStatusFlag (base, 5);
  if (_9 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  FlexCAN_IRQHandlerRxFIFO (instance, 5);

  <bb 16> :
  goto <bb 20>; [INV]

  <bb 17> :
  _10 = (long unsigned int) mb_idx;
  _11 = FlexCAN_GetBuffStatusFlag (base, _10);
  if (_11 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  _12 = (int) mb_idx;
  _13 = state->mbs[_12].state;
  if (_13 == 1)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _14 = (long unsigned int) mb_idx;
  FlexCAN_IRQHandlerRxMB (instance, _14);

  <bb 20> :
  return;

}


FlexCAN_Ip_Deinit_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.11055;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  result = 1;
  _2 = instance <= 5;
  DevAssert (_2);
  result = FlexCAN_EnterFreezeMode (base);
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_SetRegDefaultVal (base);
  FlexCAN_Disable (base);
  _3 = (int) instance;
  Flexcan_Ip_apxState[_3] = 0B;

  <bb 4> :
  D.11055 = result;

  <bb 5> :
<L2>:
  return D.11055;

}


FlexCAN_Ip_SetRxFifoGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11051;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxFifoGlobalMask (pBase, mask);

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11051 = result;

  <bb 13> :
<L12>:
  return D.11051;

}


FlexCAN_Ip_SetRxIndividualMask_Privileged (uint8 instance, uint8 mb_idx, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11037;

  <bb 2> :
  result = 0;
  status = 0;
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  freeze = 0;
  _2 = instance <= 5;
  DevAssert (_2);
  _3 = (long unsigned int) mb_idx;
  _4 = pBase->MCR;
  _5 = _4 & 127;
  if (_3 > _5)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx > 95)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result = 4;
  goto <bb 15>; [INV]

  <bb 5> :
  _6 = FlexCAN_IsEnabled (pBase);
  _7 = (int) _6;
  _8 = _7 != 0;
  _9 = ~_8;
  _10 = (int) _9;
  disabled = (boolean) _10;
  if (disabled != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = FlexCAN_Enable (pBase);

  <bb 7> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _11 = ~freeze;
  if (_11 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (result == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  result = 1;

  <bb 10> :
  if (result == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _12 = (long unsigned int) mb_idx;
  FlexCAN_SetRxIndividualMask (pBase, _12, mask);

  <bb 12> :
  if (disabled != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result = status;

  <bb 15> :
  D.11037 = result;

  <bb 16> :
<L16>:
  return D.11037;

}


FlexCAN_Ip_ExitFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.11019;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  D.11019 = FlexCAN_ExitFreezeMode (base);

  <bb 3> :
<L0>:
  return D.11019;

}


FlexCAN_Ip_EnterFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.11017;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  D.11017 = FlexCAN_EnterFreezeMode (base);

  <bb 3> :
<L0>:
  return D.11017;

}


FlexCAN_Ip_SetRxMbGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11015;

  <bb 2> :
  result = 0;
  status = 0;
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  freeze = 0;
  _2 = instance <= 5;
  DevAssert (_2);
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxMsgBuffGlobalMask (pBase, mask);

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.11015 = result;

  <bb 13> :
<L12>:
  return D.11015;

}


FlexCAN_Ip_SendBlocking (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data, uint32 timeout_ms)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 uS2Ticks;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11000;
  long unsigned int D.10993;
  long unsigned int D.10986;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  timeStart = 0;
  timeElapsed = 0;
  _3 = timeout_ms * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_3, 0);
  uS2Ticks = 0;
  flexcan_mb_config = 0;
  flexcan_mb = 0B;
  _4 = instance <= 5;
  DevAssert (_4);
  _5 = tx_info != 0B;
  DevAssert (_5);
  result = FlexCAN_StartSendData (instance, mb_idx, tx_info, msg_id, mb_data);
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 3> :
  _6 = OsIf_GetCounter (0);
  timeStart = _6;
  goto <bb 6>; [INV]

  <bb 4> :
  D.10986 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.10986 + timeElapsed;
  if (timeElapsed >= mS2Ticks)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  result = 3;
  goto <bb 7>; [INV]

  <bb 6> :
  _7 = (long unsigned int) mb_idx;
  _8 = FlexCAN_GetBuffStatusFlag (base, _7);
  if (_8 != 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (result == 3)
    goto <bb 8>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 8> :
  _9 = (int) mb_idx;
  _10 = state->mbs[_9].state;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 9> :
  _11 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _11);
  _12 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (base, _12);
  flexcan_mb_config = *flexcan_mb;
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  flexcan_mb_config = flexcan_mb_config | 150994944;
  *flexcan_mb = flexcan_mb_config;
  uS2Ticks = OsIf_MicrosToTicks (10000, 0);
  _13 = OsIf_GetCounter (0);
  timeStart = _13;
  timeElapsed = 0;
  goto <bb 12>; [INV]

  <bb 10> :
  D.10993 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.10993 + timeElapsed;
  if (timeElapsed >= uS2Ticks)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = 3;
  goto <bb 13>; [INV]

  <bb 12> :
  _14 = (long unsigned int) mb_idx;
  _15 = FlexCAN_GetBuffStatusFlag (base, _14);
  if (_15 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  flexcan_mb_config = *flexcan_mb;
  _16 = flexcan_mb_config >> 24;
  _17 = _16 & 15;
  if (_17 == 8)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result = 0;

  <bb 15> :
  _18 = flexcan_mb_config >> 24;
  _19 = _18 & 15;
  if (_19 == 9)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  result = 3;

  <bb 17> :
  _20 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _20);
  _21 = (int) mb_idx;
  state->mbs[_21].state = 0;

  <bb 18> :
  D.11000 = result;
  timeStart = {CLOBBER};

  <bb 19> :
<L21>:
  return D.11000;

}


FlexCAN_Busoff_Error_IRQHandler (uint8 instance)
{
  boolean isSpuriousInt;
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  u32ErrStatus = 0;
  isSpuriousInt = 1;
  _3 = instance <= 5;
  DevAssert (_3);
  if (state != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 3> :
  u32ErrStatus = pBase->ESR1;
  _4 = u32ErrStatus & 2;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 = pBase->CTRL1;
  _6 = _5 & 16384;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  pBase->ESR1 = 2;
  _7 = state->error_callback;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _8 = state->error_callback;
  _8 (instance, 9, u32ErrStatus, state);
  u32ErrStatus = pBase->ESR1;

  <bb 7> :
  isSpuriousInt = 0;

  <bb 8> :
  _9 = u32ErrStatus & 1048576;
  if (_9 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _10 = pBase->CTRL2;
  _11 = (signed int) _10;
  if (_11 < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  pBase->ESR1 = 1048576;
  _12 = state->error_callback;
  if (_12 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _13 = state->error_callback;
  _13 (instance, 10, u32ErrStatus, state);
  u32ErrStatus = pBase->ESR1;

  <bb 12> :
  isSpuriousInt = 0;

  <bb 13> :
  _14 = u32ErrStatus & 131072;
  if (_14 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 14> :
  _15 = pBase->CTRL1;
  _16 = _15 & 2048;
  if (_16 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  pBase->ESR1 = 131072;
  _17 = state->error_callback;
  if (_17 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _18 = state->error_callback;
  _18 (instance, 13, u32ErrStatus, state);
  u32ErrStatus = pBase->ESR1;

  <bb 17> :
  isSpuriousInt = 0;

  <bb 18> :
  _19 = u32ErrStatus & 65536;
  if (_19 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  _20 = pBase->CTRL1;
  _21 = _20 & 1024;
  if (_21 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 20> :
  pBase->ESR1 = 65536;
  _22 = state->error_callback;
  if (_22 != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  _23 = state->error_callback;
  _23 (instance, 12, u32ErrStatus, state);
  u32ErrStatus = pBase->ESR1;

  <bb 22> :
  isSpuriousInt = 0;

  <bb 23> :
  _24 = u32ErrStatus & 4;
  if (_24 != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 24> :
  _25 = pBase->CTRL1;
  _26 = _25 & 32768;
  if (_26 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  pBase->ESR1 = 4;
  _27 = state->error_callback;
  if (_27 != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _28 = state->error_callback;
  _28 (instance, 11, u32ErrStatus, state);

  <bb 27> :
  isSpuriousInt = 0;

  <bb 28> :
  if (isSpuriousInt != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  pBase->ESR1 = 3866630;

  <bb 30> :
  return;

}


FlexCAN_Ip_GetControllerRxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.10948;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = instance <= 5;
  DevAssert (_2);
  _3 = base->ECR;
  _4 = _3 >> 8;
  D.10948 = (uint8) _4;

  <bb 3> :
<L0>:
  return D.10948;

}


FlexCAN_Ip_GetControllerTxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.10946;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = instance <= 5;
  DevAssert (_2);
  _3 = base->ECR;
  D.10946 = (uint8) _3;

  <bb 3> :
<L0>:
  return D.10946;

}


FlexCAN_Ip_GetErrorStatus (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint32 D.10944;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = instance <= 5;
  DevAssert (_2);
  D.10944 = base->ESR1;

  <bb 3> :
<L0>:
  return D.10944;

}


FlexCAN_Ip_ClearErrorStatus (uint8 instance, uint32 error)
{
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = instance <= 5;
  DevAssert (_2);
  base->ESR1 = error;
  return;

}


FlexCAN_IRQHandler (uint8 instance, uint32 startMbIdx, uint32 endMbIdx, boolean bEnhancedFifoExisted)
{
  uint32 mb_idx;
  boolean bIsSpuriousInt;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  uint32 flag_reg;
  uint32 u32MbHandle;

  <bb 2> :
  u32MbHandle = 0;
  flag_reg = 0;
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  bIsSpuriousInt = 1;
  mb_idx = endMbIdx;
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = endMbIdx <= 95;
  DevAssert (_4);
  if (state != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 3> :
  _5 = FlexCAN_GetMsgBuffIntStatusFlag (base, mb_idx);
  flag_reg = (uint32) _5;
  goto <bb 5>; [INV]

  <bb 4> :
  mb_idx = mb_idx + 4294967295;
  _6 = FlexCAN_GetMsgBuffIntStatusFlag (base, mb_idx);
  flag_reg = (uint32) _6;

  <bb 5> :
  if (flag_reg == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  if (mb_idx > startMbIdx)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (flag_reg != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 8> :
  bIsSpuriousInt = 0;
  u32MbHandle = mb_idx;
  _7 = state->bIsLegacyFifoEn;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  if (mb_idx <= 7)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_IRQHandlerRxFIFO (instance, mb_idx);
  u32MbHandle = 0;
  goto <bb 13>; [INV]

  <bb 11> :
  _8 = state->mbs[u32MbHandle].state;
  if (_8 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_IRQHandlerRxMB (instance, mb_idx);

  <bb 13> :
  _9 = state->mbs[u32MbHandle].state;
  if (_9 == 2)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  FlexCAN_IRQHandlerTxMB (instance, mb_idx);

  <bb 15> :
  _10 = FlexCAN_GetMsgBuffIntStatusFlag (base, mb_idx);
  if (_10 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _11 = state->mbs[u32MbHandle].state;
  if (_11 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);

  <bb 18> :
  if (bEnhancedFifoExisted != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _12 = FlexCAN_IsEnhancedRxFifoEnabled (base);
  if (_12 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 20> :
  _13 = state->transferType;
  if (_13 == 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  bIsSpuriousInt = FlexCAN_ProcessIRQHandlerEnhancedRxFIFO (instance, bIsSpuriousInt);

  <bb 22> :
  if (bIsSpuriousInt != 0)
    goto <bb 23>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 23> :
  FlexCAN_ProcessSpuriousInterruptMB (instance, startMbIdx, endMbIdx);
  goto <bb 29>; [INV]

  <bb 24> :
  mb_idx = startMbIdx;
  goto <bb 26>; [INV]

  <bb 25> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  mb_idx = mb_idx + 1;

  <bb 26> :
  if (mb_idx <= endMbIdx)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  if (bEnhancedFifoExisted != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, 28);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, 29);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, 30);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, 31);

  <bb 29> :
  return;

}


FlexCAN_CompleteRxMessageFifoData (uint8 instance)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = state->transferType;
  if (_4 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 5, 0, _5);
  _6 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 6, 0, _6);
  _7 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 7, 0, _7);

  <bb 4> :
  state->mbs[0].pMBmessage = 0B;
  state->mbs[0].state = 0;
  return;

}


FlexCAN_Ip_GetTransferStatus (uint8 instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType status;
  const struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType D.10864;
  int iftmp.6;

  <bb 2> :
  _1 = (int) instance;
  state = Flexcan_Ip_apxState[_1];
  status = 1;
  _2 = instance <= 5;
  DevAssert (_2);
  if (mb_idx <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.6 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.6 = 0;

  <bb 6> :
  _3 = (_Bool) iftmp.6;
  DevAssert (_3);
  if (mb_idx <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = (int) mb_idx;
  _5 = state->mbs[_4].state;
  if (_5 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  status = 0;
  goto <bb 13>; [INV]

  <bb 9> :
  status = 2;
  goto <bb 13>; [INV]

  <bb 10> :
  _6 = state->enhancedFifoOutput.state;
  if (_6 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  status = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  status = 2;

  <bb 13> :
  D.10864 = status;

  <bb 14> :
<L13>:
  return D.10864;

}


FlexCAN_Ip_ConfigRemoteResponseMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  const struct Flexcan_Ip_StateType * const state;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10847;

  <bb 2> :
  result = 0;
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  pMbAddr = 0B;
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = tx_info != 0B;
  DevAssert (_4);
  _5 = pBase->CTRL2;
  _6 = _5 & 131072;
  _7 = _6 == 0;
  DevAssert (_7);
  _8 = tx_info->data_length;
  _9 = (unsigned char) _8;
  _10 = (long unsigned int) mb_idx;
  _11 = FlexCAN_GetMbPayloadSize (pBase, _10);
  _12 = _9 <= _11;
  DevAssert (_12);
  _13 = state->bIsLegacyFifoEn;
  _14 = state->u32MaxMbNum;
  _15 = FlexCAN_IsMbOutOfRange (pBase, mb_idx, _13, _14);
  if (_15 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = 4;

  <bb 4> :
  if (result == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _16 = tx_info->data_length;
  cs.dataLen = _16;
  _17 = tx_info->msg_id_type;
  cs.msgIdType = _17;
  cs.code = 10;
  cs.fd_enable = 0;
  cs.enable_brs = 0;
  cs.fd_padding = 0;
  _18 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _18);
  _19 = (long unsigned int) mb_idx;
  pMbAddr = FlexCAN_GetMsgBuffRegion (pBase, _19);
  _20 = tx_info->is_remote;
  FlexCAN_SetTxMsgBuff (pMbAddr, &cs, msg_id, mb_data, _20);
  _21 = tx_info->is_polling;
  _22 = ~_21;
  if (_22 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _23 = (long unsigned int) mb_idx;
  _24 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (pBase, instance, _23, 1, _24);

  <bb 7> :
  D.10847 = result;
  cs = {CLOBBER};

  <bb 8> :
<L7>:
  return D.10847;

}


FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged (uint8 instance, const struct Flexcan_Ip_EnhancedIdTableType * id_filter_table)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10839;

  <bb 2> :
  result = 0;
  status = 0;
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = FlexCAN_IsEnabled (pBase);
  _3 = (int) _2;
  _4 = _3 != 0;
  _5 = ~_4;
  _6 = (int) _5;
  disabled = (boolean) _6;
  _7 = instance <= 5;
  DevAssert (_7);
  _8 = FlexCAN_IsEnhancedRxFifoAvailable (pBase);
  DevAssert (_8);
  _9 = id_filter_table != 0B;
  DevAssert (_9);
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _10 = ~freeze;
  if (_10 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetEnhancedRxFifoFilter (pBase, id_filter_table);

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.10839 = result;

  <bb 13> :
<L12>:
  return D.10839;

}


FlexCAN_Ip_ConfigRxFifo_Privileged (uint8 instance, Flexcan_Ip_RxFifoIdElementFormatType id_format, const struct Flexcan_Ip_IdTableType * id_filter_table)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10823;

  <bb 2> :
  _1 = instance <= 5;
  DevAssert (_1);
  result = 0;
  status = 0;
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  freeze = FlexCAN_IsFreezeMode (pBase);
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result = 1;

  <bb 7> :
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxFifoFilter (pBase, id_format, id_filter_table);

  <bb 9> :
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status = FlexCAN_Disable (pBase);
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = status;

  <bb 12> :
  D.10823 = result;

  <bb 13> :
<L12>:
  return D.10823;

}


FlexCAN_Ip_RxFifoBlocking (uint8 instance, struct Flexcan_Ip_MsgBuffType * data, uint32 timeout)
{
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10809;

  <bb 2> :
  result = 0;
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = instance <= 5;
  DevAssert (_2);
  _3 = FlexCAN_IsEnhancedRxFifoAvailable (base);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  _4 = FlexCAN_IsEnhancedRxFifoEnabled (base);
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  result = FlexCAN_StartRxMessageEnhancedFifoData (instance, data);
  if (result == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  result = FlexCAN_ProccessEnhancedRxFifo (instance, timeout);
  goto <bb 10>; [INV]

  <bb 6> :
  result = FlexCAN_StartRxMessageFifoData (instance, data);
  if (result == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  result = FlexCAN_ProccessLegacyRxFIFO (instance, timeout);
  goto <bb 10>; [INV]

  <bb 8> :
  result = FlexCAN_StartRxMessageFifoData (instance, data);
  if (result == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  result = FlexCAN_ProccessLegacyRxFIFO (instance, timeout);

  <bb 10> :
  D.10809 = result;

  <bb 11> :
<L12>:
  return D.10809;

}


FlexCAN_Ip_RxFifo (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10793;

  <bb 2> :
  result = 0;
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = (int) instance;
  base = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnhancedRxFifoAvailable (base);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _4 = FlexCAN_IsEnhancedRxFifoEnabled (base);
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result = FlexCAN_StartRxMessageEnhancedFifoData (instance, data);
  goto <bb 7>; [INV]

  <bb 5> :
  result = FlexCAN_StartRxMessageFifoData (instance, data);
  goto <bb 7>; [INV]

  <bb 6> :
  result = FlexCAN_StartRxMessageFifoData (instance, data);

  <bb 7> :
  D.10793 = result;

  <bb 8> :
<L6>:
  return D.10793;

}


FlexCAN_Ip_ReceiveBlocking (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling, uint32 u32TimeoutMs)
{
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10784;
  long unsigned int D.10770;

  <bb 2> :
  timeStart = 0;
  timeElapsed = 0;
  _1 = u32TimeoutMs * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_1, 0);
  _2 = instance <= 5;
  DevAssert (_2);
  _3 = (int) instance;
  state = Flexcan_Ip_apxState[_3];
  _4 = (int) instance;
  base = Flexcan_Ip_apxBase[_4];
  result = FlexCAN_StartRxMessageBufferData (instance, mb_idx, data, isPolling);
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _5 = ~isPolling;
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = (long unsigned int) mb_idx;
  _7 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (base, instance, _6, 1, _7);

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _8 = OsIf_GetCounter (0);
  timeStart = _8;
  goto <bb 12>; [INV]

  <bb 7> :
  if (isPolling != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _9 = (long unsigned int) mb_idx;
  _10 = FlexCAN_GetBuffStatusFlag (base, _9);
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _11 = (long unsigned int) mb_idx;
  FlexCAN_IRQHandlerRxMB (instance, _11);

  <bb 10> :
  D.10770 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.10770 + timeElapsed;
  if (timeElapsed >= mS2Ticks)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result = 3;
  goto <bb 13>; [INV]

  <bb 12> :
  _12 = (int) mb_idx;
  _13 = state->mbs[_12].state;
  if (_13 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  if (result == 3)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _14 = ~isPolling;
  if (_14 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _15 = (long unsigned int) mb_idx;
  _16 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, _15, 0, _16);

  <bb 16> :
  if (result != 4)
    goto <bb 17>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 17> :
  if (result != 2)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  _17 = (int) mb_idx;
  _18 = state->mbs[_17].state;
  if (_18 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  result = 0;
  goto <bb 21>; [INV]

  <bb 20> :
  _19 = (int) mb_idx;
  state->mbs[_19].state = 0;
  result = 3;

  <bb 21> :
  D.10784 = result;
  timeStart = {CLOBBER};

  <bb 22> :
<L27>:
  return D.10784;

}


FlexCAN_Ip_Receive (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10758;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  result = FlexCAN_StartRxMessageBufferData (instance, mb_idx, data, isPolling);
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _4 = ~isPolling;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _5 = (long unsigned int) mb_idx;
  _6 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (base, instance, _5, 1, _6);

  <bb 5> :
  D.10758 = result;

  <bb 6> :
<L4>:
  return D.10758;

}


FlexCAN_Ip_ConfigRxMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * rx_info, uint32 msg_id)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10751;

  <bb 2> :
  eResult = 0;
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = rx_info != 0B;
  DevAssert (_4);
  _5 = state->bIsLegacyFifoEn;
  _6 = state->u32MaxMbNum;
  _7 = FlexCAN_IsMbOutOfRange (base, mb_idx, _5, _6);
  if (_7 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult = 4;
  goto <bb 5>; [INV]

  <bb 4> :
  _8 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _8);
  _9 = rx_info->data_length;
  cs.dataLen = _9;
  _10 = rx_info->msg_id_type;
  cs.msgIdType = _10;
  _11 = rx_info->fd_enable;
  cs.fd_enable = _11;
  cs.code = 15;
  _12 = (long unsigned int) mb_idx;
  FlexCAN_SetRxMsgBuff (base, _12, &cs, msg_id);
  cs.code = 0;
  _13 = (long unsigned int) mb_idx;
  FlexCAN_SetRxMsgBuff (base, _13, &cs, msg_id);
  cs.code = 4;
  _14 = (long unsigned int) mb_idx;
  FlexCAN_SetRxMsgBuff (base, _14, &cs, msg_id);

  <bb 5> :
  D.10751 = eResult;
  cs = {CLOBBER};

  <bb 6> :
<L4>:
  return D.10751;

}


FlexCAN_Ip_Send (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10744;

  <bb 2> :
  result = 1;
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = tx_info != 0B;
  DevAssert (_4);
  _5 = FlexCAN_IsListenOnlyModeEnabled (base);
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  result = FlexCAN_StartSendData (instance, mb_idx, tx_info, msg_id, mb_data);
  if (result == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _7 = tx_info->is_polling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _9 = (long unsigned int) mb_idx;
  _10 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (base, instance, _9, 1, _10);

  <bb 6> :
  D.10744 = result;

  <bb 7> :
<L6>:
  return D.10744;

}


FlexCAN_Ip_Init_Privileged (uint8 Flexcan_Ip_u8Instance, struct Flexcan_Ip_StateType * Flexcan_Ip_pState, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  uint32 i;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10736;

  <bb 2> :
  eResult = 0;
  _1 = (int) Flexcan_Ip_u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = Flexcan_Ip_u8Instance <= 5;
  DevAssert (_2);
  _3 = Flexcan_Ip_pData != 0B;
  DevAssert (_3);
  eResult = FlexCAN_InitController (Flexcan_Ip_u8Instance, pBase, Flexcan_Ip_pData);
  if (eResult == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  FlexCAN_InitBaudrate (pBase, Flexcan_Ip_pData);
  _4 = Flexcan_Ip_pData->flexcanMode;
  FlexCAN_SetOperationMode (pBase, _4);
  i = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  Flexcan_Ip_pState->mbs[i].isPolling = 1;
  Flexcan_Ip_pState->mbs[i].pMBmessage = 0B;
  Flexcan_Ip_pState->mbs[i].state = 0;
  Flexcan_Ip_pState->mbs[i].time_stamp = 0;
  i = i + 1;

  <bb 5> :
  if (i <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  Flexcan_Ip_pState->enhancedFifoOutput.isPolling = 1;
  Flexcan_Ip_pState->enhancedFifoOutput.state = 0;
  _5 = Flexcan_Ip_pData->transfer_type;
  Flexcan_Ip_pState->transferType = _5;
  _6 = Flexcan_Ip_pData->Callback;
  Flexcan_Ip_pState->callback = _6;
  Flexcan_Ip_pState->callbackParam = 0B;
  _7 = Flexcan_Ip_pData->ErrorCallback;
  Flexcan_Ip_pState->error_callback = _7;
  Flexcan_Ip_pState->errorCallbackParam = 0B;
  _8 = Flexcan_Ip_pData->is_rx_fifo_needed;
  Flexcan_Ip_pState->bIsLegacyFifoEn = _8;
  _9 = Flexcan_Ip_pData->is_enhanced_rx_fifo_needed;
  Flexcan_Ip_pState->bIsEnhancedFifoEn = _9;
  _10 = Flexcan_Ip_pData->max_num_mb;
  Flexcan_Ip_pState->u32MaxMbNum = _10;
  Flexcan_Ip_pState->isIntActive = 1;
  _11 = (int) Flexcan_Ip_u8Instance;
  Flexcan_Ip_apxState[_11] = Flexcan_Ip_pState;

  <bb 7> :
  D.10736 = eResult;

  <bb 8> :
<L5>:
  return D.10736;

}


FlexCAN_AbortRxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 val2;
  uint32 val1;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  val1 = 0;
  val2 = 0;
  flexcan_mb_config = 0;
  flexcan_mb = 0B;
  _3 = (int) mb_idx;
  state->mbs[_3].state = 0;
  _4 = state->bIsLegacyFifoEn;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _5 = pBase->CTRL2;
  _6 = _5 >> 24;
  val1 = _6 & 15;
  val2 = RxFifoOcuppiedLastMsgBuff (val1);
  _7 = (long unsigned int) mb_idx;
  if (val2 < _7)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _8 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (pBase, _8);
  flexcan_mb_config = *flexcan_mb;
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  flexcan_mb_config = flexcan_mb_config;
  *flexcan_mb = flexcan_mb_config;
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  flexcan_mb_config = flexcan_mb_config | 67108864;
  *flexcan_mb = flexcan_mb_config;

  <bb 5> :
  if (mb_idx == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _9 = state->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase, u8Instance, 5, _9);
  goto <bb 8>; [INV]

  <bb 7> :
  _10 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (pBase, _10);
  flexcan_mb_config = *flexcan_mb;
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  flexcan_mb_config = flexcan_mb_config;
  *flexcan_mb = flexcan_mb_config;
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  flexcan_mb_config = flexcan_mb_config | 67108864;
  *flexcan_mb = flexcan_mb_config;

  <bb 8> :
  _11 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _11);
  return;

}


FlexCAN_AbortTxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 uS2Ticks;
  uint32 flexcan_mb_config;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.10722;
  long unsigned int D.10713;

  <bb 2> :
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  result = 0;
  timeStart = 0;
  timeElapsed = 0;
  flexcan_mb_config = 0;
  uS2Ticks = 0;
  flexcan_mb = 0B;
  _3 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (pBase, _3);
  flexcan_mb_config = *flexcan_mb;
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  flexcan_mb_config = flexcan_mb_config | 150994944;
  *flexcan_mb = flexcan_mb_config;
  uS2Ticks = OsIf_MicrosToTicks (10000, 0);
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 5>; [INV]

  <bb 3> :
  D.10713 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.10713 + timeElapsed;
  if (timeElapsed >= uS2Ticks)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result = 3;
  goto <bb 6>; [INV]

  <bb 5> :
  _5 = (long unsigned int) mb_idx;
  _6 = FlexCAN_GetBuffStatusFlag (pBase, _5);
  if (_6 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (result != 3)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  flexcan_mb_config = *flexcan_mb;
  _7 = flexcan_mb_config >> 24;
  _8 = _7 & 15;
  if (_8 == 8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  result = 5;

  <bb 9> :
  _9 = flexcan_mb_config >> 24;
  _10 = _9 & 15;
  if (_10 == 9)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result = 0;

  <bb 11> :
  _11 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _11);
  _12 = (int) mb_idx;
  state->mbs[_12].state = 0;
  D.10722 = result;
  timeStart = {CLOBBER};

  <bb 12> :
<L12>:
  return D.10722;

}


FlexCAN_IRQHandlerEnhancedRxFIFO (uint8 instance, uint32 intType)
{
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  switch (intType) <default: <L18> [INV], case 28: <L0> [INV], case 29: <L9> [INV], case 30: <L12> [INV], case 31: <L15> [INV]>

  <bb 3> :
<L0>:
  _3 = state->enhancedFifoOutput.state;
  if (_3 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  _4 = state->enhancedFifoOutput.pMBmessage;
  if (_4 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  state->enhancedFifoOutput.pMBmessage = &data;

  <bb 6> :
  _5 = state->enhancedFifoOutput.pMBmessage;
  FlexCAN_ReadEnhancedRxFifo (base, _5);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, intType);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, 29);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, 30);
  state->enhancedFifoOutput.state = 0;
  _6 = state->callback;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = state->callback;
  _7 (instance, 5, 255, state);

  <bb 8> :
  _8 = state->enhancedFifoOutput.state;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_CompleteRxMessageEnhancedFifoData (instance);

  <bb 10> :
  goto <bb 21>; [INV]

  <bb 11> :
<L9>:
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, intType);
  _9 = state->callback;
  if (_9 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _10 = state->callback;
  _10 (instance, 6, 255, state);

  <bb 13> :
  goto <bb 21>; [INV]

  <bb 14> :
<L12>:
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, intType);
  _11 = state->callback;
  if (_11 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _12 = state->callback;
  _12 (instance, 7, 255, state);

  <bb 16> :
  goto <bb 21>; [INV]

  <bb 17> :
<L15>:
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, intType);
  _13 = state->callback;
  if (_13 != 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  _14 = state->callback;
  _14 (instance, 8, 255, state);

  <bb 19> :
  goto <bb 21>; [INV]

  <bb 20> :
<L18>:

  <bb 21> :
  data = {CLOBBER};
  return;

}


FlexCAN_ProcessIRQHandlerEnhancedRxFIFO (uint8 u8Instance, boolean bIsSpuriousIntPrevious)
{
  boolean bIsSpuriousInt;
  uint32 u32intType;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  boolean D.10917;

  <bb 2> :
  _1 = (int) u8Instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  u32intType = 0;
  bIsSpuriousInt = bIsSpuriousIntPrevious;
  u32intType = 31;
  goto <bb 10>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetEnhancedRxFIFOStatusFlag (base, u32intType);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  _4 = FlexCAN_GetEnhancedRxFIFOIntStatusFlag (base, u32intType);
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_IRQHandlerEnhancedRxFIFO (u8Instance, u32intType);
  bIsSpuriousInt = 0;
  goto <bb 9>; [INV]

  <bb 6> :
  if (bIsSpuriousInt != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _5 = state->enhancedFifoOutput.isPolling;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base, u32intType);

  <bb 9> :
  u32intType = u32intType + 4294967295;

  <bb 10> :
  if (u32intType > 27)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  D.10917 = bIsSpuriousInt;

  <bb 12> :
<L13>:
  return D.10917;

}


FlexCAN_ProcessSpuriousInterruptMB (uint8 instance, uint32 startMbIdx, uint32 endMbIdx)
{
  uint32 u32MbHandle;
  uint32 mb_idx;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  mb_idx = 0;
  u32MbHandle = 0;
  mb_idx = startMbIdx;
  goto <bb 12>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetBuffStatusFlag (base, mb_idx);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  _4 = FlexCAN_GetBuffStatusImask (base, mb_idx);
  if (_4 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  u32MbHandle = mb_idx;
  _5 = state->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (mb_idx <= 7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  u32MbHandle = 0;

  <bb 8> :
  _6 = state->mbs[u32MbHandle].isPolling;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  _8 = state->mbs[u32MbHandle].state;
  if (_8 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  state->mbs[u32MbHandle].state = 0;
  state->mbs[u32MbHandle].isPolling = 1;

  <bb 11> :
  mb_idx = mb_idx + 1;

  <bb 12> :
  if (mb_idx <= endMbIdx)
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  return;

}


FlexCAN_IRQHandlerRxFIFO (uint8 instance, uint32 mb_idx)
{
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = state->mbs[0].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state->mbs[0].pMBmessage = &data;

  <bb 4> :
  switch (mb_idx) <default: <L15> [INV], case 5: <L2> [INV], case 6: <L9> [INV], case 7: <L12> [INV]>

  <bb 5> :
<L2>:
  _4 = state->mbs[0].state;
  if (_4 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _5 = state->mbs[0].pMBmessage;
  FlexCAN_ReadRxFifo (base, _5);
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  state->mbs[0].state = 0;
  _6 = state->callback;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = state->callback;
  _7 (instance, 1, 0, state);

  <bb 8> :
  _8 = state->mbs[0].state;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  state->mbs[0].isPolling = 1;
  FlexCAN_CompleteRxMessageFifoData (instance);

  <bb 10> :
  goto <bb 18>; [INV]

  <bb 11> :
<L9>:
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  _9 = state->callback;
  if (_9 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _10 = state->callback;
  _10 (instance, 2, 0, state);

  <bb 13> :
  goto <bb 18>; [INV]

  <bb 14> :
<L12>:
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  _11 = state->callback;
  if (_11 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _12 = state->callback;
  _12 (instance, 3, 0, state);

  <bb 16> :
  goto <bb 18>; [INV]

  <bb 17> :
<L15>:

  <bb 18> :
  data = {CLOBBER};
  return;

}


FlexCAN_IRQHandlerTxMB (uint8 u8Instance, uint32 u32MbIdx)
{
  struct Flexcan_Ip_MsgBuffType mb;
  struct Flexcan_Ip_StateType * pState;
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance;
  pState = Flexcan_Ip_apxState[_2];
  _3 = pState->mbs[u32MbIdx].isRemote;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  FlexCAN_LockRxMsgBuff (pBase, u32MbIdx);
  FlexCAN_GetMsgBuff (pBase, u32MbIdx, &mb);
  FlexCAN_UnlockRxMsgBuff (pBase);
  _4 = mb.time_stamp;
  pState->mbs[u32MbIdx].time_stamp = _4;
  _5 = mb.cs;
  _6 = _5 >> 24;
  _7 = _6 & 15;
  if (_7 == 4)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, u32MbIdx);
  goto <bb 6>; [INV]

  <bb 5> :
  _8 = FlexCAN_GetMsgBuffTimestamp (pBase, u32MbIdx);
  pState->mbs[u32MbIdx].time_stamp = _8;
  FlexCAN_UnlockRxMsgBuff (pBase);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, u32MbIdx);

  <bb 6> :
  pState->mbs[u32MbIdx].state = 0;
  _9 = pState->callback;
  if (_9 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _10 = pState->callback;
  _10 (u8Instance, 4, u32MbIdx, pState);

  <bb 8> :
  _11 = pState->mbs[u32MbIdx].state;
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  pState->mbs[u32MbIdx].isPolling = 1;
  _12 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, u32MbIdx, 0, _12);
  goto <bb 12>; [INV]

  <bb 10> :
  _13 = pState->mbs[u32MbIdx].isPolling;
  if (_13 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _14 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, u32MbIdx, 0, _14);

  <bb 12> :
  mb = {CLOBBER};
  return;

}


FlexCAN_IRQHandlerRxMB (uint8 instance, uint32 mb_idx)
{
  boolean bCurrentIntStat;
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  bCurrentIntStat = 0;
  _3 = state->mbs[mb_idx].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state->mbs[mb_idx].pMBmessage = &data;

  <bb 4> :
  FlexCAN_LockRxMsgBuff (base, mb_idx);
  _4 = state->mbs[mb_idx].pMBmessage;
  FlexCAN_GetMsgBuff (base, mb_idx, _4);
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  FlexCAN_UnlockRxMsgBuff (base);
  state->mbs[mb_idx].state = 0;
  bCurrentIntStat = state->mbs[mb_idx].isPolling;
  _5 = state->callback;
  if (_5 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = state->callback;
  _6 (instance, 0, mb_idx, state);

  <bb 6> :
  _7 = state->mbs[mb_idx].state;
  if (_7 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _8 = state->mbs[mb_idx].isPolling;
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  state->mbs[mb_idx].isPolling = 1;
  _10 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, mb_idx, 0, _10);
  goto <bb 12>; [INV]

  <bb 9> :
  _11 = ~bCurrentIntStat;
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _12 = state->mbs[mb_idx].isPolling;
  if (_12 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _13 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, mb_idx, 0, _13);

  <bb 12> :
  data = {CLOBBER};
  return;

}


FlexCAN_StartRxMessageFifoData (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType eResult;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.10670;

  <bb 2> :
  base = 0B;
  state = 0B;
  eResult = 0;
  _1 = instance <= 5;
  DevAssert (_1);
  _2 = (int) instance;
  base = Flexcan_Ip_apxBase[_2];
  _3 = (int) instance;
  state = Flexcan_Ip_apxState[_3];
  _4 = state->bIsLegacyFifoEn;
  _5 = ~_4;
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult = 1;
  goto <bb 10>; [INV]

  <bb 4> :
  _6 = state->mbs[0].state;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  eResult = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  state->mbs[0].state = 1;
  _7 = state->transferType;
  if (_7 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  state->mbs[0].isPolling = 1;

  <bb 8> :
  state->mbs[0].pMBmessage = data;
  _8 = state->transferType;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  state->mbs[0].isPolling = 0;
  _9 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 6, 1, _9);
  _10 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 7, 1, _10);
  _11 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 5, 1, _11);

  <bb 10> :
  D.10670 = eResult;

  <bb 11> :
<L10>:
  return D.10670;

}


FlexCAN_StartSendData (uint8 Flexcan_Ip_u8Instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10657;

  <bb 2> :
  eResult = 0;
  _1 = (int) Flexcan_Ip_u8Instance;
  state = Flexcan_Ip_apxState[_1];
  _2 = (int) Flexcan_Ip_u8Instance;
  base = Flexcan_Ip_apxBase[_2];
  pMbAddr = 0B;
  _3 = Flexcan_Ip_u8Instance <= 5;
  DevAssert (_3);
  _4 = tx_info != 0B;
  DevAssert (_4);
  _5 = tx_info->data_length;
  _6 = (unsigned char) _5;
  _7 = (long unsigned int) mb_idx;
  _8 = FlexCAN_GetMbPayloadSize (base, _7);
  _9 = _6 <= _8;
  DevAssert (_9);
  _10 = state->bIsLegacyFifoEn;
  _11 = state->u32MaxMbNum;
  _12 = FlexCAN_IsMbOutOfRange (base, mb_idx, _10, _11);
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult = 4;
  goto <bb 10>; [INV]

  <bb 4> :
  _13 = (int) mb_idx;
  _14 = state->mbs[_13].state;
  if (_14 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  eResult = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  _15 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _15);
  _16 = (int) mb_idx;
  state->mbs[_16].state = 2;
  _17 = (int) mb_idx;
  state->mbs[_17].time_stamp = 0;
  _18 = (int) mb_idx;
  _19 = tx_info->is_polling;
  state->mbs[_18].isPolling = _19;
  _20 = (int) mb_idx;
  _21 = tx_info->is_remote;
  state->mbs[_20].isRemote = _21;
  _22 = tx_info->data_length;
  cs.dataLen = _22;
  _23 = tx_info->msg_id_type;
  cs.msgIdType = _23;
  _24 = tx_info->fd_enable;
  cs.fd_enable = _24;
  _25 = tx_info->fd_padding;
  cs.fd_padding = _25;
  _26 = tx_info->enable_brs;
  cs.enable_brs = _26;
  _27 = tx_info->is_remote;
  if (_27 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  cs.code = 28;
  goto <bb 9>; [INV]

  <bb 8> :
  cs.code = 12;

  <bb 9> :
  _28 = (long unsigned int) mb_idx;
  pMbAddr = FlexCAN_GetMsgBuffRegion (base, _28);
  FlexCAN_SetTxMsgBuff (pMbAddr, &cs, msg_id, mb_data, 0);

  <bb 10> :
  D.10657 = eResult;
  cs = {CLOBBER};

  <bb 11> :
<L10>:
  return D.10657;

}


FlexCAN_StartRxMessageBufferData (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10646;

  <bb 2> :
  result = 0;
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = state->bIsLegacyFifoEn;
  _5 = state->u32MaxMbNum;
  _6 = FlexCAN_IsMbOutOfRange (base, mb_idx, _4, _5);
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result = 4;
  goto <bb 7>; [INV]

  <bb 4> :
  _7 = (int) mb_idx;
  _8 = state->mbs[_7].state;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  result = 2;
  goto <bb 7>; [INV]

  <bb 6> :
  _9 = (int) mb_idx;
  state->mbs[_9].state = 1;
  _10 = (int) mb_idx;
  state->mbs[_10].pMBmessage = data;
  _11 = (int) mb_idx;
  state->mbs[_11].isPolling = isPolling;

  <bb 7> :
  D.10646 = result;

  <bb 8> :
<L6>:
  return D.10646;

}


FlexCAN_ProccessLegacyRxFIFO (uint8 u8Instance, uint32 u32TimeoutMs)
{
  uint32 u32intType;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_StateType * pState;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10605;
  long unsigned int D.10598;

  <bb 2> :
  eResult = 0;
  _1 = (int) u8Instance;
  pState = Flexcan_Ip_apxState[_1];
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  timeStart = 0;
  timeElapsed = 0;
  _3 = u32TimeoutMs * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_3, 0);
  u32intType = 0;
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 11>; [INV]

  <bb 3> :
  _5 = pState->transferType;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  u32intType = 7;
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = FlexCAN_GetBuffStatusFlag (pBase, u32intType);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_IRQHandlerRxFIFO (u8Instance, u32intType);

  <bb 7> :
  u32intType = u32intType + 4294967295;

  <bb 8> :
  if (u32intType > 4)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.10598 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.10598 + timeElapsed;
  if (timeElapsed >= mS2Ticks)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  eResult = 3;
  goto <bb 12>; [INV]

  <bb 11> :
  _7 = pState->mbs[0].state;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  if (eResult == 3)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _8 = pState->transferType;
  if (_8 != 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _9 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, 5, 0, _9);
  _10 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, 6, 0, _10);
  _11 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, 7, 0, _11);

  <bb 15> :
  _12 = pState->mbs[0].state;
  switch (_12) <default: <L18> [INV], case 0: <L17> [INV], case 1: <L16> [INV]>

  <bb 16> :
<L16>:
  pState->mbs[0].state = 0;
  goto <bb 19>; [INV]

  <bb 17> :
<L17>:
  eResult = 0;
  goto <bb 19>; [INV]

  <bb 18> :
<L18>:
  eResult = 1;

  <bb 19> :
  D.10605 = eResult;
  timeStart = {CLOBBER};

  <bb 20> :
<L21>:
  return D.10605;

}


FlexCAN_ProccessEnhancedRxFifo (uint8 u8Instance, uint32 u32TimeoutMs)
{
  uint32 u32intType;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_StateType * pState;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10589;
  long unsigned int D.10582;

  <bb 2> :
  eResult = 0;
  _1 = (int) u8Instance;
  pState = Flexcan_Ip_apxState[_1];
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  timeStart = 0;
  timeElapsed = 0;
  _3 = u32TimeoutMs * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_3, 0);
  u32intType = 0;
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 11>; [INV]

  <bb 3> :
  _5 = pState->transferType;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  u32intType = 31;
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = FlexCAN_GetEnhancedRxFIFOStatusFlag (pBase, u32intType);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_IRQHandlerEnhancedRxFIFO (u8Instance, u32intType);

  <bb 7> :
  u32intType = u32intType + 4294967295;

  <bb 8> :
  if (u32intType > 27)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.10582 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.10582 + timeElapsed;
  if (timeElapsed >= mS2Ticks)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  eResult = 3;
  goto <bb 12>; [INV]

  <bb 11> :
  _7 = pState->enhancedFifoOutput.state;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  if (eResult == 3)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _8 = pState->transferType;
  if (_8 != 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  FlexCAN_SetEnhancedRxFifoIntAll (pBase, 0);

  <bb 15> :
  _9 = pState->enhancedFifoOutput.state;
  switch (_9) <default: <L18> [INV], case 0: <L17> [INV], case 1: <L16> [INV]>

  <bb 16> :
<L16>:
  pState->enhancedFifoOutput.state = 0;
  goto <bb 19>; [INV]

  <bb 17> :
<L17>:
  eResult = 0;
  goto <bb 19>; [INV]

  <bb 18> :
<L18>:
  eResult = 1;

  <bb 19> :
  D.10589 = eResult;
  timeStart = {CLOBBER};

  <bb 20> :
<L21>:
  return D.10589;

}


FlexCAN_StartRxMessageEnhancedFifoData (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType eResult;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.10576;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  eResult = 0;
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = state->enhancedFifoOutput.state;
  if (_4 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult = 2;
  goto <bb 9>; [INV]

  <bb 4> :
  state->enhancedFifoOutput.state = 1;
  state->enhancedFifoOutput.pMBmessage = data;
  _5 = state->transferType;
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  state->enhancedFifoOutput.isPolling = 0;
  _6 = state->isIntActive;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_SetEnhancedRxFifoIntAll (base, 1);

  <bb 7> :
  _7 = state->transferType;
  if (_7 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  state->enhancedFifoOutput.isPolling = 1;

  <bb 9> :
  D.10576 = eResult;

  <bb 10> :
<L9>:
  return D.10576;

}


FlexCAN_CompleteRxMessageEnhancedFifoData (uint8 instance)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  _3 = instance <= 5;
  DevAssert (_3);
  _4 = FlexCAN_IsEnhancedRxFifoAvailable (base);
  DevAssert (_4);
  _5 = state->enhancedFifoOutput.isPolling;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state->enhancedFifoOutput.isPolling = 1;
  FlexCAN_SetEnhancedRxFifoIntAll (base, 0);

  <bb 4> :
  state->enhancedFifoOutput.pMBmessage = 0B;
  state->enhancedFifoOutput.state = 0;
  return;

}


FlexCAN_InitBaudrate (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  <bb 2> :
  _1 = Flexcan_Ip_pData->fd_enable;
  FlexCAN_EnableExtCbt (pBase, _1);
  _2 = Flexcan_Ip_pData->enhCbtEnable;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _3 = pBase->CTRL2;
  _4 = _3 | 8192;
  pBase->CTRL2 = _4;
  _5 = &Flexcan_Ip_pData->bitrate;
  FlexCAN_SetEnhancedNominalTimeSegments (pBase, _5);
  _6 = Flexcan_Ip_pData->fd_enable;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _7 = &Flexcan_Ip_pData->bitrate_cbt;
  FlexCAN_SetEnhancedDataTimeSegments (pBase, _7);
  goto <bb 8>; [INV]

  <bb 5> :
  _8 = pBase->CTRL2;
  _9 = _8 & 4294959103;
  pBase->CTRL2 = _9;
  _10 = Flexcan_Ip_pData->fd_enable;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _11 = &Flexcan_Ip_pData->bitrate;
  FlexCAN_SetExtendedTimeSegments (pBase, _11);
  _12 = &Flexcan_Ip_pData->bitrate_cbt;
  FlexCAN_SetFDTimeSegments (pBase, _12);
  goto <bb 8>; [INV]

  <bb 7> :
  _13 = &Flexcan_Ip_pData->bitrate;
  FlexCAN_SetTimeSegments (pBase, _13);

  <bb 8> :
  return;

}


FlexCAN_InitController (uint8 Instance, struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10535;

  <bb 2> :
  eResult = 0;
  _1 = FlexCAN_IsEnabled (pBase);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  eResult = FlexCAN_EnterFreezeMode (pBase);
  if (eResult == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  eResult = FlexCAN_Disable (pBase);

  <bb 5> :
  if (eResult == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _2 = pBase->MCR;
  _3 = _2 & 2147483647;
  pBase->MCR = _3;
  eResult = FlexCAN_Init (pBase);
  if (eResult != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  FlexCAN_EnterFreezeMode (pBase);
  FlexCAN_Disable (pBase);
  goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_DisableMemErrorDetection (pBase);
  _4 = Flexcan_Ip_pData->fd_enable;
  _5 = Flexcan_Ip_pData->bitRateSwitch;
  FlexCAN_SetFDEnabled (pBase, _4, _5);
  _6 = Flexcan_Ip_pData->ctrlOptions;
  FlexCAN_ConfigCtrlOptions (pBase, _6);
  FlexCAN_ResetImaskBuff (Instance);
  eResult = FlexCAN_InitCtroll (pBase, Flexcan_Ip_pData);

  <bb 9> :
  D.10535 = eResult;

  <bb 10> :
<L9>:
  return D.10535;

}


FlexCAN_InitCtroll (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10520;

  <bb 2> :
  eResult = 0;
  _1 = Flexcan_Ip_pData->flexcanMode;
  if (_1 != 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_SetSelfReception (pBase, 0);

  <bb 4> :
  eResult = FlexCAN_InitRxFifo (pBase, Flexcan_Ip_pData);
  if (eResult != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_EnterFreezeMode (pBase);
  FlexCAN_Disable (pBase);
  goto <bb 8>; [INV]

  <bb 6> :
  _2 = &Flexcan_Ip_pData->payload;
  FlexCAN_SetPayloadSize (pBase, _2);
  _3 = Flexcan_Ip_pData->max_num_mb;
  eResult = FlexCAN_SetMaxMsgBuffNum (pBase, _3);
  if (eResult != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  FlexCAN_EnterFreezeMode (pBase);
  FlexCAN_Disable (pBase);

  <bb 8> :
  D.10520 = eResult;

  <bb 9> :
<L7>:
  return D.10520;

}


FlexCAN_InitRxFifo (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10511;

  <bb 2> :
  eResult = 0;
  _1 = Flexcan_Ip_pData->is_rx_fifo_needed;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = Flexcan_Ip_pData->num_id_filters;
  eResult = FlexCAN_EnableRxFifo (pBase, _2);

  <bb 4> :
  if (eResult == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _3 = Flexcan_Ip_pData->is_enhanced_rx_fifo_needed;
  if (_3 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _4 = Flexcan_Ip_pData->num_enhanced_std_id_filters;
  _5 = Flexcan_Ip_pData->num_enhanced_ext_id_filters;
  _6 = Flexcan_Ip_pData->num_enhanced_watermark;
  eResult = FlexCAN_EnableEnhancedRxFifo (pBase, _4, _5, _6);

  <bb 7> :
  D.10511 = eResult;

  <bb 8> :
<L6>:
  return D.10511;

}


FlexCAN_SetRegDefaultVal (struct FLEXCAN_Type * base)
{
  <bb 2> :
  _1 = FlexCAN_IsEnhancedRxFifoAvailable (base);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base->ERFSR = 4160749568;
  base->ERFIER = 0;
  base->ERFCR = 0;

  <bb 4> :
  base->FDCBT = 0;
  base->FDCTRL = 2147500288;
  base->ERRSR = 851981;
  base->ERRIPPR = 0;
  base->ERRIDPR = 0;
  base->ERRIAR = 0;
  _2 = base->CTRL2;
  _3 = _2 | 536870912;
  base->CTRL2 = _3;
  _4 = base->MECR;
  _5 = _4 & 2147483647;
  base->MECR = _5;
  base->MECR = 786560;
  _6 = base->MECR;
  _7 = _6 | 2147483648;
  base->MECR = _7;
  _8 = base->CTRL2;
  _9 = _8 & 3758096383;
  base->CTRL2 = _9;
  _10 = FlexCAN_GetMaxMbNum (base);
  if (_10 > 64)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  base->IFLAG3 = 4294967295;
  base->IMASK3 = 0;

  <bb 6> :
  _11 = FlexCAN_GetMaxMbNum (base);
  if (_11 > 32)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  base->IFLAG2 = 4294967295;
  base->IMASK2 = 0;

  <bb 8> :
  base->IFLAG1 = 4294967295;
  base->IMASK1 = 0;
  base->CBT = 0;
  base->CTRL2 = 1048576;
  base->ESR1 = 241670;
  base->ECR = 0;
  base->TIMER = 0;
  base->CTRL1 = 0;
  base->EPRS = 0;
  base->ENCBT = 0;
  base->EDCBT = 0;
  base->ETDC = 0;
  base->MCR = 3633315855;
  return;

}


FlexCAN_GetEnhancedRxFIFOIntStatusFlag (const struct FLEXCAN_Type * base, uint32 intFlag)
{
  uint8 D.10919;

  <bb 2> :
  _1 = base->ERFIER;
  _2 = (unsigned char) intFlag;
  _3 = (int) _2;
  _4 = _3 & 31;
  _5 = 1 << _4;
  _6 = _1 & _5;
  _7 = (unsigned char) intFlag;
  _8 = (int) _7;
  _9 = _8 & 31;
  _10 = _6 >> _9;
  D.10919 = (uint8) _10;

  <bb 3> :
<L0>:
  return D.10919;

}


FlexCAN_ClearEnhancedRxFifoIntStatusFlag (struct FLEXCAN_Type * base, uint32 intFlag)
{
  <bb 2> :
  _1 = 1 << intFlag;
  base->ERFSR = _1;
  return;

}


FlexCAN_GetEnhancedRxFIFOStatusFlag (const struct FLEXCAN_Type * base, uint32 intFlag)
{
  uint8 D.10592;

  <bb 2> :
  _1 = base->ERFSR;
  _2 = (unsigned char) intFlag;
  _3 = (int) _2;
  _4 = _3 & 31;
  _5 = 1 << _4;
  _6 = _1 & _5;
  _7 = (unsigned char) intFlag;
  _8 = (int) _7;
  _9 = _8 & 31;
  _10 = _6 >> _9;
  D.10592 = (uint8) _10;

  <bb 3> :
<L0>:
  return D.10592;

}


FlexCAN_SetEnhancedRxFifoIntAll (struct FLEXCAN_Type * base, boolean enable)
{
  <bb 2> :
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base->ERFIER = 4026531840;
  goto <bb 5>; [INV]

  <bb 4> :
  base->ERFIER = 0;

  <bb 5> :
  return;

}


FlexCAN_IsEnhancedRxFifoEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.10795;

  <bb 2> :
  _1 = base->ERFCR;
  _2 = (signed int) _1;
  D.10795 = _2 < 0;

  <bb 3> :
<L0>:
  return D.10795;

}


FlexCAN_SetRxMaskType (struct FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
  <bb 2> :
  if (type == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = base->MCR;
  _2 = _1 & 4294901759;
  base->MCR = _2;
  goto <bb 5>; [INV]

  <bb 4> :
  _3 = base->MCR;
  _4 = _3 | 65536;
  base->MCR = _4;

  <bb 5> :
  return;

}


FlexCAN_SetTxArbitrationStartDelay (struct FLEXCAN_Type * base, uint8 tasd)
{
  <bb 2> :
  _1 = base->CTRL2;
  _2 = _1 & 4278714367;
  _3 = (long unsigned int) tasd;
  _4 = _3 << 19;
  _5 = _4 & 16252928;
  _6 = _2 | _5;
  base->CTRL2 = _6;
  return;

}


FlexCAN_IsFreezeMode (const struct FLEXCAN_Type * base)
{
  boolean D.10825;

  <bb 2> :
  _1 = base->MCR;
  _2 = _1 & 16777216;
  D.10825 = _2 != 0;

  <bb 3> :
<L0>:
  return D.10825;

}


FlexCAN_SetRxIndividualMask (struct FLEXCAN_Type * base, uint32 msgBuffIdx, uint32 mask)
{
  <bb 2> :
  base->RXIMR[msgBuffIdx] = mask;
  return;

}


FlexCAN_SetRxMsgBuffGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  base->RXMGMASK = Mask;
  return;

}


FlexCAN_GetMsgBuffIntStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 mask;
  uint8 flag;
  uint8 D.10905;

  <bb 2> :
  flag = 0;
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  mask = base->IMASK1;
  _1 = base->IFLAG1;
  _2 = mask & _1;
  _3 = msgBuffIdx & 31;
  _4 = _2 >> _3;
  _5 = (unsigned char) _4;
  flag = _5 & 1;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  mask = base->IMASK2;
  _6 = base->IFLAG2;
  _7 = mask & _6;
  _8 = msgBuffIdx & 31;
  _9 = _7 >> _8;
  _10 = (unsigned char) _9;
  flag = _10 & 1;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  mask = base->IMASK3;
  _11 = base->IFLAG3;
  _12 = mask & _11;
  _13 = msgBuffIdx & 31;
  _14 = _12 >> _13;
  _15 = (unsigned char) _14;
  flag = _15 & 1;

  <bb 8> :
  D.10905 = flag;

  <bb 9> :
<L9>:
  return D.10905;

}


RxFifoOcuppiedLastMsgBuff (uint32 x)
{
  uint32 D.10732;

  <bb 2> :
  _1 = x + 1;
  _2 = _1 * 8;
  _3 = _2 / 4;
  D.10732 = _3 + 5;

  <bb 3> :
<L0>:
  return D.10732;

}


FlexCAN_IsListenOnlyModeEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.10746;

  <bb 2> :
  _1 = base->CTRL1;
  _2 = _1 & 8;
  D.10746 = _2 != 0;

  <bb 3> :
<L0>:
  return D.10746;

}


FlexCAN_IsFDEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.11199;

  <bb 2> :
  _1 = base->MCR;
  _2 = _1 & 2048;
  D.11199 = _2 != 0;

  <bb 3> :
<L0>:
  return D.11199;

}


FlexCAN_SetSelfReception (struct FLEXCAN_Type * base, boolean enable)
{
  long unsigned int iftmp.0;

  <bb 2> :
  _1 = base->MCR;
  _2 = _1 & 4294836223;
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = 131072;

  <bb 5> :
  _3 = iftmp.0 | _2;
  base->MCR = _3;
  return;

}


FlexCAN_EnableExtCbt (struct FLEXCAN_Type * base, boolean enableCBT)
{
  long unsigned int iftmp.3;

  <bb 2> :
  _1 = base->CBT;
  _2 = _1 & 2147483647;
  if (enableCBT != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.3 = 2147483648;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.3 = 0;

  <bb 5> :
  _3 = iftmp.3 | _2;
  base->CBT = _3;
  return;

}


FlexCAN_EnhCbtEnable (struct FLEXCAN_Type * base, boolean enableCBT)
{
  long unsigned int iftmp.8;

  <bb 2> :
  _1 = base->CTRL2;
  _2 = _1 & 4294959103;
  if (enableCBT != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.8 = 8192;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.8 = 0;

  <bb 5> :
  _3 = iftmp.8 | _2;
  base->CTRL2 = _3;
  return;

}


FlexCAN_IsEnhCbtEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.11167;

  <bb 2> :
  _1 = pBase->CTRL2;
  _2 = _1 & 8192;
  D.11167 = _2 != 0;

  <bb 3> :
<L0>:
  return D.11167;

}


FlexCAN_IsExCbtEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.11157;

  <bb 2> :
  _1 = pBase->CBT;
  _2 = (signed int) _1;
  D.11157 = _2 < 0;

  <bb 3> :
<L0>:
  return D.11157;

}


FlexCAN_GetFDTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = base->FDCBT;
  _2 = _1 >> 20;
  _3 = _2 & 1023;
  timeSeg->preDivider = _3;
  _4 = base->FDCBT;
  _5 = _4 >> 10;
  _6 = _5 & 31;
  timeSeg->propSeg = _6;
  _7 = base->FDCBT;
  _8 = _7 >> 5;
  _9 = _8 & 7;
  timeSeg->phaseSeg1 = _9;
  _10 = base->FDCBT;
  _11 = _10 & 7;
  timeSeg->phaseSeg2 = _11;
  _12 = base->FDCBT;
  _13 = _12 >> 16;
  _14 = _13 & 7;
  timeSeg->rJumpwidth = _14;
  return;

}


FlexCAN_GetTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = base->CTRL1;
  _2 = _1 >> 24;
  _3 = _2 & 255;
  timeSeg->preDivider = _3;
  _4 = base->CTRL1;
  _5 = _4 & 7;
  timeSeg->propSeg = _5;
  _6 = base->CTRL1;
  _7 = _6 >> 19;
  _8 = _7 & 7;
  timeSeg->phaseSeg1 = _8;
  _9 = base->CTRL1;
  _10 = _9 >> 16;
  _11 = _10 & 7;
  timeSeg->phaseSeg2 = _11;
  _12 = base->CTRL1;
  _13 = _12 >> 22;
  _14 = _13 & 3;
  timeSeg->rJumpwidth = _14;
  return;

}


FlexCAN_GetExtendedTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = base->CBT;
  _2 = _1 >> 21;
  _3 = _2 & 1023;
  timeSeg->preDivider = _3;
  _4 = base->CBT;
  _5 = _4 >> 10;
  _6 = _5 & 63;
  timeSeg->propSeg = _6;
  _7 = base->CBT;
  _8 = _7 >> 5;
  _9 = _8 & 31;
  timeSeg->phaseSeg1 = _9;
  _10 = base->CBT;
  _11 = _10 & 31;
  timeSeg->phaseSeg2 = _11;
  _12 = base->CBT;
  _13 = _12 >> 16;
  _14 = _13 & 31;
  timeSeg->rJumpwidth = _14;
  return;

}


FlexCAN_GetEnhancedDataTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = timeSeg != 0B;
  DevAssert (_1);
  timeSeg->propSeg = 0;
  _2 = base->EDCBT;
  _3 = _2 & 31;
  timeSeg->phaseSeg1 = _3;
  _4 = base->EDCBT;
  _5 = _4 >> 12;
  _6 = _5 & 15;
  timeSeg->phaseSeg2 = _6;
  _7 = base->EDCBT;
  _8 = _7 >> 22;
  _9 = _8 & 15;
  timeSeg->rJumpwidth = _9;
  _10 = base->EPRS;
  _11 = _10 >> 16;
  _12 = _11 & 1023;
  timeSeg->preDivider = _12;
  return;

}


FlexCAN_SetEnhancedDataTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = timeSeg != 0B;
  DevAssert (_1);
  _2 = base->EDCBT;
  _3 = _2 & 4231991264;
  base->EDCBT = _3;
  _4 = base->EDCBT;
  _5 = timeSeg->phaseSeg1;
  _6 = timeSeg->propSeg;
  _7 = _5 + _6;
  _8 = _7 & 31;
  _9 = timeSeg->phaseSeg2;
  _10 = _9 << 12;
  _11 = _10 & 65535;
  _12 = _8 | _11;
  _13 = timeSeg->rJumpwidth;
  _14 = _13 << 22;
  _15 = _14 & 62914560;
  _16 = _12 | _15;
  _17 = _4 | _16;
  base->EDCBT = _17;
  _18 = base->EPRS;
  _19 = _18 & 4227923967;
  base->EPRS = _19;
  _20 = base->EPRS;
  _21 = timeSeg->preDivider;
  _22 = _21 << 16;
  _23 = _22 & 67043328;
  _24 = _20 | _23;
  base->EPRS = _24;
  return;

}


FlexCAN_GetEnhancedNominalTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  timeSeg->propSeg = 0;
  _1 = base->EPRS;
  _2 = _1 & 1023;
  timeSeg->preDivider = _2;
  _3 = base->ENCBT;
  _4 = _3 & 255;
  timeSeg->phaseSeg1 = _4;
  _5 = base->ENCBT;
  _6 = _5 >> 12;
  _7 = _6 & 127;
  timeSeg->phaseSeg2 = _7;
  _8 = base->ENCBT;
  _9 = _8 >> 22;
  _10 = _9 & 127;
  timeSeg->rJumpwidth = _10;
  return;

}


FlexCAN_SetEnhancedNominalTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = timeSeg != 0B;
  DevAssert (_1);
  _2 = base->ENCBT;
  _3 = _2 & 3761770240;
  base->ENCBT = _3;
  _4 = base->ENCBT;
  _5 = timeSeg->phaseSeg1;
  _6 = timeSeg->propSeg;
  _7 = _5 + _6;
  _8 = _7 + 1;
  _9 = _8 & 255;
  _10 = timeSeg->phaseSeg2;
  _11 = _10 << 12;
  _12 = _11 & 520192;
  _13 = _9 | _12;
  _14 = timeSeg->rJumpwidth;
  _15 = _14 << 22;
  _16 = _15 & 532676608;
  _17 = _13 | _16;
  _18 = _4 | _17;
  base->ENCBT = _18;
  _19 = base->EPRS;
  _20 = _19 & 4294966272;
  base->EPRS = _20;
  _21 = base->EPRS;
  _22 = timeSeg->preDivider;
  _23 = _22 & 1023;
  _24 = _21 | _23;
  base->EPRS = _24;
  return;

}


FlexCAN_SetExtendedTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = timeSeg != 0B;
  DevAssert (_1);
  _2 = base->CBT;
  _3 = _2 & 2147483648;
  base->CBT = _3;
  _4 = base->CBT;
  _5 = timeSeg->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 65535;
  _8 = timeSeg->phaseSeg2;
  _9 = _8 & 31;
  _10 = _7 | _9;
  _11 = timeSeg->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 992;
  _14 = _10 | _13;
  _15 = timeSeg->preDivider;
  _16 = _15 << 21;
  _17 = _16 & 2145386496;
  _18 = _14 | _17;
  _19 = timeSeg->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 2031616;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base->CBT = _23;
  return;

}


FlexCAN_SetTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = timeSeg != 0B;
  DevAssert (_1);
  _2 = base->CTRL1;
  _3 = _2 & 65528;
  base->CTRL1 = _3;
  _4 = base->CTRL1;
  _5 = timeSeg->propSeg;
  _6 = _5 & 7;
  _7 = timeSeg->phaseSeg2;
  _8 = _7 << 16;
  _9 = _8 & 458752;
  _10 = _6 | _9;
  _11 = timeSeg->phaseSeg1;
  _12 = _11 << 19;
  _13 = _12 & 3670016;
  _14 = _10 | _13;
  _15 = timeSeg->preDivider;
  _16 = _15 << 24;
  _17 = _14 | _16;
  _18 = timeSeg->rJumpwidth;
  _19 = _18 << 22;
  _20 = _19 & 12582912;
  _21 = _17 | _20;
  _22 = _4 | _21;
  base->CTRL1 = _22;
  return;

}


FlexCAN_SetFDTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  _1 = timeSeg != 0B;
  DevAssert (_1);
  _2 = base->FDCBT;
  _3 = _2 & 3221783320;
  base->FDCBT = _3;
  _4 = base->FDCBT;
  _5 = timeSeg->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 31744;
  _8 = timeSeg->phaseSeg2;
  _9 = _8 & 7;
  _10 = _7 | _9;
  _11 = timeSeg->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 255;
  _14 = _10 | _13;
  _15 = timeSeg->preDivider;
  _16 = _15 << 20;
  _17 = _16 & 1072693248;
  _18 = _14 | _17;
  _19 = timeSeg->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 458752;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base->FDCBT = _23;
  return;

}


FlexCAN_GetBuffStatusImask (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 u32Imask;
  uint8 D.10942;

  <bb 2> :
  u32Imask = 0;
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = base->IMASK1;
  _2 = msgBuffIdx & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx & 31;
  u32Imask = _4 >> _5;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = base->IMASK2;
  _7 = msgBuffIdx & 31;
  _8 = 1 << _7;
  _9 = _6 & _8;
  _10 = msgBuffIdx & 31;
  u32Imask = _9 >> _10;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _11 = base->IMASK3;
  _12 = msgBuffIdx & 31;
  _13 = 1 << _12;
  _14 = _11 & _13;
  _15 = msgBuffIdx & 31;
  u32Imask = _14 >> _15;

  <bb 8> :
  D.10942 = (uint8) u32Imask;

  <bb 9> :
<L9>:
  return D.10942;

}


FlexCAN_GetBuffStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;
  uint8 D.10617;

  <bb 2> :
  flag = 0;
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = base->IFLAG1;
  _2 = msgBuffIdx & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx & 31;
  flag = _4 >> _5;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = base->IFLAG2;
  _7 = msgBuffIdx & 31;
  _8 = 1 << _7;
  _9 = _6 & _8;
  _10 = msgBuffIdx & 31;
  flag = _9 >> _10;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _11 = base->IFLAG3;
  _12 = msgBuffIdx & 31;
  _13 = 1 << _12;
  _14 = _11 & _13;
  _15 = msgBuffIdx & 31;
  flag = _14 >> _15;

  <bb 8> :
  D.10617 = (uint8) flag;

  <bb 9> :
<L9>:
  return D.10617;

}


FlexCAN_ClearMsgBuffIntStatusFlag (struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;

  <bb 2> :
  _1 = msgBuffIdx & 31;
  flag = 1 << _1;
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base->IFLAG1 = flag;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  base->IFLAG2 = flag;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  base->IFLAG3 = flag;

  <bb 8> :
  return;

}


FlexCAN_UnlockRxMsgBuff (const struct FLEXCAN_Type * base)
{
  long unsigned int vol.5;

  <bb 2> :
  vol.5 = base->TIMER;
  return;

}


FlexCAN_SetListenOnlyMode (struct FLEXCAN_Type * base, boolean enableListenOnly)
{
  long unsigned int iftmp.10;

  <bb 2> :
  _1 = base->CTRL1;
  _2 = _1 & 4294967287;
  if (enableListenOnly != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.10 = 8;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.10 = 0;

  <bb 5> :
  _3 = iftmp.10 | _2;
  base->CTRL1 = _3;
  return;

}


FlexCAN_SetFDEnabled (struct FLEXCAN_Type * base, boolean enableFD, boolean enableBRS)
{
  long unsigned int iftmp.2;
  long unsigned int iftmp.1;

  <bb 2> :
  _1 = base->MCR;
  _2 = _1 & 4294965247;
  if (enableFD != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1 = 2048;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1 = 0;

  <bb 5> :
  _3 = iftmp.1 | _2;
  base->MCR = _3;
  _4 = base->FDCTRL;
  _5 = _4 & 2147483647;
  if (enableBRS != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  iftmp.2 = 2147483648;
  goto <bb 8>; [INV]

  <bb 7> :
  iftmp.2 = 0;

  <bb 8> :
  _6 = iftmp.2 | _5;
  base->FDCTRL = _6;
  _7 = base->FDCTRL;
  _8 = _7 & 4294926591;
  base->FDCTRL = _8;
  return;

}


FlexCAN_DisableMemErrorDetection (struct FLEXCAN_Type * base)
{
  <bb 2> :
  _1 = base->CTRL2;
  _2 = _1 | 536870912;
  base->CTRL2 = _2;
  base->MECR = 0;
  base->MECR = 0;
  _3 = base->MECR;
  _4 = _3 | 256;
  base->MECR = _4;
  _5 = base->CTRL2;
  _6 = _5 & 3758096383;
  base->CTRL2 = _6;
  return;

}


FlexCAN_IsEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.10537;

  <bb 2> :
  _1 = pBase->MCR;
  _2 = (signed int) _1;
  D.10537 = _2 >= 0;

  <bb 3> :
<L0>:
  return D.10537;

}


FlexCAN_SetEnhancedTDCOffset (struct FLEXCAN_Type * base, boolean enable, uint8 offset)
{
  uint32 tmp;

  <bb 2> :
  tmp = base->ETDC;
  tmp = tmp & 2139160575;
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  tmp = tmp | 2147483648;
  _1 = (long unsigned int) offset;
  _2 = _1 << 16;
  _3 = _2 & 8323072;
  tmp = tmp | _3;

  <bb 4> :
  base->ETDC = tmp;
  return;

}


FlexCAN_SetTDCOffset (struct FLEXCAN_Type * base, boolean enable, uint8 offset)
{
  uint32 tmp;

  <bb 2> :
  tmp = base->FDCTRL;
  tmp = tmp & 4294926591;
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  tmp = tmp | 32768;
  _1 = (long unsigned int) offset;
  _2 = _1 << 8;
  _3 = _2 & 7936;
  tmp = tmp | _3;

  <bb 4> :
  base->FDCTRL = tmp;
  return;

}


FlexCAN_SetRxFifoGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  base->RXFGMASK = Mask;
  return;

}


DevAssert (volatile boolean x)
{
  <bb 2> :
  x.4_1 = x;
  if (x.4_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0");
  goto <bb 3>; [INV]

  <bb 4> :
  return;

}


