
Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20/174 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20) @07f1d540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20/173 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20) @07f1d460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10/172 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10) @07f1d0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10/171 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10) @07f1d000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 
  Calls: 
FlexCAN_SetErrIntCmd/170 (FlexCAN_SetErrIntCmd) @07f03b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 
  Calls: 
FlexCAN_DisableInterrupts/169 (FlexCAN_DisableInterrupts) @07f038c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 
  Calls: 
FlexCAN_EnableInterrupts/168 (FlexCAN_EnableInterrupts) @07f03700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_EnableInterrupts_Privileged/114 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17/167 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17) @07f032a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17/166 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17) @07f031c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16/165 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16) @07ef1e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16/164 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16) @07ef1d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15/163 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15) @07ef17e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15/162 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15) @07ef1700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09/161 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09) @07ef1380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ClearTDCFail/105 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09/160 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09) @07ef12a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ClearTDCFail/105 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14/159 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14) @07ee1a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14/158 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14) @07ee19a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08/157 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08) @07ee1700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/102 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08/156 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08) @07ee1620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/102 
  Calls: 
SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07/155 (SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07) @07ee1380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/100 
  Calls: 
SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07/154 (SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07) @07ee12a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/100 
  Calls: 
FlexCAN_GetMaxMbNum/153 (FlexCAN_GetMaxMbNum) @07ec5b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_SetRegDefaultVal/48 FlexCAN_SetRegDefaultVal/48 
  Calls: 
FlexCAN_ExitFreezeMode/152 (FlexCAN_ExitFreezeMode) @07ec5540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStartMode_Privileged/100 FlexCAN_Ip_ExitFreezeMode_Privileged/91 
  Calls: 
FlexCAN_SetEnhancedRxFifoFilter/151 (FlexCAN_SetEnhancedRxFifoFilter) @07e8fee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 
  Calls: 
FlexCAN_SetRxFifoFilter/150 (FlexCAN_SetRxFifoFilter) @07e8fc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRxFifo_Privileged/77 
  Calls: 
FlexCAN_Enable/149 (FlexCAN_Enable) @07e8fb60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 
  Calls: 
FlexCAN_SetRxMsgBuff/148 (FlexCAN_SetRxMsgBuff) @07e8f460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_ConfigRxMb/72 
  Calls: 
FlexCAN_SetOperationMode/147 (FlexCAN_SetOperationMode) @07e8f0e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_Init_Privileged/70 
  Calls: 
FLEXCAN_ClearMsgBuffIntCmd/146 (FLEXCAN_ClearMsgBuffIntCmd) @07e78e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_AbortTransfer/117 FlexCAN_AbortRxTransfer/69 
  Calls: 
FlexCAN_ReadEnhancedRxFifo/145 (FlexCAN_ReadEnhancedRxFifo) @07e78a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerEnhancedRxFIFO/67 
  Calls: 
FlexCAN_GetMsgBuffTimestamp/144 (FlexCAN_GetMsgBuffTimestamp) @07e788c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 
  Calls: 
FlexCAN_GetMsgBuff/143 (FlexCAN_GetMsgBuff) @07e78620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 
  Calls: 
FlexCAN_LockRxMsgBuff/142 (FlexCAN_LockRxMsgBuff) @07e78540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 
  Calls: 
FlexCAN_SetTxMsgBuff/141 (FlexCAN_SetTxMsgBuff) @07e782a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_StartSendData/60 
  Calls: 
FlexCAN_GetMsgBuffRegion/140 (FlexCAN_GetMsgBuffRegion) @07e781c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_AbortRxTransfer/69 FlexCAN_AbortRxTransfer/69 FlexCAN_AbortTxTransfer/68 FlexCAN_StartSendData/60 
  Calls: 
FlexCAN_GetMbPayloadSize/139 (FlexCAN_GetMbPayloadSize) @07e780e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_StartSendData/60 
  Calls: 
FlexCAN_IsMbOutOfRange/138 (FlexCAN_IsMbOutOfRange) @07dbdee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_StartSendData/60 FlexCAN_StartRxMessageBufferData/59 
  Calls: 
FlexCAN_ReadRxFifo/137 (FlexCAN_ReadRxFifo) @07dbdc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_IRQHandlerRxFIFO/64 
  Calls: 
FlexCAN_SetMsgBuffIntCmd/136 (FlexCAN_SetMsgBuffIntCmd) @07dbd9a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 FlexCAN_Ip_Send/71 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 FlexCAN_IRQHandlerRxMB/62 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageFifoData/61 
  Calls: 
OsIf_GetElapsed/135 (OsIf_GetElapsed) @07dbd620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
OsIf_GetCounter/134 (OsIf_GetCounter) @07dbd540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
OsIf_MicrosToTicks/133 (OsIf_MicrosToTicks) @07dbd460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
FlexCAN_IsEnhancedRxFifoAvailable/132 (FlexCAN_IsEnhancedRxFifoAvailable) @07dbd000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_RxFifo/75 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_SetRegDefaultVal/48 
  Calls: 
FlexCAN_ResetImaskBuff/131 (FlexCAN_ResetImaskBuff) @04e34460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_ConfigCtrlOptions/130 (FlexCAN_ConfigCtrlOptions) @04e34380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_Init/129 (FlexCAN_Init) @04e342a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_SetMaxMsgBuffNum/128 (FlexCAN_SetMaxMsgBuffNum) @04e34000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_SetPayloadSize/127 (FlexCAN_SetPayloadSize) @07d8b7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_Disable/126 (FlexCAN_Disable) @07d8b540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_InitController/53 FlexCAN_InitController/53 FlexCAN_InitCtroll/52 FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_EnterFreezeMode/125 (FlexCAN_EnterFreezeMode) @07d8b2a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_EnterFreezeMode_Privileged/90 FlexCAN_InitController/53 FlexCAN_InitController/53 FlexCAN_InitCtroll/52 FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_EnableEnhancedRxFifo/124 (FlexCAN_EnableEnhancedRxFifo) @07d8bee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitRxFifo/51 
  Calls: 
FlexCAN_EnableRxFifo/123 (FlexCAN_EnableRxFifo) @07d8be00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: FlexCAN_InitRxFifo/51 
  Calls: 
FlexCAN_Ip_ManualBusOffRecovery/122 (FlexCAN_Ip_ManualBusOffRecovery) @07d8b9a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: OsIf_GetElapsed/135 OsIf_GetCounter/134 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20/174 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20/173 DevAssert/0 OsIf_MicrosToTicks/133 
FlexCAN_Ip_GetListenOnlyMode/121 (FlexCAN_Ip_GetListenOnlyMode) @07d8b700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsListenOnlyModeEnabled/28 
FlexCAN_Ip_SetListenOnlyMode_Privileged/120 (FlexCAN_Ip_SetListenOnlyMode_Privileged) @07d8b460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10/172 FlexCAN_SetListenOnlyMode/7 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10/171 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetRxMb15Mask_Privileged/119 (FlexCAN_Ip_SetRxMb15Mask_Privileged) @07d8b1c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetRxMb14Mask_Privileged/118 (FlexCAN_Ip_SetRxMb14Mask_Privileged) @07d7dd20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_AbortTransfer/117 (FlexCAN_Ip_AbortTransfer) @07d7d7e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_AbortRxTransfer/69 FlexCAN_AbortTxTransfer/68 FLEXCAN_ClearMsgBuffIntCmd/146 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetErrorInt_Privileged/116 (FlexCAN_Ip_SetErrorInt_Privileged) @07d7d2a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 DevAssert/0 FlexCAN_SetErrIntCmd/170 FlexCAN_IsFreezeMode/40 FlexCAN_SetErrIntCmd/170 FlexCAN_IsFreezeMode/40 FlexCAN_SetErrIntCmd/170 FlexCAN_SetErrIntCmd/170 FlexCAN_SetErrIntCmd/170 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_DisableInterrupts_Privileged/115 (FlexCAN_Ip_DisableInterrupts_Privileged) @07d7dee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 FlexCAN_DisableInterrupts/169 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_EnableInterrupts_Privileged/114 (FlexCAN_Ip_EnableInterrupts_Privileged) @07d7dc40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 FlexCAN_EnableInterrupts/168 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_ClearBuffStatusFlag/113 (FlexCAN_Ip_ClearBuffStatusFlag) @07d7d9a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 DevAssert/0 
FlexCAN_Ip_GetBuffStatusFlag/112 (FlexCAN_Ip_GetBuffStatusFlag) @07d7d700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetBuffStatusFlag/10 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 DevAssert/0 
FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 (FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged) @07d7d460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17/167 FlexCAN_SetTxArbitrationStartDelay/41 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17/166 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetTDCOffset_Privileged/110 (FlexCAN_Ip_SetTDCOffset_Privileged) @07d7d1c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16/165 FlexCAN_SetTDCOffset/2 FlexCAN_SetEnhancedTDCOffset/3 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16/164 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_GetBitrateFD/109 (FlexCAN_Ip_GetBitrateFD) @07d73d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetFDTimeSegments/21 FlexCAN_GetEnhancedDataTimeSegments/18 FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetBitrateCbt_Privileged/108 (FlexCAN_Ip_SetBitrateCbt_Privileged) @07d737e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15/163 FlexCAN_SetFDTimeSegments/12 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_SetFDEnabled/6 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15/162 FlexCAN_IsEnhCbtEnabled/23 FlexCAN_Enable/149 FlexCAN_IsFDEnabled/27 DevAssert/0 DevAssert/0 
FlexCAN_Ip_GetTDCValue/107 (FlexCAN_Ip_GetTDCValue) @07d732a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 
FlexCAN_Ip_GetTDCFail/106 (FlexCAN_Ip_GetTDCFail) @07d73ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 
FlexCAN_Ip_ClearTDCFail/105 (FlexCAN_Ip_ClearTDCFail) @07d73c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09/161 FlexCAN_IsEnhCbtEnabled/23 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09/160 DevAssert/0 
FlexCAN_Ip_GetBitrate/104 (FlexCAN_Ip_GetBitrate) @07d739a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_GetTimeSegments/20 FlexCAN_GetExtendedTimeSegments/19 FlexCAN_IsExCbtEnabled/22 FlexCAN_GetEnhancedNominalTimeSegments/16 FlexCAN_IsEnhCbtEnabled/23 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetBitrate_Privileged/103 (FlexCAN_Ip_SetBitrate_Privileged) @07d73700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14/159 FlexCAN_SetTimeSegments/13 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_IsExCbtEnabled/22 FlexCAN_SetEnhancedNominalTimeSegments/15 FlexCAN_EnhCbtEnable/24 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14/158 FlexCAN_Enable/149 DevAssert/0 DevAssert/0 
FlexCAN_Ip_SetRxMaskType_Privileged/102 (FlexCAN_Ip_SetRxMaskType_Privileged) @07d73460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08/157 FlexCAN_SetRxMaskType/42 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08/156 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetStopMode_Privileged/101 (FlexCAN_Ip_SetStopMode_Privileged) @07d731c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 DevAssert/0 
FlexCAN_Ip_SetStartMode_Privileged/100 (FlexCAN_Ip_SetStartMode_Privileged) @07ce6d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ExitFreezeMode/152 SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07/155 SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07/154 DevAssert/0 
FlexCAN_Ip_GetStartMode_Privileged/99 (FlexCAN_Ip_GetStartMode_Privileged) @07ce67e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
FlexCAN_Ip_GetStopMode_Privileged/98 (FlexCAN_Ip_GetStopMode_Privileged) @07ce62a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: 
FlexCAN_Ip_MainFunctionWrite/97 (FlexCAN_Ip_MainFunctionWrite) @07ce6ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuffTimestamp/144 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuff/143 FlexCAN_LockRxMsgBuff/142 FlexCAN_GetBuffStatusFlag/10 DevAssert/0 
   Indirect call Num speculative call targets: 0
FlexCAN_Ip_MainFunctionBusOff_Privileged/96 (FlexCAN_Ip_MainFunctionBusOff_Privileged) @07ce6c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call Num speculative call targets: 0
FlexCAN_Ip_MainFunctionRead/95 (FlexCAN_Ip_MainFunctionRead) @07ce69a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_IRQHandlerRxMB/62 FlexCAN_GetBuffStatusFlag/10 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_GetBuffStatusFlag/10 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Deinit_Privileged/94 (FlexCAN_Ip_Deinit_Privileged) @07ce6700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRegDefaultVal/48 FlexCAN_EnterFreezeMode/125 DevAssert/0 
FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 (FlexCAN_Ip_SetRxFifoGlobalMask_Privileged) @07ce6460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxFifoGlobalMask/1 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SetRxIndividualMask_Privileged/92 (FlexCAN_Ip_SetRxIndividualMask_Privileged) @07ce61c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxIndividualMask/39 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_ExitFreezeMode_Privileged/91 (FlexCAN_Ip_ExitFreezeMode_Privileged) @07cd6d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ExitFreezeMode/152 
FlexCAN_Ip_EnterFreezeMode_Privileged/90 (FlexCAN_Ip_EnterFreezeMode_Privileged) @07cd67e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_EnterFreezeMode/125 
FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 (FlexCAN_Ip_SetRxMbGlobalMask_Privileged) @07cd62a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxMsgBuffGlobalMask/38 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_SendBlocking/88 (FlexCAN_Ip_SendBlocking) @07cd6ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusFlag/10 OsIf_GetElapsed/135 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 FlexCAN_GetMsgBuffRegion/140 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusFlag/10 OsIf_GetElapsed/135 OsIf_GetCounter/134 FlexCAN_StartSendData/60 DevAssert/0 DevAssert/0 OsIf_MicrosToTicks/133 
FlexCAN_Busoff_Error_IRQHandler/87 (FlexCAN_Busoff_Error_IRQHandler) @07cd6c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
FlexCAN_Ip_GetControllerRxErrorCounter/86 (FlexCAN_Ip_GetControllerRxErrorCounter) @07cd69a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetControllerTxErrorCounter/85 (FlexCAN_Ip_GetControllerTxErrorCounter) @07cd6700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_GetErrorStatus/84 (FlexCAN_Ip_GetErrorStatus) @07cd6460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_Ip_ClearErrorStatus/83 (FlexCAN_Ip_ClearErrorStatus) @07cd61c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 
FlexCAN_IRQHandler/82 (FlexCAN_IRQHandler) @07cc7d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ProcessSpuriousInterruptMB/65 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetMsgBuffIntStatusFlag/37 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_GetMsgBuffIntStatusFlag/37 FlexCAN_GetMsgBuffIntStatusFlag/37 DevAssert/0 DevAssert/0 
FlexCAN_CompleteRxMessageFifoData/81 (FlexCAN_CompleteRxMessageFifoData) @07cc77e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandlerRxFIFO/64 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 DevAssert/0 
FlexCAN_Ip_GetTransferStatus/80 (FlexCAN_Ip_GetTransferStatus) @07cc72a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: DevAssert/0 DevAssert/0 
FlexCAN_Ip_ConfigRemoteResponseMb/79 (FlexCAN_Ip_ConfigRemoteResponseMb) @07cc7ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetTxMsgBuff/141 FlexCAN_GetMsgBuffRegion/140 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_IsMbOutOfRange/138 DevAssert/0 FlexCAN_GetMbPayloadSize/139 DevAssert/0 DevAssert/0 DevAssert/0 
FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 (FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged) @07cc7c40
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetEnhancedRxFifoFilter/151 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 DevAssert/0 DevAssert/0 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 FlexCAN_IsEnabled/4 
FlexCAN_Ip_ConfigRxFifo_Privileged/77 (FlexCAN_Ip_ConfigRxFifo_Privileged) @07cc79a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_Disable/126 FlexCAN_SetRxFifoFilter/150 FlexCAN_IsFreezeMode/40 FlexCAN_Enable/149 FlexCAN_IsEnabled/4 DevAssert/0 
FlexCAN_Ip_RxFifoBlocking/76 (FlexCAN_Ip_RxFifoBlocking) @07cc7700
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_StartRxMessageFifoData/61 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_StartRxMessageFifoData/61 FlexCAN_ProccessEnhancedRxFifo/57 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 
FlexCAN_Ip_RxFifo/75 (FlexCAN_Ip_RxFifo) @07cc7460
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_IsEnhancedRxFifoEnabled/43 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 
FlexCAN_Ip_ReceiveBlocking/74 (FlexCAN_Ip_ReceiveBlocking) @07cc71c0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 OsIf_GetElapsed/135 FlexCAN_IRQHandlerRxMB/62 FlexCAN_GetBuffStatusFlag/10 OsIf_GetCounter/134 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_StartRxMessageBufferData/59 DevAssert/0 OsIf_MicrosToTicks/133 
FlexCAN_Ip_Receive/73 (FlexCAN_Ip_Receive) @07e60d20
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_StartRxMessageBufferData/59 DevAssert/0 
FlexCAN_Ip_ConfigRxMb/72 (FlexCAN_Ip_ConfigRxMb) @07e607e0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetRxMsgBuff/148 FlexCAN_SetRxMsgBuff/148 FlexCAN_SetRxMsgBuff/148 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_IsMbOutOfRange/138 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Send/71 (FlexCAN_Ip_Send) @07e602a0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_StartSendData/60 FlexCAN_IsListenOnlyModeEnabled/28 DevAssert/0 DevAssert/0 
FlexCAN_Ip_Init_Privileged/70 (FlexCAN_Ip_Init_Privileged) @07e60ee0
  Type: function definition analyzed
  Visibility: force_output externally_visible no_reorder public
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (write) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: FlexCAN_SetOperationMode/147 FlexCAN_InitBaudrate/54 FlexCAN_InitController/53 DevAssert/0 DevAssert/0 
FlexCAN_AbortRxTransfer/69 (FlexCAN_AbortRxTransfer) @07e60c40
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_AbortTransfer/117 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetMsgBuffRegion/140 FLEXCAN_ClearMsgBuffIntCmd/146 FlexCAN_GetMsgBuffRegion/140 RxFifoOcuppiedLastMsgBuff/29 
FlexCAN_AbortTxTransfer/68 (FlexCAN_AbortTxTransfer) @07e609a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_AbortTransfer/117 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusFlag/10 OsIf_GetElapsed/135 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 FlexCAN_GetMsgBuffRegion/140 
FlexCAN_IRQHandlerEnhancedRxFIFO/67 (FlexCAN_IRQHandlerEnhancedRxFIFO) @07e60700
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_MainFunctionRead/95 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_ReadEnhancedRxFifo/145 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 (FlexCAN_ProcessIRQHandlerEnhancedRxFIFO) @07e60460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/82 
  Calls: FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_GetEnhancedRxFIFOIntStatusFlag/47 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 
FlexCAN_ProcessSpuriousInterruptMB/65 (FlexCAN_ProcessSpuriousInterruptMB) @07e601c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/82 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetBuffStatusImask/11 FlexCAN_GetBuffStatusFlag/10 
FlexCAN_IRQHandlerRxFIFO/64 (FlexCAN_IRQHandlerRxFIFO) @07e4cd20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_MainFunctionRead/95 FlexCAN_IRQHandler/82 FlexCAN_ProccessLegacyRxFIFO/58 
  Calls: FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_ReadRxFifo/137 
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
   Indirect call Num speculative call targets: 0
FlexCAN_IRQHandlerTxMB/63 (FlexCAN_IRQHandlerTxMB) @07e4c7e0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandler/82 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuffTimestamp/144 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_GetMsgBuff/143 FlexCAN_LockRxMsgBuff/142 
   Indirect call Num speculative call targets: 0
FlexCAN_IRQHandlerRxMB/62 (FlexCAN_IRQHandlerRxMB) @07e4c2a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_MainFunctionRead/95 FlexCAN_IRQHandler/82 FlexCAN_Ip_ReceiveBlocking/74 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_UnlockRxMsgBuff/8 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_GetMsgBuff/143 FlexCAN_LockRxMsgBuff/142 
   Indirect call Num speculative call targets: 0
FlexCAN_StartRxMessageFifoData/61 (FlexCAN_StartRxMessageFifoData) @07e4cee0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 FlexCAN_Ip_RxFifo/75 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 DevAssert/0 
FlexCAN_StartSendData/60 (FlexCAN_StartSendData) @07e4cc40
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_Send/71 
  Calls: FlexCAN_SetTxMsgBuff/141 FlexCAN_GetMsgBuffRegion/140 FlexCAN_ClearMsgBuffIntStatusFlag/9 FlexCAN_IsMbOutOfRange/138 DevAssert/0 FlexCAN_GetMbPayloadSize/139 DevAssert/0 DevAssert/0 
FlexCAN_StartRxMessageBufferData/59 (FlexCAN_StartRxMessageBufferData) @07e4c9a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 
  Calls: FlexCAN_IsMbOutOfRange/138 DevAssert/0 
FlexCAN_ProccessLegacyRxFIFO/58 (FlexCAN_ProccessLegacyRxFIFO) @07e4c700
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifoBlocking/76 
  Calls: FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 FlexCAN_SetMsgBuffIntCmd/136 OsIf_GetElapsed/135 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_GetBuffStatusFlag/10 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 
FlexCAN_ProccessEnhancedRxFifo/57 (FlexCAN_ProccessEnhancedRxFifo) @07e4c460
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxState/50 (read) Flexcan_Ip_apxBase/49 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 OsIf_GetElapsed/135 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_GetEnhancedRxFIFOStatusFlag/45 OsIf_GetCounter/134 OsIf_MicrosToTicks/133 
FlexCAN_StartRxMessageEnhancedFifoData/56 (FlexCAN_StartRxMessageEnhancedFifoData) @07e4c1c0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 DevAssert/0 
FlexCAN_CompleteRxMessageEnhancedFifoData/55 (FlexCAN_CompleteRxMessageEnhancedFifoData) @07c5eee0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: Flexcan_Ip_apxBase/49 (read) Flexcan_Ip_apxState/50 (read) 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_IRQHandlerEnhancedRxFIFO/67 
  Calls: FlexCAN_SetEnhancedRxFifoIntAll/44 DevAssert/0 FlexCAN_IsEnhancedRxFifoAvailable/132 DevAssert/0 
FlexCAN_InitBaudrate/54 (FlexCAN_InitBaudrate) @07c5e9a0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_Init_Privileged/70 
  Calls: FlexCAN_SetTimeSegments/13 FlexCAN_SetFDTimeSegments/12 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_SetEnhancedNominalTimeSegments/15 FlexCAN_EnableExtCbt/25 
FlexCAN_InitController/53 (FlexCAN_InitController) @07c5ee00
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_Ip_Init_Privileged/70 
  Calls: FlexCAN_InitCtroll/52 FlexCAN_ResetImaskBuff/131 FlexCAN_ConfigCtrlOptions/130 FlexCAN_SetFDEnabled/6 FlexCAN_DisableMemErrorDetection/5 FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_Init/129 FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_IsEnabled/4 
FlexCAN_InitCtroll/52 (FlexCAN_InitCtroll) @07c5eb60
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_InitController/53 
  Calls: FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_SetMaxMsgBuffNum/128 FlexCAN_SetPayloadSize/127 FlexCAN_Disable/126 FlexCAN_EnterFreezeMode/125 FlexCAN_InitRxFifo/51 FlexCAN_SetSelfReception/26 
FlexCAN_InitRxFifo/51 (FlexCAN_InitRxFifo) @07c5e8c0
  Type: function definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: FlexCAN_InitCtroll/52 
  Calls: FlexCAN_EnableEnhancedRxFifo/124 FlexCAN_EnableRxFifo/123 
Flexcan_Ip_apxState/50 (Flexcan_Ip_apxState) @07c587e0
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: FlexCAN_Ip_DisableInterrupts_Privileged/115 (read) FlexCAN_ProcessSpuriousInterruptMB/65 (read) FlexCAN_IRQHandlerTxMB/63 (read) FlexCAN_CompleteRxMessageFifoData/81 (read) FlexCAN_Ip_GetTransferStatus/80 (read) FlexCAN_CompleteRxMessageEnhancedFifoData/55 (read) FlexCAN_StartRxMessageEnhancedFifoData/56 (read) FlexCAN_StartRxMessageBufferData/59 (read) FlexCAN_StartSendData/60 (read) FlexCAN_StartRxMessageFifoData/61 (read) FlexCAN_IRQHandlerRxMB/62 (read) FlexCAN_ProccessEnhancedRxFifo/57 (read) FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 (read) FlexCAN_AbortTxTransfer/68 (read) FlexCAN_AbortRxTransfer/69 (read) FlexCAN_Ip_Init_Privileged/70 (write) FlexCAN_Ip_Send/71 (read) FlexCAN_Ip_ConfigRxMb/72 (read) FlexCAN_Ip_Receive/73 (read) FlexCAN_Ip_ReceiveBlocking/74 (read) FlexCAN_Ip_ConfigRemoteResponseMb/79 (read) FlexCAN_IRQHandlerRxFIFO/64 (read) FlexCAN_IRQHandlerEnhancedRxFIFO/67 (read) FlexCAN_Ip_EnableInterrupts_Privileged/114 (read) FlexCAN_ProccessLegacyRxFIFO/58 (read) FlexCAN_IRQHandler/82 (read) FlexCAN_Busoff_Error_IRQHandler/87 (read) FlexCAN_Ip_SendBlocking/88 (read) FlexCAN_Ip_Deinit_Privileged/94 (write) FlexCAN_Ip_MainFunctionRead/95 (read) FlexCAN_Ip_MainFunctionBusOff_Privileged/96 (read) FlexCAN_Ip_MainFunctionWrite/97 (read) FlexCAN_Ip_AbortTransfer/117 (read) 
  Availability: available
  Varpool flags:
Flexcan_Ip_apxBase/49 (Flexcan_Ip_apxBase) @07c58750
  Type: variable definition analyzed
  Visibility: force_output no_reorder prevailing_def_ironly
  References: 
  Referring: FlexCAN_Ip_GetListenOnlyMode/121 (read) FlexCAN_ProcessSpuriousInterruptMB/65 (read) FlexCAN_IRQHandlerTxMB/63 (read) FlexCAN_CompleteRxMessageFifoData/81 (read) FlexCAN_Ip_ConfigRemoteResponseMb/79 (read) FlexCAN_CompleteRxMessageEnhancedFifoData/55 (read) FlexCAN_StartRxMessageEnhancedFifoData/56 (read) FlexCAN_StartRxMessageBufferData/59 (read) FlexCAN_StartSendData/60 (read) FlexCAN_StartRxMessageFifoData/61 (read) FlexCAN_IRQHandlerRxMB/62 (read) FlexCAN_ProccessEnhancedRxFifo/57 (read) FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 (read) FlexCAN_AbortTxTransfer/68 (read) FlexCAN_AbortRxTransfer/69 (read) FlexCAN_Ip_Init_Privileged/70 (read) FlexCAN_Ip_Send/71 (read) FlexCAN_Ip_ConfigRxMb/72 (read) FlexCAN_Ip_Receive/73 (read) FlexCAN_IRQHandlerRxFIFO/64 (read) FlexCAN_Ip_ReceiveBlocking/74 (read) FlexCAN_Ip_RxFifo/75 (read) FlexCAN_Ip_ConfigRxFifo_Privileged/77 (read) FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 (read) FlexCAN_ProccessLegacyRxFIFO/58 (read) FlexCAN_IRQHandlerEnhancedRxFIFO/67 (read) FlexCAN_Ip_SetListenOnlyMode_Privileged/120 (read) FlexCAN_Ip_RxFifoBlocking/76 (read) FlexCAN_IRQHandler/82 (read) FlexCAN_Ip_ClearErrorStatus/83 (read) FlexCAN_Ip_GetErrorStatus/84 (read) FlexCAN_Ip_GetControllerTxErrorCounter/85 (read) FlexCAN_Ip_GetControllerRxErrorCounter/86 (read) FlexCAN_Busoff_Error_IRQHandler/87 (read) FlexCAN_Ip_SendBlocking/88 (read) FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 (read) FlexCAN_Ip_EnterFreezeMode_Privileged/90 (read) FlexCAN_Ip_ExitFreezeMode_Privileged/91 (read) FlexCAN_Ip_SetRxIndividualMask_Privileged/92 (read) FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 (read) FlexCAN_Ip_Deinit_Privileged/94 (read) FlexCAN_Ip_MainFunctionRead/95 (read) FlexCAN_Ip_MainFunctionBusOff_Privileged/96 (read) FlexCAN_Ip_MainFunctionWrite/97 (read) FlexCAN_Ip_GetStopMode_Privileged/98 (read) FlexCAN_Ip_GetStartMode_Privileged/99 (read) FlexCAN_Ip_SetStartMode_Privileged/100 (read) FlexCAN_Ip_SetStopMode_Privileged/101 (read) FlexCAN_Ip_SetRxMaskType_Privileged/102 (read) FlexCAN_Ip_SetBitrate_Privileged/103 (read) FlexCAN_Ip_GetBitrate/104 (read) FlexCAN_Ip_ClearTDCFail/105 (read) FlexCAN_Ip_GetTDCFail/106 (read) FlexCAN_Ip_GetTDCValue/107 (read) FlexCAN_Ip_SetBitrateCbt_Privileged/108 (read) FlexCAN_Ip_GetBitrateFD/109 (read) FlexCAN_Ip_SetTDCOffset_Privileged/110 (read) FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 (read) FlexCAN_Ip_GetBuffStatusFlag/112 (read) FlexCAN_Ip_ClearBuffStatusFlag/113 (read) FlexCAN_Ip_EnableInterrupts_Privileged/114 (read) FlexCAN_Ip_DisableInterrupts_Privileged/115 (read) FlexCAN_Ip_SetErrorInt_Privileged/116 (read) FlexCAN_Ip_AbortTransfer/117 (read) FlexCAN_Ip_SetRxMb14Mask_Privileged/118 (read) FlexCAN_Ip_SetRxMb15Mask_Privileged/119 (read) FlexCAN_Ip_ManualBusOffRecovery/122 (read) 
  Availability: available
  Varpool flags: initialized read-only const-value-known
FlexCAN_SetRegDefaultVal/48 (FlexCAN_SetRegDefaultVal) @07d59d20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_Deinit_Privileged/94 
  Calls: FlexCAN_GetMaxMbNum/153 FlexCAN_GetMaxMbNum/153 FlexCAN_IsEnhancedRxFifoAvailable/132 
FlexCAN_GetEnhancedRxFIFOIntStatusFlag/47 (FlexCAN_GetEnhancedRxFIFOIntStatusFlag) @07d592a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 
  Calls: 
FlexCAN_ClearEnhancedRxFifoIntStatusFlag/46 (FlexCAN_ClearEnhancedRxFifoIntStatusFlag) @07d59000
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 FlexCAN_IRQHandlerEnhancedRxFIFO/67 
  Calls: 
FlexCAN_GetEnhancedRxFIFOStatusFlag/45 (FlexCAN_GetEnhancedRxFIFOStatusFlag) @07d55d20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_ProcessIRQHandlerEnhancedRxFIFO/66 FlexCAN_ProccessEnhancedRxFifo/57 
  Calls: 
FlexCAN_SetEnhancedRxFifoIntAll/44 (FlexCAN_SetEnhancedRxFifoIntAll) @07d55a80
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_ProccessEnhancedRxFifo/57 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_CompleteRxMessageEnhancedFifoData/55 
  Calls: 
FlexCAN_IsEnhancedRxFifoEnabled/43 (FlexCAN_IsEnhancedRxFifoEnabled) @07d557e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_IRQHandler/82 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_Ip_RxFifo/75 
  Calls: 
FlexCAN_SetRxMaskType/42 (FlexCAN_SetRxMaskType) @07d55540
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxMaskType_Privileged/102 
  Calls: 
FlexCAN_SetTxArbitrationStartDelay/41 (FlexCAN_SetTxArbitrationStartDelay) @07d550e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 
  Calls: 
FlexCAN_IsFreezeMode/40 (FlexCAN_IsFreezeMode) @07d51d20
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 
  Calls: 
FlexCAN_SetRxIndividualMask/39 (FlexCAN_SetRxIndividualMask) @07d51a80
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxIndividualMask_Privileged/92 
  Calls: 
FlexCAN_SetRxMsgBuffGlobalMask/38 (FlexCAN_SetRxMsgBuffGlobalMask) @07d517e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 
  Calls: 
FlexCAN_GetMsgBuffIntStatusFlag/37 (FlexCAN_GetMsgBuffIntStatusFlag) @07d51540
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 
  Calls: 
RxFifoOcuppiedLastMsgBuff/29 (RxFifoOcuppiedLastMsgBuff) @07d487e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_AbortRxTransfer/69 
  Calls: 
FlexCAN_IsListenOnlyModeEnabled/28 (FlexCAN_IsListenOnlyModeEnabled) @07d48540
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetListenOnlyMode/121 FlexCAN_Ip_Send/71 
  Calls: 
FlexCAN_IsFDEnabled/27 (FlexCAN_IsFDEnabled) @07d482a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 
  Calls: 
FlexCAN_SetSelfReception/26 (FlexCAN_SetSelfReception) @07d48000
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitCtroll/52 
  Calls: 
FlexCAN_EnableExtCbt/25 (FlexCAN_EnableExtCbt) @07d45b60
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitBaudrate/54 
  Calls: 
FlexCAN_EnhCbtEnable/24 (FlexCAN_EnhCbtEnable) @07d457e0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
FlexCAN_IsEnhCbtEnabled/23 (FlexCAN_IsEnhCbtEnabled) @07d45460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_GetTDCValue/107 FlexCAN_Ip_GetTDCFail/106 FlexCAN_Ip_ClearTDCFail/105 FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_IsExCbtEnabled/22 (FlexCAN_IsExCbtEnabled) @07d451c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_SetBitrate_Privileged/103 
  Calls: 
FlexCAN_GetFDTimeSegments/21 (FlexCAN_GetFDTimeSegments) @07c88ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/109 
  Calls: 
FlexCAN_GetTimeSegments/20 (FlexCAN_GetTimeSegments) @07c88c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_GetExtendedTimeSegments/19 (FlexCAN_GetExtendedTimeSegments) @07c889a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_GetEnhancedDataTimeSegments/18 (FlexCAN_GetEnhancedDataTimeSegments) @07c88700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrateFD/109 
  Calls: DevAssert/0 
FlexCAN_SetEnhancedDataTimeSegments/17 (FlexCAN_SetEnhancedDataTimeSegments) @07c88460
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_GetEnhancedNominalTimeSegments/16 (FlexCAN_GetEnhancedNominalTimeSegments) @07c84ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBitrate/104 
  Calls: 
FlexCAN_SetEnhancedNominalTimeSegments/15 (FlexCAN_SetEnhancedNominalTimeSegments) @07c84c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_SetExtendedTimeSegments/14 (FlexCAN_SetExtendedTimeSegments) @07c84700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_SetTimeSegments/13 (FlexCAN_SetTimeSegments) @07c84000
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_SetFDTimeSegments/12 (FlexCAN_SetFDTimeSegments) @07c7e8c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_InitBaudrate/54 
  Calls: DevAssert/0 
FlexCAN_GetBuffStatusImask/11 (FlexCAN_GetBuffStatusImask) @07c7e1c0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_ProcessSpuriousInterruptMB/65 
  Calls: 
FlexCAN_GetBuffStatusFlag/10 (FlexCAN_GetBuffStatusFlag) @07c78ee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_ProccessLegacyRxFIFO/58 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_AbortTxTransfer/68 FlexCAN_ProcessSpuriousInterruptMB/65 
  Calls: 
FlexCAN_ClearMsgBuffIntStatusFlag/9 (FlexCAN_ClearMsgBuffIntStatusFlag) @07c78c40
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_IRQHandlerRxFIFO/64 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_AbortRxTransfer/69 FlexCAN_AbortTxTransfer/68 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 FlexCAN_StartSendData/60 FlexCAN_ProcessSpuriousInterruptMB/65 
  Calls: 
FlexCAN_UnlockRxMsgBuff/8 (FlexCAN_UnlockRxMsgBuff) @07c789a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerTxMB/63 FlexCAN_IRQHandlerRxMB/62 
  Calls: 
FlexCAN_SetListenOnlyMode/7 (FlexCAN_SetListenOnlyMode) @07c78620
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 
  Calls: 
FlexCAN_SetFDEnabled/6 (FlexCAN_SetFDEnabled) @07c782a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_InitController/53 
  Calls: 
FlexCAN_DisableMemErrorDetection/5 (FlexCAN_DisableMemErrorDetection) @07c74e00
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_InitController/53 
  Calls: 
FlexCAN_IsEnabled/4 (FlexCAN_IsEnabled) @07c74700
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_InitController/53 
  Calls: 
FlexCAN_SetEnhancedTDCOffset/3 (FlexCAN_SetEnhancedTDCOffset) @07c742a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
FlexCAN_SetTDCOffset/2 (FlexCAN_SetTDCOffset) @07c6dee0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetTDCOffset_Privileged/110 
  Calls: 
FlexCAN_SetRxFifoGlobalMask/1 (FlexCAN_SetRxFifoGlobalMask) @07c6db60
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 
  Calls: 
DevAssert/0 (DevAssert) @07bc19a0
  Type: function definition analyzed
  Visibility: no_reorder prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local
  Called by: FlexCAN_Ip_ManualBusOffRecovery/122 FlexCAN_Ip_SetListenOnlyMode_Privileged/120 FlexCAN_Ip_SetRxMb15Mask_Privileged/119 FlexCAN_Ip_SetRxMb14Mask_Privileged/118 FlexCAN_Ip_AbortTransfer/117 FlexCAN_Ip_AbortTransfer/117 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_SetErrorInt_Privileged/116 FlexCAN_Ip_DisableInterrupts_Privileged/115 FlexCAN_Ip_EnableInterrupts_Privileged/114 FlexCAN_Ip_ClearBuffStatusFlag/113 FlexCAN_Ip_GetBuffStatusFlag/112 FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged/111 FlexCAN_Ip_SetTDCOffset_Privileged/110 FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_GetBitrateFD/109 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_SetBitrateCbt_Privileged/108 FlexCAN_Ip_GetTDCValue/107 FlexCAN_Ip_GetTDCFail/106 FlexCAN_Ip_ClearTDCFail/105 FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_GetBitrate/104 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetBitrate_Privileged/103 FlexCAN_Ip_SetRxMaskType_Privileged/102 FlexCAN_Ip_SetStopMode_Privileged/101 FlexCAN_Ip_SetStartMode_Privileged/100 FlexCAN_Ip_MainFunctionWrite/97 FlexCAN_Ip_MainFunctionBusOff_Privileged/96 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_MainFunctionRead/95 FlexCAN_Ip_Deinit_Privileged/94 FlexCAN_Ip_SetRxFifoGlobalMask_Privileged/93 FlexCAN_Ip_SetRxIndividualMask_Privileged/92 FlexCAN_Ip_SetRxMbGlobalMask_Privileged/89 FlexCAN_Ip_SendBlocking/88 FlexCAN_Ip_SendBlocking/88 FlexCAN_Busoff_Error_IRQHandler/87 FlexCAN_Ip_GetControllerRxErrorCounter/86 FlexCAN_Ip_GetControllerTxErrorCounter/85 FlexCAN_Ip_GetErrorStatus/84 FlexCAN_Ip_ClearErrorStatus/83 FlexCAN_IRQHandler/82 FlexCAN_IRQHandler/82 FlexCAN_Ip_RxFifoBlocking/76 FlexCAN_CompleteRxMessageFifoData/81 FlexCAN_Ip_GetTransferStatus/80 FlexCAN_Ip_GetTransferStatus/80 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigRemoteResponseMb/79 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged/78 FlexCAN_Ip_ConfigRxFifo_Privileged/77 FlexCAN_Ip_RxFifo/75 FlexCAN_Ip_ReceiveBlocking/74 FlexCAN_Ip_Receive/73 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_ConfigRxMb/72 FlexCAN_Ip_Send/71 FlexCAN_Ip_Send/71 FlexCAN_Ip_Init_Privileged/70 FlexCAN_Ip_Init_Privileged/70 FlexCAN_StartRxMessageFifoData/61 FlexCAN_StartSendData/60 FlexCAN_StartSendData/60 FlexCAN_StartSendData/60 FlexCAN_StartRxMessageBufferData/59 FlexCAN_StartRxMessageEnhancedFifoData/56 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_CompleteRxMessageEnhancedFifoData/55 FlexCAN_GetEnhancedDataTimeSegments/18 FlexCAN_SetEnhancedDataTimeSegments/17 FlexCAN_SetEnhancedNominalTimeSegments/15 FlexCAN_SetExtendedTimeSegments/14 FlexCAN_SetTimeSegments/13 FlexCAN_SetFDTimeSegments/12 
  Calls: 
FlexCAN_Ip_ManualBusOffRecovery (uint8 Instance)
{
  Flexcan_Ip_StatusType RetVal;
  uint32 uS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * Base;
  Flexcan_Ip_StatusType D.11352;
  long unsigned int D.11349;
  int _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _35;
  Flexcan_Ip_StatusType _38;

  <bb 2> :
  _1 = (int) Instance_18(D);
  Base_20 = Flexcan_Ip_apxBase[_1];
  timeStart = 0;
  timeElapsed_22 = 0;
  uS2Ticks_24 = OsIf_MicrosToTicks (10000, 0);
  RetVal_25 = 1;
  _2 = Instance_18(D) <= 5;
  DevAssert (_2);
  _3 ={v} Base_20->CTRL1;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  RetVal_27 = 0;
  _5 ={v} Base_20->ESR1;
  _6 = _5 & 32;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20 ();
  _7 ={v} Base_20->CTRL1;
  _8 = _7 & 4294967231;
  Base_20->CTRL1 ={v} _8;
  _9 ={v} Base_20->CTRL1;
  _10 = _9 | 64;
  Base_20->CTRL1 ={v} _10;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20 ();
  _11 = OsIf_GetCounter (0);
  timeStart = _11;
  goto <bb 7>; [INV]

  <bb 5> :
  _35 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_36 = _35 + timeElapsed_14;
  if (timeElapsed_36 >= uS2Ticks_24)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  RetVal_37 = 3;
  goto <bb 8>; [INV]

  <bb 7> :
  # timeElapsed_14 = PHI <timeElapsed_22(4), timeElapsed_36(5)>
  _12 ={v} Base_20->ESR1;
  _13 = _12 & 32;
  if (_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # RetVal_15 = PHI <RetVal_25(2), RetVal_27(3), RetVal_37(6), RetVal_27(7)>
  _38 = RetVal_15;
  timeStart ={v} {CLOBBER};

  <bb 9> :
<L10>:
  return _38;

}


FlexCAN_Ip_GetListenOnlyMode (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.11343;
  int _1;
  boolean _6;

  <bb 2> :
  _1 = (int) instance_2(D);
  base_4 = Flexcan_Ip_apxBase[_1];
  _6 = FlexCAN_IsListenOnlyModeEnabled (base_4);

  <bb 3> :
<L0>:
  return _6;

}


FlexCAN_Ip_SetListenOnlyMode_Privileged (uint8 instance, const boolean enable)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11337;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _35;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10 ();
  FlexCAN_SetListenOnlyMode (pBase_20, enable_29(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10 ();

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_33 = FlexCAN_Disable (pBase_20);
  if (status_33 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_34 = status_33;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_34(11)>
  _35 = result_11;

  <bb 13> :
<L12>:
  return _35;

}


FlexCAN_Ip_SetRxMb15Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11323;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  freeze_21 = 0;
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_23 = (boolean) _7;
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_25 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_25(3)>
  freeze_27 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_27;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_28 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_28(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  pBase_20->RX15MASK ={v} mask_29(D);

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_20);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_SetRxMb14Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11309;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  freeze_21 = 0;
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_23 = (boolean) _7;
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_25 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_25(3)>
  freeze_27 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_27;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_28 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_28(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  pBase_20->RX14MASK ={v} mask_29(D);

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_20);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_AbortTransfer (uint8 u8Instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType result;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11295;
  int iftmp.9;
  _Bool _1;
  _Bool _2;
  int _3;
  int _4;
  int _5;
  <unnamed type> _6;
  long unsigned int _7;
  _Bool _8;
  int _9;
  <unnamed type> _10;
  int _11;
  <unnamed type> _12;
  int iftmp.9_15;
  int iftmp.9_22;
  int iftmp.9_23;
  Flexcan_Ip_StatusType _33;

  <bb 2> :
  _1 = u8Instance_18(D) <= 5;
  DevAssert (_1);
  if (mb_idx_21(D) <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_21(D) == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.9_23 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.9_22 = 0;

  <bb 6> :
  # iftmp.9_15 = PHI <iftmp.9_23(4), iftmp.9_22(5)>
  _2 = (_Bool) iftmp.9_15;
  DevAssert (_2);
  _3 = (int) u8Instance_18(D);
  pBase_25 = Flexcan_Ip_apxBase[_3];
  _4 = (int) u8Instance_18(D);
  state_26 = Flexcan_Ip_apxState[_4];
  result_27 = 0;
  if (mb_idx_21(D) <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 7> :
  _5 = (int) mb_idx_21(D);
  _6 ={v} state_26->mbs[_5].state;
  if (_6 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  result_32 = 5;
  goto <bb 13>; [INV]

  <bb 9> :
  _7 = (long unsigned int) mb_idx_21(D);
  _8 = state_26->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase_25, u8Instance_18(D), _7, _8);
  _9 = (int) mb_idx_21(D);
  _10 ={v} state_26->mbs[_9].state;
  if (_10 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result_30 = FlexCAN_AbortTxTransfer (u8Instance_18(D), mb_idx_21(D));

  <bb 11> :
  # result_13 = PHI <result_27(9), result_30(10)>
  _11 = (int) mb_idx_21(D);
  _12 ={v} state_26->mbs[_11].state;
  if (_12 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_AbortRxTransfer (u8Instance_18(D), mb_idx_21(D));

  <bb 13> :
  # result_14 = PHI <result_27(6), result_32(8), result_13(11), result_13(12)>
  _33 = result_14;

  <bb 14> :
<L13>:
  return _33;

}


FlexCAN_Ip_SetErrorInt_Privileged (uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11279;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  Flexcan_Ip_StatusType _47;

  <bb 2> :
  _1 = u8Instance_22(D) <= 5;
  DevAssert (_1);
  result_25 = 0;
  status_26 = 0;
  _2 = (int) u8Instance_22(D);
  pBase_27 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_27);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_29 = (boolean) _7;
  if (disabled_29 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_31 = FlexCAN_Enable (pBase_27);

  <bb 4> :
  # result_12 = PHI <result_25(2), result_31(3)>
  if (result_12 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 5> :
  switch (type_32(D)) <default: <L14> [INV], case 0: <L6> [INV], case 1: <L10> [INV], case 2: <L4> [INV], case 3: <L5> [INV], case 4: <L3> [INV]>

  <bb 6> :
<L3>:
  FlexCAN_SetErrIntCmd (pBase_27, 32768, enable_33(D));
  goto <bb 18>; [INV]

  <bb 7> :
<L4>:
  FlexCAN_SetErrIntCmd (pBase_27, 16384, enable_33(D));
  goto <bb 18>; [INV]

  <bb 8> :
<L5>:
  FlexCAN_SetErrIntCmd (pBase_27, 16385, enable_33(D));
  goto <bb 18>; [INV]

  <bb 9> :
<L6>:
  _8 = FlexCAN_IsFreezeMode (pBase_27);
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result_42 = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetErrIntCmd (pBase_27, 1024, enable_33(D));

  <bb 12> :
  # result_13 = PHI <result_42(10), result_12(11)>
  goto <bb 18>; [INV]

  <bb 13> :
<L10>:
  _10 = FlexCAN_IsFreezeMode (pBase_27);
  _11 = ~_10;
  if (_11 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_39 = 1;
  goto <bb 16>; [INV]

  <bb 15> :
  FlexCAN_SetErrIntCmd (pBase_27, 2048, enable_33(D));

  <bb 16> :
  # result_14 = PHI <result_39(14), result_12(15)>
  goto <bb 18>; [INV]

  <bb 17> :
<L14>:
  DevAssert (0);

  <bb 18> :
  # result_15 = PHI <result_12(4), result_12(6), result_12(7), result_12(8), result_13(12), result_14(16), result_12(17)>
  if (disabled_29 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  status_45 = FlexCAN_Disable (pBase_27);
  if (status_45 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  result_46 = status_45;

  <bb 21> :
  # result_16 = PHI <result_15(18), result_15(19), result_46(20)>
  _47 = result_16;

  <bb 22> :
<L21>:
  return _47;

}


FlexCAN_Ip_DisableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11263;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  Flexcan_Ip_StatusType _23;

  <bb 2> :
  _1 = (int) u8Instance_10(D);
  pBase_12 = Flexcan_Ip_apxBase[_1];
  result_13 = 1;
  _2 = (int) u8Instance_10(D);
  state_14 = Flexcan_Ip_apxState[_2];
  _3 = u8Instance_10(D) <= 5;
  DevAssert (_3);
  _4 = FlexCAN_IsEnabled (pBase_12);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  FlexCAN_DisableInterrupts (pBase_12);
  _5 = FlexCAN_IsEnhancedRxFifoAvailable (pBase_12);
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _6 = FlexCAN_IsEnhancedRxFifoEnabled (pBase_12);
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_SetEnhancedRxFifoIntAll (pBase_12, 0);

  <bb 6> :
  state_14->isIntActive = 0;
  result_22 = 0;

  <bb 7> :
  # result_7 = PHI <result_13(2), result_22(6)>
  _23 = result_7;

  <bb 8> :
<L6>:
  return _23;

}


FlexCAN_Ip_EnableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11255;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  _Bool _8;
  Flexcan_Ip_StatusType _25;

  <bb 2> :
  _1 = (int) u8Instance_12(D);
  pBase_14 = Flexcan_Ip_apxBase[_1];
  result_15 = 1;
  _2 = (int) u8Instance_12(D);
  state_16 = Flexcan_Ip_apxState[_2];
  _3 = u8Instance_12(D) <= 5;
  DevAssert (_3);
  _4 = FlexCAN_IsEnabled (pBase_14);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  FlexCAN_EnableInterrupts (pBase_14, u8Instance_12(D));
  _5 = state_16->enhancedFifoOutput.isPolling;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _7 = FlexCAN_IsEnhancedRxFifoAvailable (pBase_14);
  if (_7 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _8 = FlexCAN_IsEnhancedRxFifoEnabled (pBase_14);
  if (_8 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_SetEnhancedRxFifoIntAll (pBase_14, 1);

  <bb 7> :
  state_16->isIntActive = 1;
  result_24 = 0;

  <bb 8> :
  # result_9 = PHI <result_15(2), result_24(7)>
  _25 = result_9;

  <bb 9> :
<L8>:
  return _25;

}


FlexCAN_Ip_ClearBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  struct FLEXCAN_Type * pBase;
  _Bool _1;
  int _2;
  long unsigned int _3;

  <bb 2> :
  _1 = instance_5(D) <= 5;
  DevAssert (_1);
  _2 = (int) instance_5(D);
  pBase_8 = Flexcan_Ip_apxBase[_2];
  if (msgBuffIdx_9(D) == 255)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (pBase_8, 30);
  goto <bb 5>; [INV]

  <bb 4> :
  _3 = (long unsigned int) msgBuffIdx_9(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_8, _3);

  <bb 5> :
  return;

}


FlexCAN_Ip_GetBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  const struct FLEXCAN_Type * pBase;
  boolean returnResult;
  boolean D.11242;
  _Bool _1;
  int _2;
  unsigned char _3;
  long unsigned int _4;
  unsigned char _5;
  boolean _18;

  <bb 2> :
  returnResult_8 = 1;
  _1 = instance_9(D) <= 5;
  DevAssert (_1);
  _2 = (int) instance_9(D);
  pBase_12 = Flexcan_Ip_apxBase[_2];
  if (msgBuffIdx_13(D) == 255)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetEnhancedRxFIFOStatusFlag (pBase_12, 30);
  returnResult_17 = _3 == 1;
  goto <bb 5>; [INV]

  <bb 4> :
  _4 = (long unsigned int) msgBuffIdx_13(D);
  _5 = FlexCAN_GetBuffStatusFlag (pBase_12, _4);
  returnResult_15 = _5 == 1;

  <bb 5> :
  # returnResult_6 = PHI <returnResult_17(3), returnResult_15(4)>
  _18 = returnResult_6;

  <bb 6> :
<L3>:
  return _18;

}


FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (uint8 instance, uint8 value)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11237;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _35;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17 ();
  FlexCAN_SetTxArbitrationStartDelay (pBase_20, value_29(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17 ();

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_33 = FlexCAN_Disable (pBase_20);
  if (status_33 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_34 = status_33;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_34(11)>
  _35 = result_11;

  <bb 13> :
<L12>:
  return _35;

}


FlexCAN_Ip_SetTDCOffset_Privileged (uint8 instance, boolean enable, uint8 offset)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11219;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  long unsigned int _9;
  long unsigned int _10;
  Flexcan_Ip_StatusType _40;

  <bb 2> :
  _1 = instance_18(D) <= 5;
  DevAssert (_1);
  result_21 = 0;
  status_22 = 0;
  _2 = (int) instance_18(D);
  pBase_23 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_23);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_25 = (boolean) _7;
  if (disabled_25 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_27 = FlexCAN_Enable (pBase_23);

  <bb 4> :
  # result_11 = PHI <result_21(2), result_27(3)>
  freeze_29 = FlexCAN_IsFreezeMode (pBase_23);
  _8 = ~freeze_29;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_11 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_30 = 1;

  <bb 7> :
  # result_12 = PHI <result_11(4), result_11(5), result_30(6)>
  if (result_12 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16 ();
  _9 ={v} pBase_23->CTRL2;
  _10 = _9 & 8192;
  if (_10 == 8192)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_SetEnhancedTDCOffset (pBase_23, enable_32(D), offset_33(D));
  goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_SetTDCOffset (pBase_23, enable_32(D), offset_33(D));

  <bb 11> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16 ();

  <bb 12> :
  if (disabled_25 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  status_38 = FlexCAN_Disable (pBase_23);
  if (status_38 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_39 = status_38;

  <bb 15> :
  # result_13 = PHI <result_12(12), result_12(13), result_39(14)>
  _40 = result_13;

  <bb 16> :
<L15>:
  return _40;

}


FlexCAN_Ip_GetBitrateFD (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.11202;
  _Bool _1;
  _Bool _2;
  int _3;
  boolean _16;

  <bb 2> :
  _1 = instance_5(D) <= 5;
  DevAssert (_1);
  _2 = bitrate_8(D) != 0B;
  DevAssert (_2);
  _3 = (int) instance_5(D);
  pBase_10 = Flexcan_Ip_apxBase[_3];
  enhCbt_11 = 0;
  enhCbt_13 = FlexCAN_IsEnhCbtEnabled (pBase_10);
  if (enhCbt_13 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_GetEnhancedDataTimeSegments (pBase_10, bitrate_8(D));
  goto <bb 5>; [INV]

  <bb 4> :
  FlexCAN_GetFDTimeSegments (pBase_10, bitrate_8(D));

  <bb 5> :
  _16 = enhCbt_13;

  <bb 6> :
<L3>:
  return _16;

}


FlexCAN_Ip_SetBitrateCbt_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
  boolean enhCbt;
  boolean freeze;
  boolean disabled;
  boolean fd_enable;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11195;
  _Bool _1;
  _Bool _2;
  int _3;
  long unsigned int _4;
  signed int _5;
  long unsigned int _6;
  long unsigned int _7;
  _Bool _8;
  _Bool _9;
  Flexcan_Ip_StatusType _43;

  <bb 2> :
  _1 = instance_17(D) <= 5;
  DevAssert (_1);
  _2 = bitrate_20(D) != 0B;
  DevAssert (_2);
  result_22 = 0;
  status_23 = 0;
  _3 = (int) instance_17(D);
  pBase_24 = Flexcan_Ip_apxBase[_3];
  fd_enable_26 = FlexCAN_IsFDEnabled (pBase_24);
  _4 ={v} pBase_24->MCR;
  _5 = (signed int) _4;
  disabled_27 = _5 < 0;
  if (disabled_27 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_29 = FlexCAN_Enable (pBase_24);

  <bb 4> :
  # result_10 = PHI <result_22(2), result_29(3)>
  _6 ={v} pBase_24->MCR;
  _7 = _6 & 16777216;
  freeze_30 = _7 != 0;
  _8 = ~fd_enable_26;
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _9 = ~freeze_30;
  if (_9 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (result_10 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  result_31 = 1;

  <bb 8> :
  # result_11 = PHI <result_10(5), result_10(6), result_31(7)>
  if (result_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  enhCbt_33 = FlexCAN_IsEnhCbtEnabled (pBase_24);
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15 ();
  FlexCAN_SetFDEnabled (pBase_24, fd_enable_26, bitRateSwitch_35(D));
  if (enhCbt_33 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_SetEnhancedDataTimeSegments (pBase_24, bitrate_20(D));
  goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetFDTimeSegments (pBase_24, bitrate_20(D));

  <bb 12> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15 ();

  <bb 13> :
  if (disabled_27 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  status_41 = FlexCAN_Disable (pBase_24);
  if (status_41 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  result_42 = status_41;

  <bb 16> :
  # result_12 = PHI <result_11(13), result_11(14), result_42(15)>
  _43 = result_12;

  <bb 17> :
<L15>:
  return _43;

}


FlexCAN_Ip_GetTDCValue (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  uint8 value;
  uint8 D.11178;
  _Bool _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  unsigned char _6;
  uint8 _16;

  <bb 2> :
  value_8 = 0;
  _1 = u8Instance_9(D) <= 5;
  DevAssert (_1);
  _2 = (int) u8Instance_9(D);
  pBase_12 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnhCbtEnabled (pBase_12);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 ={v} pBase_12->ETDC;
  value_15 = (uint8) _4;
  goto <bb 5>; [INV]

  <bb 4> :
  _5 ={v} pBase_12->FDCTRL;
  _6 = (unsigned char) _5;
  value_14 = _6 & 63;

  <bb 5> :
  # value_7 = PHI <value_15(3), value_14(4)>
  _16 = value_7;

  <bb 6> :
<L3>:
  return _16;

}


FlexCAN_Ip_GetTDCFail (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  boolean value;
  boolean D.11173;
  _Bool _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  boolean _17;

  <bb 2> :
  value_9 = 0;
  _1 = u8Instance_10(D) <= 5;
  DevAssert (_1);
  _2 = (int) u8Instance_10(D);
  pBase_13 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnhCbtEnabled (pBase_13);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 ={v} pBase_13->ETDC;
  _5 = _4 & 32768;
  value_16 = _5 == 32768;
  goto <bb 5>; [INV]

  <bb 4> :
  _6 ={v} pBase_13->FDCTRL;
  _7 = _6 & 16384;
  value_15 = _7 == 16384;

  <bb 5> :
  # value_8 = PHI <value_16(3), value_15(4)>
  _17 = value_8;

  <bb 6> :
<L3>:
  return _17;

}


FlexCAN_Ip_ClearTDCFail (uint8 u8Instance)
{
  struct FLEXCAN_Type * pBase;
  _Bool _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;

  <bb 2> :
  _1 = u8Instance_9(D) <= 5;
  DevAssert (_1);
  _2 = (int) u8Instance_9(D);
  pBase_12 = Flexcan_Ip_apxBase[_2];
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09 ();
  _3 = FlexCAN_IsEnhCbtEnabled (pBase_12);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 ={v} pBase_12->ETDC;
  _5 = _4 | 32768;
  pBase_12->ETDC ={v} _5;
  goto <bb 5>; [INV]

  <bb 4> :
  _6 ={v} pBase_12->FDCTRL;
  _7 = _6 | 16384;
  pBase_12->FDCTRL ={v} _7;

  <bb 5> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09 ();
  return;

}


FlexCAN_Ip_GetBitrate (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.11163;
  _Bool _1;
  _Bool _2;
  int _3;
  _Bool _4;
  boolean _19;

  <bb 2> :
  _1 = instance_6(D) <= 5;
  DevAssert (_1);
  _2 = bitrate_9(D) != 0B;
  DevAssert (_2);
  _3 = (int) instance_6(D);
  pBase_11 = Flexcan_Ip_apxBase[_3];
  enhCbt_12 = 0;
  enhCbt_14 = FlexCAN_IsEnhCbtEnabled (pBase_11);
  if (enhCbt_14 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_GetEnhancedNominalTimeSegments (pBase_11, bitrate_9(D));
  goto <bb 7>; [INV]

  <bb 4> :
  _4 = FlexCAN_IsExCbtEnabled (pBase_11);
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_GetExtendedTimeSegments (pBase_11, bitrate_9(D));
  goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_GetTimeSegments (pBase_11, bitrate_9(D));

  <bb 7> :
  _19 = enhCbt_14;

  <bb 8> :
<L6>:
  return _19;

}


FlexCAN_Ip_SetBitrate_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11149;
  _Bool _1;
  _Bool _2;
  int _3;
  long unsigned int _4;
  signed int _5;
  long unsigned int _6;
  long unsigned int _7;
  _Bool _8;
  _Bool _9;
  Flexcan_Ip_StatusType _41;

  <bb 2> :
  _1 = instance_17(D) <= 5;
  DevAssert (_1);
  _2 = bitrate_20(D) != 0B;
  DevAssert (_2);
  result_22 = 0;
  status_23 = 0;
  _3 = (int) instance_17(D);
  pBase_24 = Flexcan_Ip_apxBase[_3];
  _4 ={v} pBase_24->MCR;
  _5 = (signed int) _4;
  disabled_25 = _5 < 0;
  if (disabled_25 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_27 = FlexCAN_Enable (pBase_24);

  <bb 4> :
  # result_10 = PHI <result_22(2), result_27(3)>
  _6 ={v} pBase_24->MCR;
  _7 = _6 & 16777216;
  freeze_28 = _7 != 0;
  _8 = ~freeze_28;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_10 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_29 = 1;

  <bb 7> :
  # result_11 = PHI <result_10(4), result_10(5), result_29(6)>
  if (result_11 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14 ();
  FlexCAN_EnhCbtEnable (pBase_24, enhExt_31(D));
  if (enhExt_31(D) != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_SetEnhancedNominalTimeSegments (pBase_24, bitrate_20(D));
  goto <bb 13>; [INV]

  <bb 10> :
  _9 = FlexCAN_IsExCbtEnabled (pBase_24);
  if (_9 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  FlexCAN_SetExtendedTimeSegments (pBase_24, bitrate_20(D));
  goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_SetTimeSegments (pBase_24, bitrate_20(D));

  <bb 13> :
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14 ();

  <bb 14> :
  if (disabled_25 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  status_39 = FlexCAN_Disable (pBase_24);
  if (status_39 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  result_40 = status_39;

  <bb 17> :
  # result_12 = PHI <result_11(14), result_11(15), result_40(16)>
  _41 = result_12;

  <bb 18> :
<L18>:
  return _41;

}


FlexCAN_Ip_SetRxMaskType_Privileged (uint8 instance, Flexcan_Ip_RxMaskType type)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11126;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _35;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08 ();
  FlexCAN_SetRxMaskType (pBase_20, type_29(D));
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08 ();

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_33 = FlexCAN_Disable (pBase_20);
  if (status_33 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_34 = status_33;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_34(11)>
  _35 = result_11;

  <bb 13> :
<L12>:
  return _35;

}


FlexCAN_Ip_SetStopMode_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType status;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11112;
  _Bool _1;
  int _2;
  Flexcan_Ip_StatusType _13;

  <bb 2> :
  _1 = instance_5(D) <= 5;
  DevAssert (_1);
  _2 = (int) instance_5(D);
  pBase_8 = Flexcan_Ip_apxBase[_2];
  status_10 = FlexCAN_EnterFreezeMode (pBase_8);
  if (status_10 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  status_12 = FlexCAN_Disable (pBase_8);

  <bb 4> :
  # status_3 = PHI <status_10(2), status_12(3)>
  _13 = status_3;

  <bb 5> :
<L2>:
  return _13;

}


FlexCAN_Ip_SetStartMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.11108;
  _Bool _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  Flexcan_Ip_StatusType _13;

  <bb 2> :
  _1 = instance_5(D) <= 5;
  DevAssert (_1);
  _2 = (int) instance_5(D);
  pBase_8 = Flexcan_Ip_apxBase[_2];
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07 ();
  _3 ={v} pBase_8->MCR;
  _4 = _3 & 2147483647;
  pBase_8->MCR ={v} _4;
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07 ();
  _13 = FlexCAN_ExitFreezeMode (pBase_8);

  <bb 3> :
<L0>:
  return _13;

}


FlexCAN_Ip_GetStartMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.11106;
  int _1;
  long unsigned int _2;
  long unsigned int _3;
  boolean _7;

  <bb 2> :
  _1 = (int) instance_4(D);
  base_6 = Flexcan_Ip_apxBase[_1];
  _2 ={v} base_6->MCR;
  _3 = _2 & 17825792;
  _7 = _3 == 0;

  <bb 3> :
<L0>:
  return _7;

}


FlexCAN_Ip_GetStopMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.11104;
  int _1;
  long unsigned int _2;
  long unsigned int _3;
  boolean _7;

  <bb 2> :
  _1 = (int) instance_4(D);
  base_6 = Flexcan_Ip_apxBase[_1];
  _2 ={v} base_6->MCR;
  _3 = _2 & 1048576;
  _7 = _3 == 1048576;

  <bb 3> :
<L0>:
  return _7;

}


FlexCAN_Ip_MainFunctionWrite (uint8 instance, uint8 mb_idx)
{
  struct Flexcan_Ip_MsgBuffType mb;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  unsigned char _5;
  int _6;
  <unnamed type> _7;
  int _8;
  _Bool _9;
  long unsigned int _10;
  long unsigned int _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  int _19;
  long unsigned int _20;
  long unsigned int _21;
  int _22;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _23;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _24;
  long unsigned int _25;

  <bb 2> :
  _1 = (int) instance_29(D);
  base_31 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_29(D);
  state_32 = Flexcan_Ip_apxState[_2];
  _3 = instance_29(D) <= 5;
  DevAssert (_3);
  _4 = (long unsigned int) mb_idx_34(D);
  _5 = FlexCAN_GetBuffStatusFlag (base_31, _4);
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  _6 = (int) mb_idx_34(D);
  _7 ={v} state_32->mbs[_6].state;
  if (_7 == 2)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  _8 = (int) mb_idx_34(D);
  _9 = state_32->mbs[_8].isRemote;
  if (_9 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _10 = (long unsigned int) mb_idx_34(D);
  FlexCAN_LockRxMsgBuff (base_31, _10);
  _11 = (long unsigned int) mb_idx_34(D);
  FlexCAN_GetMsgBuff (base_31, _11, &mb);
  FlexCAN_UnlockRxMsgBuff (base_31);
  _12 = (int) mb_idx_34(D);
  _13 = mb.time_stamp;
  state_32->mbs[_12].time_stamp = _13;
  _14 = mb.cs;
  _15 = _14 >> 24;
  _16 = _15 & 15;
  if (_16 == 4)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _17 = (long unsigned int) mb_idx_34(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_31, _17);

  <bb 7> :
  mb ={v} {CLOBBER};
  goto <bb 9>; [INV]

  <bb 8> :
  _18 = (long unsigned int) mb_idx_34(D);
  _19 = (int) mb_idx_34(D);
  _20 = FlexCAN_GetMsgBuffTimestamp (base_31, _18);
  state_32->mbs[_19].time_stamp = _20;
  FlexCAN_UnlockRxMsgBuff (base_31);
  _21 = (long unsigned int) mb_idx_34(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_31, _21);

  <bb 9> :
  _22 = (int) mb_idx_34(D);
  state_32->mbs[_22].state ={v} 0;
  _23 = state_32->callback;
  if (_23 != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _24 = state_32->callback;
  _25 = (long unsigned int) mb_idx_34(D);
  _24 (instance_29(D), 4, _25, state_32);

  <bb 11> :
  return;

}


FlexCAN_Ip_MainFunctionBusOff_Privileged (uint8 instance)
{
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType eRetVal;
  Flexcan_Ip_StatusType D.11091;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _5;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _6;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  eRetVal_10 = 1;
  _1 = (int) instance_11(D);
  base_13 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_11(D);
  state_14 = Flexcan_Ip_apxState[_2];
  u32ErrStatus_15 = 0;
  _3 = instance_11(D) <= 5;
  DevAssert (_3);
  u32ErrStatus_17 ={v} base_13->ESR1;
  _4 = u32ErrStatus_17 & 4;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _5 = state_14->error_callback;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = state_14->error_callback;
  _6 (instance_11(D), 11, u32ErrStatus_17, state_14);

  <bb 5> :
  base_13->ESR1 ={v} 4;
  eRetVal_20 = 0;

  <bb 6> :
  # eRetVal_7 = PHI <eRetVal_10(2), eRetVal_20(5)>
  _21 = eRetVal_7;

  <bb 7> :
<L4>:
  return _21;

}


FlexCAN_Ip_MainFunctionRead (uint8 instance, uint8 mb_idx)
{
  const struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  int iftmp.7;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  unsigned char _7;
  _Bool _8;
  unsigned char _9;
  long unsigned int _10;
  unsigned char _11;
  int _12;
  <unnamed type> _13;
  long unsigned int _14;
  int iftmp.7_15;
  int iftmp.7_24;
  int iftmp.7_25;

  <bb 2> :
  _1 = (int) instance_18(D);
  base_20 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_18(D);
  state_21 = Flexcan_Ip_apxState[_2];
  _3 = instance_18(D) <= 5;
  DevAssert (_3);
  if (mb_idx_23(D) <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_23(D) == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.7_25 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.7_24 = 0;

  <bb 6> :
  # iftmp.7_15 = PHI <iftmp.7_25(4), iftmp.7_24(5)>
  _4 = (_Bool) iftmp.7_15;
  DevAssert (_4);
  if (mb_idx_23(D) == 255)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  _5 = FlexCAN_IsEnhancedRxFifoAvailable (base_20);
  if (_5 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 8> :
  _6 = FlexCAN_IsEnhancedRxFifoEnabled (base_20);
  if (_6 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 9> :
  _7 = FlexCAN_GetEnhancedRxFIFOStatusFlag (base_20, 28);
  if (_7 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 10> :
  FlexCAN_IRQHandlerEnhancedRxFIFO (instance_18(D), 28);
  goto <bb 20>; [INV]

  <bb 11> :
  _8 = state_21->bIsLegacyFifoEn;
  if (_8 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 12> :
  if (mb_idx_23(D) <= 7)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  if (mb_idx_23(D) == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _9 = FlexCAN_GetBuffStatusFlag (base_20, 5);
  if (_9 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  FlexCAN_IRQHandlerRxFIFO (instance_18(D), 5);

  <bb 16> :
  goto <bb 20>; [INV]

  <bb 17> :
  _10 = (long unsigned int) mb_idx_23(D);
  _11 = FlexCAN_GetBuffStatusFlag (base_20, _10);
  if (_11 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  _12 = (int) mb_idx_23(D);
  _13 ={v} state_21->mbs[_12].state;
  if (_13 == 1)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _14 = (long unsigned int) mb_idx_23(D);
  FlexCAN_IRQHandlerRxMB (instance_18(D), _14);

  <bb 20> :
  return;

}


FlexCAN_Ip_Deinit_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.11053;
  int _1;
  _Bool _2;
  int _3;
  Flexcan_Ip_StatusType _15;

  <bb 2> :
  _1 = (int) instance_5(D);
  base_7 = Flexcan_Ip_apxBase[_1];
  result_8 = 1;
  _2 = instance_5(D) <= 5;
  DevAssert (_2);
  result_11 = FlexCAN_EnterFreezeMode (base_7);
  if (result_11 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_SetRegDefaultVal (base_7);
  FlexCAN_Disable (base_7);
  _3 = (int) instance_5(D);
  Flexcan_Ip_apxState[_3] = 0B;

  <bb 4> :
  _15 = result_11;

  <bb 5> :
<L2>:
  return _15;

}


FlexCAN_Ip_SetRxFifoGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11049;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _33;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxFifoGlobalMask (pBase_20, mask_28(D));

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_31 = FlexCAN_Disable (pBase_20);
  if (status_31 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_32 = status_31;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_32(11)>
  _33 = result_11;

  <bb 13> :
<L12>:
  return _33;

}


FlexCAN_Ip_SetRxIndividualMask_Privileged (uint8 instance, uint8 mb_idx, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11035;
  int _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  _Bool _6;
  int _7;
  _Bool _8;
  _Bool _9;
  int _10;
  _Bool _11;
  long unsigned int _12;
  Flexcan_Ip_StatusType _40;

  <bb 2> :
  result_19 = 0;
  status_20 = 0;
  _1 = (int) instance_21(D);
  pBase_23 = Flexcan_Ip_apxBase[_1];
  freeze_24 = 0;
  _2 = instance_21(D) <= 5;
  DevAssert (_2);
  _3 = (long unsigned int) mb_idx_26(D);
  _4 ={v} pBase_23->MCR;
  _5 = _4 & 127;
  if (_3 > _5)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_26(D) > 95)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result_39 = 4;
  goto <bb 15>; [INV]

  <bb 5> :
  _6 = FlexCAN_IsEnabled (pBase_23);
  _7 = (int) _6;
  _8 = _7 != 0;
  _9 = ~_8;
  _10 = (int) _9;
  disabled_28 = (boolean) _10;
  if (disabled_28 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_30 = FlexCAN_Enable (pBase_23);

  <bb 7> :
  # result_13 = PHI <result_19(5), result_30(6)>
  freeze_32 = FlexCAN_IsFreezeMode (pBase_23);
  _11 = ~freeze_32;
  if (_11 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (result_13 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  result_33 = 1;

  <bb 10> :
  # result_14 = PHI <result_13(7), result_13(8), result_33(9)>
  if (result_14 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _12 = (long unsigned int) mb_idx_26(D);
  FlexCAN_SetRxIndividualMask (pBase_23, _12, mask_34(D));

  <bb 12> :
  if (disabled_28 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  status_37 = FlexCAN_Disable (pBase_23);
  if (status_37 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_38 = status_37;

  <bb 15> :
  # result_15 = PHI <result_39(4), result_14(12), result_14(13), result_38(14)>
  _40 = result_15;

  <bb 16> :
<L16>:
  return _40;

}


FlexCAN_Ip_ExitFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.11017;
  int _1;
  Flexcan_Ip_StatusType _6;

  <bb 2> :
  _1 = (int) instance_2(D);
  base_4 = Flexcan_Ip_apxBase[_1];
  _6 = FlexCAN_ExitFreezeMode (base_4);

  <bb 3> :
<L0>:
  return _6;

}


FlexCAN_Ip_EnterFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.11015;
  int _1;
  Flexcan_Ip_StatusType _6;

  <bb 2> :
  _1 = (int) instance_2(D);
  base_4 = Flexcan_Ip_apxBase[_1];
  _6 = FlexCAN_EnterFreezeMode (base_4);

  <bb 3> :
<L0>:
  return _6;

}


FlexCAN_Ip_SetRxMbGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.11013;
  int _1;
  _Bool _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  result_15 = 0;
  status_16 = 0;
  _1 = (int) instance_17(D);
  pBase_19 = Flexcan_Ip_apxBase[_1];
  freeze_20 = 0;
  _2 = instance_17(D) <= 5;
  DevAssert (_2);
  _3 = FlexCAN_IsEnabled (pBase_19);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_23 = (boolean) _7;
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_25 = FlexCAN_Enable (pBase_19);

  <bb 4> :
  # result_9 = PHI <result_15(2), result_25(3)>
  freeze_27 = FlexCAN_IsFreezeMode (pBase_19);
  _8 = ~freeze_27;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_28 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_28(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxMsgBuffGlobalMask (pBase_19, mask_29(D));

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_19);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_SendBlocking (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data, uint32 timeout_ms)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 uS2Ticks;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10998;
  long unsigned int D.10991;
  long unsigned int D.10984;
  int _1;
  int _2;
  long unsigned int _3;
  _Bool _4;
  _Bool _5;
  long unsigned int _6;
  long unsigned int _7;
  unsigned char _8;
  int _9;
  <unnamed type> _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  unsigned char _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  int _21;
  long unsigned int _59;
  long unsigned int _76;
  Flexcan_Ip_StatusType _84;

  <bb 2> :
  _1 = (int) instance_35(D);
  base_37 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_35(D);
  state_38 = Flexcan_Ip_apxState[_2];
  timeStart = 0;
  timeElapsed_40 = 0;
  _3 = timeout_ms_41(D) * 1000;
  mS2Ticks_43 = OsIf_MicrosToTicks (_3, 0);
  uS2Ticks_44 = 0;
  flexcan_mb_config_45 = 0;
  flexcan_mb_46 = 0B;
  _4 = instance_35(D) <= 5;
  DevAssert (_4);
  _5 = tx_info_48(D) != 0B;
  DevAssert (_5);
  result_54 = FlexCAN_StartSendData (instance_35(D), mb_idx_50(D), tx_info_48(D), msg_id_51(D), mb_data_52(D));
  if (result_54 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 3> :
  _6 = OsIf_GetCounter (0);
  timeStart = _6;
  goto <bb 6>; [INV]

  <bb 4> :
  _59 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_60 = _59 + timeElapsed_27;
  if (timeElapsed_60 >= mS2Ticks_43)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  result_61 = 3;
  goto <bb 7>; [INV]

  <bb 6> :
  # timeElapsed_27 = PHI <timeElapsed_40(3), timeElapsed_60(4)>
  _7 = (long unsigned int) mb_idx_50(D);
  _8 = FlexCAN_GetBuffStatusFlag (base_37, _7);
  if (_8 != 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # result_22 = PHI <result_61(5), result_54(6)>
  if (result_22 == 3)
    goto <bb 8>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 8> :
  _9 = (int) mb_idx_50(D);
  _10 ={v} state_38->mbs[_9].state;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 9> :
  _11 = (long unsigned int) mb_idx_50(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_37, _11);
  _12 = (long unsigned int) mb_idx_50(D);
  flexcan_mb_64 = FlexCAN_GetMsgBuffRegion (base_37, _12);
  flexcan_mb_config_65 ={v} *flexcan_mb_64;
  flexcan_mb_config_66 = flexcan_mb_config_65 & 4043309055;
  flexcan_mb_config_67 = flexcan_mb_config_66 | 150994944;
  *flexcan_mb_64 ={v} flexcan_mb_config_67;
  uS2Ticks_70 = OsIf_MicrosToTicks (10000, 0);
  _13 = OsIf_GetCounter (0);
  timeStart = _13;
  timeElapsed_73 = 0;
  goto <bb 12>; [INV]

  <bb 10> :
  _76 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_77 = _76 + timeElapsed_28;
  if (timeElapsed_77 >= uS2Ticks_70)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_78 = 3;
  goto <bb 13>; [INV]

  <bb 12> :
  # timeElapsed_28 = PHI <timeElapsed_73(9), timeElapsed_77(10)>
  _14 = (long unsigned int) mb_idx_50(D);
  _15 = FlexCAN_GetBuffStatusFlag (base_37, _14);
  if (_15 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # result_23 = PHI <result_78(11), result_22(12)>
  flexcan_mb_config_79 ={v} *flexcan_mb_64;
  _16 = flexcan_mb_config_79 >> 24;
  _17 = _16 & 15;
  if (_17 == 8)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  result_80 = 0;

  <bb 15> :
  # result_24 = PHI <result_23(13), result_80(14)>
  _18 = flexcan_mb_config_79 >> 24;
  _19 = _18 & 15;
  if (_19 == 9)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  result_81 = 3;

  <bb 17> :
  # result_25 = PHI <result_22(7), result_22(8), result_24(15), result_81(16)>
  _20 = (long unsigned int) mb_idx_50(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_37, _20);
  _21 = (int) mb_idx_50(D);
  state_38->mbs[_21].state ={v} 0;

  <bb 18> :
  # result_26 = PHI <result_54(2), result_25(17)>
  _84 = result_26;
  timeStart ={v} {CLOBBER};

  <bb 19> :
<L21>:
  return _84;

}


FlexCAN_Busoff_Error_IRQHandler (uint8 instance)
{
  boolean isSpuriousInt;
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _7;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _8;
  long unsigned int _9;
  long unsigned int _10;
  signed int _11;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _12;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _17;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _22;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _27;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _28;

  <bb 2> :
  _1 = (int) instance_53(D);
  pBase_55 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_53(D);
  state_56 = Flexcan_Ip_apxState[_2];
  u32ErrStatus_57 = 0;
  isSpuriousInt_58 = 1;
  _3 = instance_53(D) <= 5;
  DevAssert (_3);
  if (state_56 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 3> :
  u32ErrStatus_60 ={v} pBase_55->ESR1;
  _4 = u32ErrStatus_60 & 2;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 ={v} pBase_55->CTRL1;
  _6 = _5 & 16384;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  pBase_55->ESR1 ={v} 2;
  _7 = state_56->error_callback;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _8 = state_56->error_callback;
  _8 (instance_53(D), 9, u32ErrStatus_60, state_56);
  u32ErrStatus_63 ={v} pBase_55->ESR1;

  <bb 7> :
  # u32ErrStatus_29 = PHI <u32ErrStatus_60(5), u32ErrStatus_63(6)>
  isSpuriousInt_64 = 0;

  <bb 8> :
  # u32ErrStatus_30 = PHI <u32ErrStatus_60(3), u32ErrStatus_60(4), u32ErrStatus_29(7)>
  # isSpuriousInt_37 = PHI <isSpuriousInt_58(3), isSpuriousInt_58(4), isSpuriousInt_64(7)>
  _9 = u32ErrStatus_30 & 1048576;
  if (_9 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _10 ={v} pBase_55->CTRL2;
  _11 = (signed int) _10;
  if (_11 < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  pBase_55->ESR1 ={v} 1048576;
  _12 = state_56->error_callback;
  if (_12 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _13 = state_56->error_callback;
  _13 (instance_53(D), 10, u32ErrStatus_30, state_56);
  u32ErrStatus_67 ={v} pBase_55->ESR1;

  <bb 12> :
  # u32ErrStatus_31 = PHI <u32ErrStatus_30(10), u32ErrStatus_67(11)>
  isSpuriousInt_68 = 0;

  <bb 13> :
  # u32ErrStatus_32 = PHI <u32ErrStatus_30(8), u32ErrStatus_30(9), u32ErrStatus_31(12)>
  # isSpuriousInt_38 = PHI <isSpuriousInt_37(8), isSpuriousInt_37(9), isSpuriousInt_68(12)>
  _14 = u32ErrStatus_32 & 131072;
  if (_14 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 14> :
  _15 ={v} pBase_55->CTRL1;
  _16 = _15 & 2048;
  if (_16 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  pBase_55->ESR1 ={v} 131072;
  _17 = state_56->error_callback;
  if (_17 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _18 = state_56->error_callback;
  _18 (instance_53(D), 13, u32ErrStatus_32, state_56);
  u32ErrStatus_71 ={v} pBase_55->ESR1;

  <bb 17> :
  # u32ErrStatus_33 = PHI <u32ErrStatus_32(15), u32ErrStatus_71(16)>
  isSpuriousInt_72 = 0;

  <bb 18> :
  # u32ErrStatus_34 = PHI <u32ErrStatus_32(13), u32ErrStatus_32(14), u32ErrStatus_33(17)>
  # isSpuriousInt_39 = PHI <isSpuriousInt_38(13), isSpuriousInt_38(14), isSpuriousInt_72(17)>
  _19 = u32ErrStatus_34 & 65536;
  if (_19 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  _20 ={v} pBase_55->CTRL1;
  _21 = _20 & 1024;
  if (_21 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 20> :
  pBase_55->ESR1 ={v} 65536;
  _22 = state_56->error_callback;
  if (_22 != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  _23 = state_56->error_callback;
  _23 (instance_53(D), 12, u32ErrStatus_34, state_56);
  u32ErrStatus_75 ={v} pBase_55->ESR1;

  <bb 22> :
  # u32ErrStatus_35 = PHI <u32ErrStatus_34(20), u32ErrStatus_75(21)>
  isSpuriousInt_76 = 0;

  <bb 23> :
  # u32ErrStatus_36 = PHI <u32ErrStatus_34(18), u32ErrStatus_34(19), u32ErrStatus_35(22)>
  # isSpuriousInt_40 = PHI <isSpuriousInt_39(18), isSpuriousInt_39(19), isSpuriousInt_76(22)>
  _24 = u32ErrStatus_36 & 4;
  if (_24 != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 24> :
  _25 ={v} pBase_55->CTRL1;
  _26 = _25 & 32768;
  if (_26 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  pBase_55->ESR1 ={v} 4;
  _27 = state_56->error_callback;
  if (_27 != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _28 = state_56->error_callback;
  _28 (instance_53(D), 11, u32ErrStatus_36, state_56);

  <bb 27> :
  isSpuriousInt_79 = 0;

  <bb 28> :
  # isSpuriousInt_41 = PHI <isSpuriousInt_58(2), isSpuriousInt_40(23), isSpuriousInt_40(24), isSpuriousInt_79(27)>
  if (isSpuriousInt_41 != 0)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  pBase_55->ESR1 ={v} 3866630;

  <bb 30> :
  return;

}


FlexCAN_Ip_GetControllerRxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.10946;
  int _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  uint8 _9;

  <bb 2> :
  _1 = (int) instance_5(D);
  base_7 = Flexcan_Ip_apxBase[_1];
  _2 = instance_5(D) <= 5;
  DevAssert (_2);
  _3 ={v} base_7->ECR;
  _4 = _3 >> 8;
  _9 = (uint8) _4;

  <bb 3> :
<L0>:
  return _9;

}


FlexCAN_Ip_GetControllerTxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.10944;
  int _1;
  _Bool _2;
  long unsigned int _3;
  uint8 _8;

  <bb 2> :
  _1 = (int) instance_4(D);
  base_6 = Flexcan_Ip_apxBase[_1];
  _2 = instance_4(D) <= 5;
  DevAssert (_2);
  _3 ={v} base_6->ECR;
  _8 = (uint8) _3;

  <bb 3> :
<L0>:
  return _8;

}


FlexCAN_Ip_GetErrorStatus (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint32 D.10942;
  int _1;
  _Bool _2;
  uint32 _7;

  <bb 2> :
  _1 = (int) instance_3(D);
  base_5 = Flexcan_Ip_apxBase[_1];
  _2 = instance_3(D) <= 5;
  DevAssert (_2);
  _7 ={v} base_5->ESR1;

  <bb 3> :
<L0>:
  return _7;

}


FlexCAN_Ip_ClearErrorStatus (uint8 instance, uint32 error)
{
  struct FLEXCAN_Type * base;
  int _1;
  _Bool _2;

  <bb 2> :
  _1 = (int) instance_3(D);
  base_5 = Flexcan_Ip_apxBase[_1];
  _2 = instance_3(D) <= 5;
  DevAssert (_2);
  base_5->ESR1 ={v} error_7(D);
  return;

}


FlexCAN_IRQHandler (uint8 instance, uint32 startMbIdx, uint32 endMbIdx, boolean bEnhancedFifoExisted)
{
  uint32 mb_idx;
  boolean bIsSpuriousInt;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  uint32 flag_reg;
  uint32 u32MbHandle;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  unsigned char _5;
  unsigned char _6;
  _Bool _7;
  <unnamed type> _8;
  <unnamed type> _9;
  unsigned char _10;
  <unnamed type> _11;
  _Bool _12;
  <unnamed type> _13;

  <bb 2> :
  u32MbHandle_27 = 0;
  flag_reg_28 = 0;
  _1 = (int) instance_29(D);
  base_31 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_29(D);
  state_32 = Flexcan_Ip_apxState[_2];
  bIsSpuriousInt_33 = 1;
  mb_idx_35 = endMbIdx_34(D);
  _3 = instance_29(D) <= 5;
  DevAssert (_3);
  _4 = endMbIdx_34(D) <= 95;
  DevAssert (_4);
  if (state_32 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 3> :
  _5 = FlexCAN_GetMsgBuffIntStatusFlag (base_31, mb_idx_35);
  flag_reg_48 = (uint32) _5;
  goto <bb 5>; [INV]

  <bb 4> :
  mb_idx_49 = mb_idx_18 + 4294967295;
  _6 = FlexCAN_GetMsgBuffIntStatusFlag (base_31, mb_idx_49);
  flag_reg_51 = (uint32) _6;

  <bb 5> :
  # flag_reg_15 = PHI <flag_reg_48(3), flag_reg_51(4)>
  # mb_idx_18 = PHI <mb_idx_35(3), mb_idx_49(4)>
  if (flag_reg_15 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  if (mb_idx_18 > startMbIdx_38(D))
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (flag_reg_15 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 8> :
  bIsSpuriousInt_52 = 0;
  u32MbHandle_53 = mb_idx_18;
  _7 = state_32->bIsLegacyFifoEn;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  if (mb_idx_18 <= 7)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  FlexCAN_IRQHandlerRxFIFO (instance_29(D), mb_idx_18);
  u32MbHandle_55 = 0;
  goto <bb 13>; [INV]

  <bb 11> :
  _8 ={v} state_32->mbs[u32MbHandle_53].state;
  if (_8 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  FlexCAN_IRQHandlerRxMB (instance_29(D), mb_idx_18);

  <bb 13> :
  # u32MbHandle_14 = PHI <u32MbHandle_55(10), u32MbHandle_53(11), u32MbHandle_53(12)>
  _9 ={v} state_32->mbs[u32MbHandle_14].state;
  if (_9 == 2)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  FlexCAN_IRQHandlerTxMB (instance_29(D), mb_idx_18);

  <bb 15> :
  _10 = FlexCAN_GetMsgBuffIntStatusFlag (base_31, mb_idx_18);
  if (_10 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _11 ={v} state_32->mbs[u32MbHandle_14].state;
  if (_11 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base_31, mb_idx_18);

  <bb 18> :
  # bIsSpuriousInt_16 = PHI <bIsSpuriousInt_33(7), bIsSpuriousInt_52(15), bIsSpuriousInt_52(16), bIsSpuriousInt_52(17)>
  if (bEnhancedFifoExisted_40(D) != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _12 = FlexCAN_IsEnhancedRxFifoEnabled (base_31);
  if (_12 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 20> :
  _13 = state_32->transferType;
  if (_13 == 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  bIsSpuriousInt_62 = FlexCAN_ProcessIRQHandlerEnhancedRxFIFO (instance_29(D), bIsSpuriousInt_16);

  <bb 22> :
  # bIsSpuriousInt_17 = PHI <bIsSpuriousInt_16(18), bIsSpuriousInt_16(19), bIsSpuriousInt_16(20), bIsSpuriousInt_62(21)>
  if (bIsSpuriousInt_17 != 0)
    goto <bb 23>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 23> :
  FlexCAN_ProcessSpuriousInterruptMB (instance_29(D), startMbIdx_38(D), endMbIdx_34(D));
  goto <bb 29>; [INV]

  <bb 24> :
  mb_idx_39 = startMbIdx_38(D);
  goto <bb 26>; [INV]

  <bb 25> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base_31, mb_idx_19);
  mb_idx_46 = mb_idx_19 + 1;

  <bb 26> :
  # mb_idx_19 = PHI <mb_idx_39(24), mb_idx_46(25)>
  if (mb_idx_19 <= endMbIdx_34(D))
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  if (bEnhancedFifoExisted_40(D) != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_31, 28);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_31, 29);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_31, 30);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_31, 31);

  <bb 29> :
  return;

}


FlexCAN_CompleteRxMessageFifoData (uint8 instance)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  <unnamed type> _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;

  <bb 2> :
  _1 = (int) instance_9(D);
  base_11 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_9(D);
  state_12 = Flexcan_Ip_apxState[_2];
  _3 = instance_9(D) <= 5;
  DevAssert (_3);
  _4 = state_12->transferType;
  if (_4 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = state_12->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), 5, 0, _5);
  _6 = state_12->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), 6, 0, _6);
  _7 = state_12->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), 7, 0, _7);

  <bb 4> :
  state_12->mbs[0].pMBmessage = 0B;
  state_12->mbs[0].state ={v} 0;
  return;

}


FlexCAN_Ip_GetTransferStatus (uint8 instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType status;
  const struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType D.10862;
  int iftmp.6;
  int _1;
  _Bool _2;
  _Bool _3;
  int _4;
  <unnamed type> _5;
  <unnamed type> _6;
  int iftmp.6_8;
  int iftmp.6_15;
  int iftmp.6_16;
  Flexcan_Ip_StatusType _22;

  <bb 2> :
  _1 = (int) instance_9(D);
  state_11 = Flexcan_Ip_apxState[_1];
  status_12 = 1;
  _2 = instance_9(D) <= 5;
  DevAssert (_2);
  if (mb_idx_14(D) <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx_14(D) == 255)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.6_16 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.6_15 = 0;

  <bb 6> :
  # iftmp.6_8 = PHI <iftmp.6_16(4), iftmp.6_15(5)>
  _3 = (_Bool) iftmp.6_8;
  DevAssert (_3);
  if (mb_idx_14(D) <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = (int) mb_idx_14(D);
  _5 ={v} state_11->mbs[_4].state;
  if (_5 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  status_21 = 0;
  goto <bb 13>; [INV]

  <bb 9> :
  status_20 = 2;
  goto <bb 13>; [INV]

  <bb 10> :
  _6 ={v} state_11->enhancedFifoOutput.state;
  if (_6 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  status_19 = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  status_18 = 2;

  <bb 13> :
  # status_7 = PHI <status_20(9), status_19(11), status_18(12), status_21(8)>
  _22 = status_7;

  <bb 14> :
<L13>:
  return _22;

}


FlexCAN_Ip_ConfigRemoteResponseMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  const struct Flexcan_Ip_StateType * const state;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10845;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  long unsigned int _6;
  _Bool _7;
  long unsigned int _8;
  unsigned char _9;
  long unsigned int _10;
  unsigned char _11;
  _Bool _12;
  _Bool _13;
  long unsigned int _14;
  _Bool _15;
  long unsigned int _16;
  <unnamed type> _17;
  long unsigned int _18;
  long unsigned int _19;
  _Bool _20;
  _Bool _21;
  _Bool _22;
  long unsigned int _23;
  _Bool _24;
  Flexcan_Ip_StatusType _57;

  <bb 2> :
  result_28 = 0;
  _1 = (int) instance_29(D);
  pBase_31 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_29(D);
  state_32 = Flexcan_Ip_apxState[_2];
  pMbAddr_33 = 0B;
  _3 = instance_29(D) <= 5;
  DevAssert (_3);
  _4 = tx_info_35(D) != 0B;
  DevAssert (_4);
  _5 ={v} pBase_31->CTRL2;
  _6 = _5 & 131072;
  _7 = _6 == 0;
  DevAssert (_7);
  _8 = tx_info_35(D)->data_length;
  _9 = (unsigned char) _8;
  _10 = (long unsigned int) mb_idx_38(D);
  _11 = FlexCAN_GetMbPayloadSize (pBase_31, _10);
  _12 = _9 <= _11;
  DevAssert (_12);
  _13 = state_32->bIsLegacyFifoEn;
  _14 = state_32->u32MaxMbNum;
  _15 = FlexCAN_IsMbOutOfRange (pBase_31, mb_idx_38(D), _13, _14);
  if (_15 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_42 = 4;

  <bb 4> :
  # result_25 = PHI <result_28(2), result_42(3)>
  if (result_25 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _16 = tx_info_35(D)->data_length;
  cs.dataLen = _16;
  _17 = tx_info_35(D)->msg_id_type;
  cs.msgIdType = _17;
  cs.code = 10;
  cs.fd_enable = 0;
  cs.enable_brs = 0;
  cs.fd_padding = 0;
  _18 = (long unsigned int) mb_idx_38(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_31, _18);
  _19 = (long unsigned int) mb_idx_38(D);
  pMbAddr_51 = FlexCAN_GetMsgBuffRegion (pBase_31, _19);
  _20 = tx_info_35(D)->is_remote;
  FlexCAN_SetTxMsgBuff (pMbAddr_51, &cs, msg_id_52(D), mb_data_53(D), _20);
  _21 = tx_info_35(D)->is_polling;
  _22 = ~_21;
  if (_22 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _23 = (long unsigned int) mb_idx_38(D);
  _24 = state_32->isIntActive;
  result_56 = FlexCAN_SetMsgBuffIntCmd (pBase_31, instance_29(D), _23, 1, _24);

  <bb 7> :
  # result_26 = PHI <result_25(4), result_25(5), result_56(6)>
  _57 = result_26;
  cs ={v} {CLOBBER};

  <bb 8> :
<L7>:
  return _57;

}


FlexCAN_Ip_ConfigEnhancedRxFifo_Privileged (uint8 instance, const struct Flexcan_Ip_EnhancedIdTableType * id_filter_table)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10837;
  int _1;
  _Bool _2;
  int _3;
  _Bool _4;
  _Bool _5;
  int _6;
  _Bool _7;
  _Bool _8;
  _Bool _9;
  _Bool _10;
  Flexcan_Ip_StatusType _38;

  <bb 2> :
  result_17 = 0;
  status_18 = 0;
  _1 = (int) instance_19(D);
  pBase_21 = Flexcan_Ip_apxBase[_1];
  _2 = FlexCAN_IsEnabled (pBase_21);
  _3 = (int) _2;
  _4 = _3 != 0;
  _5 = ~_4;
  _6 = (int) _5;
  disabled_23 = (boolean) _6;
  _7 = instance_19(D) <= 5;
  DevAssert (_7);
  _8 = FlexCAN_IsEnhancedRxFifoAvailable (pBase_21);
  DevAssert (_8);
  _9 = id_filter_table_27(D) != 0B;
  DevAssert (_9);
  if (disabled_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_30 = FlexCAN_Enable (pBase_21);

  <bb 4> :
  # result_11 = PHI <result_17(2), result_30(3)>
  freeze_32 = FlexCAN_IsFreezeMode (pBase_21);
  _10 = ~freeze_32;
  if (_10 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_11 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_33 = 1;

  <bb 7> :
  # result_12 = PHI <result_11(4), result_11(5), result_33(6)>
  if (result_12 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetEnhancedRxFifoFilter (pBase_21, id_filter_table_27(D));

  <bb 9> :
  if (disabled_23 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_36 = FlexCAN_Disable (pBase_21);
  if (status_36 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_37 = status_36;

  <bb 12> :
  # result_13 = PHI <result_12(9), result_12(10), result_37(11)>
  _38 = result_13;

  <bb 13> :
<L12>:
  return _38;

}


FlexCAN_Ip_ConfigRxFifo_Privileged (uint8 instance, Flexcan_Ip_RxFifoIdElementFormatType id_format, const struct Flexcan_Ip_IdTableType * id_filter_table)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10821;
  _Bool _1;
  int _2;
  _Bool _3;
  int _4;
  _Bool _5;
  _Bool _6;
  int _7;
  _Bool _8;
  Flexcan_Ip_StatusType _34;

  <bb 2> :
  _1 = instance_15(D) <= 5;
  DevAssert (_1);
  result_18 = 0;
  status_19 = 0;
  _2 = (int) instance_15(D);
  pBase_20 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnabled (pBase_20);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled_22 = (boolean) _7;
  if (disabled_22 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_24 = FlexCAN_Enable (pBase_20);

  <bb 4> :
  # result_9 = PHI <result_18(2), result_24(3)>
  freeze_26 = FlexCAN_IsFreezeMode (pBase_20);
  _8 = ~freeze_26;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result_9 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  result_27 = 1;

  <bb 7> :
  # result_10 = PHI <result_9(4), result_9(5), result_27(6)>
  if (result_10 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_SetRxFifoFilter (pBase_20, id_format_28(D), id_filter_table_29(D));

  <bb 9> :
  if (disabled_22 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  status_32 = FlexCAN_Disable (pBase_20);
  if (status_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_33 = status_32;

  <bb 12> :
  # result_11 = PHI <result_10(9), result_10(10), result_33(11)>
  _34 = result_11;

  <bb 13> :
<L12>:
  return _34;

}


FlexCAN_Ip_RxFifoBlocking (uint8 instance, struct Flexcan_Ip_MsgBuffType * data, uint32 timeout)
{
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10807;
  int _1;
  _Bool _2;
  _Bool _3;
  _Bool _4;
  Flexcan_Ip_StatusType _28;

  <bb 2> :
  result_7 = 0;
  _1 = (int) instance_8(D);
  base_10 = Flexcan_Ip_apxBase[_1];
  _2 = instance_8(D) <= 5;
  DevAssert (_2);
  _3 = FlexCAN_IsEnhancedRxFifoAvailable (base_10);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  _4 = FlexCAN_IsEnhancedRxFifoEnabled (base_10);
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  result_25 = FlexCAN_StartRxMessageEnhancedFifoData (instance_8(D), data_13(D));
  if (result_25 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  result_27 = FlexCAN_ProccessEnhancedRxFifo (instance_8(D), timeout_16(D));
  goto <bb 10>; [INV]

  <bb 6> :
  result_21 = FlexCAN_StartRxMessageFifoData (instance_8(D), data_13(D));
  if (result_21 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  result_23 = FlexCAN_ProccessLegacyRxFIFO (instance_8(D), timeout_16(D));
  goto <bb 10>; [INV]

  <bb 8> :
  result_15 = FlexCAN_StartRxMessageFifoData (instance_8(D), data_13(D));
  if (result_15 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  result_18 = FlexCAN_ProccessLegacyRxFIFO (instance_8(D), timeout_16(D));

  <bb 10> :
  # result_5 = PHI <result_21(6), result_15(8), result_18(9), result_27(5), result_25(4), result_23(7)>
  _28 = result_5;

  <bb 11> :
<L12>:
  return _28;

}


FlexCAN_Ip_RxFifo (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10791;
  _Bool _1;
  int _2;
  _Bool _3;
  _Bool _4;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  result_7 = 0;
  _1 = instance_8(D) <= 5;
  DevAssert (_1);
  _2 = (int) instance_8(D);
  base_11 = Flexcan_Ip_apxBase[_2];
  _3 = FlexCAN_IsEnhancedRxFifoAvailable (base_11);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _4 = FlexCAN_IsEnhancedRxFifoEnabled (base_11);
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result_20 = FlexCAN_StartRxMessageEnhancedFifoData (instance_8(D), data_13(D));
  goto <bb 7>; [INV]

  <bb 5> :
  result_18 = FlexCAN_StartRxMessageFifoData (instance_8(D), data_13(D));
  goto <bb 7>; [INV]

  <bb 6> :
  result_15 = FlexCAN_StartRxMessageFifoData (instance_8(D), data_13(D));

  <bb 7> :
  # result_5 = PHI <result_18(5), result_15(6), result_20(4)>
  _21 = result_5;

  <bb 8> :
<L6>:
  return _21;

}


FlexCAN_Ip_ReceiveBlocking (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling, uint32 u32TimeoutMs)
{
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10782;
  long unsigned int D.10768;
  long unsigned int _1;
  _Bool _2;
  int _3;
  int _4;
  _Bool _5;
  long unsigned int _6;
  _Bool _7;
  long unsigned int _8;
  long unsigned int _9;
  unsigned char _10;
  long unsigned int _11;
  int _12;
  <unnamed type> _13;
  _Bool _14;
  long unsigned int _15;
  _Bool _16;
  int _17;
  <unnamed type> _18;
  int _19;
  long unsigned int _52;
  Flexcan_Ip_StatusType _59;

  <bb 2> :
  timeStart = 0;
  timeElapsed_32 = 0;
  _1 = u32TimeoutMs_33(D) * 1000;
  mS2Ticks_35 = OsIf_MicrosToTicks (_1, 0);
  _2 = instance_36(D) <= 5;
  DevAssert (_2);
  _3 = (int) instance_36(D);
  state_38 = Flexcan_Ip_apxState[_3];
  _4 = (int) instance_36(D);
  base_39 = Flexcan_Ip_apxBase[_4];
  result_44 = FlexCAN_StartRxMessageBufferData (instance_36(D), mb_idx_40(D), data_41(D), isPolling_42(D));
  if (result_44 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _5 = ~isPolling_42(D);
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = (long unsigned int) mb_idx_40(D);
  _7 = state_38->isIntActive;
  result_46 = FlexCAN_SetMsgBuffIntCmd (base_39, instance_36(D), _6, 1, _7);

  <bb 5> :
  # result_20 = PHI <result_44(2), result_44(3), result_46(4)>
  if (result_20 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _8 = OsIf_GetCounter (0);
  timeStart = _8;
  goto <bb 12>; [INV]

  <bb 7> :
  if (isPolling_42(D) != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _9 = (long unsigned int) mb_idx_40(D);
  _10 = FlexCAN_GetBuffStatusFlag (base_39, _9);
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _11 = (long unsigned int) mb_idx_40(D);
  FlexCAN_IRQHandlerRxMB (instance_36(D), _11);

  <bb 10> :
  _52 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_53 = _52 + timeElapsed_23;
  if (timeElapsed_53 >= mS2Ticks_35)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  result_54 = 3;
  goto <bb 13>; [INV]

  <bb 12> :
  # timeElapsed_23 = PHI <timeElapsed_32(6), timeElapsed_53(10)>
  _12 = (int) mb_idx_40(D);
  _13 ={v} state_38->mbs[_12].state;
  if (_13 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # result_21 = PHI <result_20(5), result_54(11), result_20(12)>
  if (result_21 == 3)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _14 = ~isPolling_42(D);
  if (_14 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _15 = (long unsigned int) mb_idx_40(D);
  _16 = state_38->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_39, instance_36(D), _15, 0, _16);

  <bb 16> :
  if (result_21 != 4)
    goto <bb 17>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 17> :
  if (result_21 != 2)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  _17 = (int) mb_idx_40(D);
  _18 ={v} state_38->mbs[_17].state;
  if (_18 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  result_58 = 0;
  goto <bb 21>; [INV]

  <bb 20> :
  _19 = (int) mb_idx_40(D);
  state_38->mbs[_19].state ={v} 0;
  result_57 = 3;

  <bb 21> :
  # result_22 = PHI <result_21(16), result_21(17), result_58(19), result_57(20)>
  _59 = result_22;
  timeStart ={v} {CLOBBER};

  <bb 22> :
<L27>:
  return _59;

}


FlexCAN_Ip_Receive (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10756;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  _Bool _6;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  _1 = (int) instance_9(D);
  base_11 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_9(D);
  state_12 = Flexcan_Ip_apxState[_2];
  _3 = instance_9(D) <= 5;
  DevAssert (_3);
  result_18 = FlexCAN_StartRxMessageBufferData (instance_9(D), mb_idx_14(D), data_15(D), isPolling_16(D));
  if (result_18 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _4 = ~isPolling_16(D);
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _5 = (long unsigned int) mb_idx_14(D);
  _6 = state_12->isIntActive;
  result_20 = FlexCAN_SetMsgBuffIntCmd (base_11, instance_9(D), _5, 1, _6);

  <bb 5> :
  # result_7 = PHI <result_18(2), result_18(3), result_20(4)>
  _21 = result_7;

  <bb 6> :
<L4>:
  return _21;

}


FlexCAN_Ip_ConfigRxMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * rx_info, uint32 msg_id)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10749;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  long unsigned int _6;
  _Bool _7;
  long unsigned int _8;
  long unsigned int _9;
  <unnamed type> _10;
  _Bool _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  Flexcan_Ip_StatusType _39;

  <bb 2> :
  eResult_17 = 0;
  _1 = (int) instance_18(D);
  base_20 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_18(D);
  state_21 = Flexcan_Ip_apxState[_2];
  _3 = instance_18(D) <= 5;
  DevAssert (_3);
  _4 = rx_info_23(D) != 0B;
  DevAssert (_4);
  _5 = state_21->bIsLegacyFifoEn;
  _6 = state_21->u32MaxMbNum;
  _7 = FlexCAN_IsMbOutOfRange (base_20, mb_idx_25(D), _5, _6);
  if (_7 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_38 = 4;
  goto <bb 5>; [INV]

  <bb 4> :
  _8 = (long unsigned int) mb_idx_25(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_20, _8);
  _9 = rx_info_23(D)->data_length;
  cs.dataLen = _9;
  _10 = rx_info_23(D)->msg_id_type;
  cs.msgIdType = _10;
  _11 = rx_info_23(D)->fd_enable;
  cs.fd_enable = _11;
  cs.code = 15;
  _12 = (long unsigned int) mb_idx_25(D);
  FlexCAN_SetRxMsgBuff (base_20, _12, &cs, msg_id_32(D));
  cs.code = 0;
  _13 = (long unsigned int) mb_idx_25(D);
  FlexCAN_SetRxMsgBuff (base_20, _13, &cs, msg_id_32(D));
  cs.code = 4;
  _14 = (long unsigned int) mb_idx_25(D);
  FlexCAN_SetRxMsgBuff (base_20, _14, &cs, msg_id_32(D));

  <bb 5> :
  # eResult_15 = PHI <eResult_38(3), eResult_17(4)>
  _39 = eResult_15;
  cs ={v} {CLOBBER};

  <bb 6> :
<L4>:
  return _39;

}


FlexCAN_Ip_Send (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10742;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  _Bool _8;
  long unsigned int _9;
  _Bool _10;
  Flexcan_Ip_StatusType _29;

  <bb 2> :
  result_13 = 1;
  _1 = (int) instance_14(D);
  base_16 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_14(D);
  state_17 = Flexcan_Ip_apxState[_2];
  _3 = instance_14(D) <= 5;
  DevAssert (_3);
  _4 = tx_info_19(D) != 0B;
  DevAssert (_4);
  _5 = FlexCAN_IsListenOnlyModeEnabled (base_16);
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  result_26 = FlexCAN_StartSendData (instance_14(D), mb_idx_22(D), tx_info_19(D), msg_id_23(D), mb_data_24(D));
  if (result_26 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _7 = tx_info_19(D)->is_polling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _9 = (long unsigned int) mb_idx_22(D);
  _10 = state_17->isIntActive;
  result_28 = FlexCAN_SetMsgBuffIntCmd (base_16, instance_14(D), _9, 1, _10);

  <bb 6> :
  # result_11 = PHI <result_13(2), result_26(3), result_26(4), result_28(5)>
  _29 = result_11;

  <bb 7> :
<L6>:
  return _29;

}


FlexCAN_Ip_Init_Privileged (uint8 Flexcan_Ip_u8Instance, struct Flexcan_Ip_StateType * Flexcan_Ip_pState, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  uint32 i;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10734;
  int _1;
  _Bool _2;
  _Bool _3;
  <unnamed type> _4;
  <unnamed type> _5;
  void (*<T7e3>) (uint8, Flexcan_Ip_EventType, uint32, const struct Flexcan_Ip_StateType *) _6;
  void (*<T7e3>) (uint8, Flexcan_Ip_EventType, uint32, const struct Flexcan_Ip_StateType *) _7;
  _Bool _8;
  _Bool _9;
  long unsigned int _10;
  int _11;
  Flexcan_Ip_StatusType _45;

  <bb 2> :
  eResult_15 = 0;
  _1 = (int) Flexcan_Ip_u8Instance_16(D);
  pBase_18 = Flexcan_Ip_apxBase[_1];
  _2 = Flexcan_Ip_u8Instance_16(D) <= 5;
  DevAssert (_2);
  _3 = Flexcan_Ip_pData_20(D) != 0B;
  DevAssert (_3);
  eResult_23 = FlexCAN_InitController (Flexcan_Ip_u8Instance_16(D), pBase_18, Flexcan_Ip_pData_20(D));
  if (eResult_23 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  FlexCAN_InitBaudrate (pBase_18, Flexcan_Ip_pData_20(D));
  _4 = Flexcan_Ip_pData_20(D)->flexcanMode;
  FlexCAN_SetOperationMode (pBase_18, _4);
  i_26 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  Flexcan_Ip_pState_27(D)->mbs[i_12].isPolling = 1;
  Flexcan_Ip_pState_27(D)->mbs[i_12].pMBmessage = 0B;
  Flexcan_Ip_pState_27(D)->mbs[i_12].state ={v} 0;
  Flexcan_Ip_pState_27(D)->mbs[i_12].time_stamp = 0;
  i_44 = i_12 + 1;

  <bb 5> :
  # i_12 = PHI <i_26(3), i_44(4)>
  if (i_12 <= 95)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  Flexcan_Ip_pState_27(D)->enhancedFifoOutput.isPolling = 1;
  Flexcan_Ip_pState_27(D)->enhancedFifoOutput.state ={v} 0;
  _5 = Flexcan_Ip_pData_20(D)->transfer_type;
  Flexcan_Ip_pState_27(D)->transferType = _5;
  _6 = Flexcan_Ip_pData_20(D)->Callback;
  Flexcan_Ip_pState_27(D)->callback = _6;
  Flexcan_Ip_pState_27(D)->callbackParam = 0B;
  _7 = Flexcan_Ip_pData_20(D)->ErrorCallback;
  Flexcan_Ip_pState_27(D)->error_callback = _7;
  Flexcan_Ip_pState_27(D)->errorCallbackParam = 0B;
  _8 = Flexcan_Ip_pData_20(D)->is_rx_fifo_needed;
  Flexcan_Ip_pState_27(D)->bIsLegacyFifoEn = _8;
  _9 = Flexcan_Ip_pData_20(D)->is_enhanced_rx_fifo_needed;
  Flexcan_Ip_pState_27(D)->bIsEnhancedFifoEn = _9;
  _10 = Flexcan_Ip_pData_20(D)->max_num_mb;
  Flexcan_Ip_pState_27(D)->u32MaxMbNum = _10;
  Flexcan_Ip_pState_27(D)->isIntActive = 1;
  _11 = (int) Flexcan_Ip_u8Instance_16(D);
  Flexcan_Ip_apxState[_11] = Flexcan_Ip_pState_27(D);

  <bb 7> :
  _45 = eResult_23;

  <bb 8> :
<L5>:
  return _45;

}


FlexCAN_AbortRxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 val2;
  uint32 val1;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  int _1;
  int _2;
  int _3;
  _Bool _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  _Bool _9;
  long unsigned int _10;
  long unsigned int _11;

  <bb 2> :
  _1 = (int) u8Instance_14(D);
  pBase_16 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_14(D);
  state_17 = Flexcan_Ip_apxState[_2];
  val1_18 = 0;
  val2_19 = 0;
  flexcan_mb_config_20 = 0;
  flexcan_mb_21 = 0B;
  _3 = (int) mb_idx_22(D);
  state_17->mbs[_3].state ={v} 0;
  _4 = state_17->bIsLegacyFifoEn;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _5 ={v} pBase_16->CTRL2;
  _6 = _5 >> 24;
  val1_33 = _6 & 15;
  val2_35 = RxFifoOcuppiedLastMsgBuff (val1_33);
  _7 = (long unsigned int) mb_idx_22(D);
  if (val2_35 < _7)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _8 = (long unsigned int) mb_idx_22(D);
  flexcan_mb_37 = FlexCAN_GetMsgBuffRegion (pBase_16, _8);
  flexcan_mb_config_38 ={v} *flexcan_mb_37;
  flexcan_mb_config_39 = flexcan_mb_config_38 & 4043309055;
  flexcan_mb_config_40 = flexcan_mb_config_39;
  *flexcan_mb_37 ={v} flexcan_mb_config_40;
  flexcan_mb_config_42 = flexcan_mb_config_40 & 4043309055;
  flexcan_mb_config_43 = flexcan_mb_config_42 | 67108864;
  *flexcan_mb_37 ={v} flexcan_mb_config_43;

  <bb 5> :
  if (mb_idx_22(D) == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _9 = state_17->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase_16, u8Instance_14(D), 5, _9);
  goto <bb 8>; [INV]

  <bb 7> :
  _10 = (long unsigned int) mb_idx_22(D);
  flexcan_mb_25 = FlexCAN_GetMsgBuffRegion (pBase_16, _10);
  flexcan_mb_config_26 ={v} *flexcan_mb_25;
  flexcan_mb_config_27 = flexcan_mb_config_26 & 4043309055;
  flexcan_mb_config_28 = flexcan_mb_config_27;
  *flexcan_mb_25 ={v} flexcan_mb_config_28;
  flexcan_mb_config_30 = flexcan_mb_config_28 & 4043309055;
  flexcan_mb_config_31 = flexcan_mb_config_30 | 67108864;
  *flexcan_mb_25 ={v} flexcan_mb_config_31;

  <bb 8> :
  _11 = (long unsigned int) mb_idx_22(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_16, _11);
  return;

}


FlexCAN_AbortTxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 uS2Ticks;
  uint32 flexcan_mb_config;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.10720;
  long unsigned int D.10711;
  int _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  unsigned char _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  int _12;
  long unsigned int _42;
  Flexcan_Ip_StatusType _50;

  <bb 2> :
  _1 = (int) u8Instance_19(D);
  pBase_21 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_19(D);
  state_22 = Flexcan_Ip_apxState[_2];
  result_23 = 0;
  timeStart = 0;
  timeElapsed_25 = 0;
  flexcan_mb_config_26 = 0;
  uS2Ticks_27 = 0;
  flexcan_mb_28 = 0B;
  _3 = (long unsigned int) mb_idx_29(D);
  flexcan_mb_31 = FlexCAN_GetMsgBuffRegion (pBase_21, _3);
  flexcan_mb_config_32 ={v} *flexcan_mb_31;
  flexcan_mb_config_33 = flexcan_mb_config_32 & 4043309055;
  flexcan_mb_config_34 = flexcan_mb_config_33 | 150994944;
  *flexcan_mb_31 ={v} flexcan_mb_config_34;
  uS2Ticks_37 = OsIf_MicrosToTicks (10000, 0);
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 5>; [INV]

  <bb 3> :
  _42 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_43 = _42 + timeElapsed_16;
  if (timeElapsed_43 >= uS2Ticks_37)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  result_44 = 3;
  goto <bb 6>; [INV]

  <bb 5> :
  # timeElapsed_16 = PHI <timeElapsed_25(2), timeElapsed_43(3)>
  _5 = (long unsigned int) mb_idx_29(D);
  _6 = FlexCAN_GetBuffStatusFlag (pBase_21, _5);
  if (_6 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # result_13 = PHI <result_44(4), result_23(5)>
  if (result_13 != 3)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  flexcan_mb_config_45 ={v} *flexcan_mb_31;
  _7 = flexcan_mb_config_45 >> 24;
  _8 = _7 & 15;
  if (_8 == 8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  result_46 = 5;

  <bb 9> :
  # result_14 = PHI <result_13(7), result_46(8)>
  _9 = flexcan_mb_config_45 >> 24;
  _10 = _9 & 15;
  if (_10 == 9)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  result_47 = 0;

  <bb 11> :
  # result_15 = PHI <result_13(6), result_14(9), result_47(10)>
  _11 = (long unsigned int) mb_idx_29(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_21, _11);
  _12 = (int) mb_idx_29(D);
  state_22->mbs[_12].state ={v} 0;
  _50 = result_15;
  timeStart ={v} {CLOBBER};

  <bb 12> :
<L12>:
  return _50;

}


FlexCAN_IRQHandlerEnhancedRxFIFO (uint8 instance, uint32 intType)
{
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  <unnamed type> _3;
  struct Flexcan_Ip_MsgBuffType * _4;
  struct Flexcan_Ip_MsgBuffType * _5;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _6;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _7;
  <unnamed type> _8;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _9;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _10;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _11;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _12;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _13;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _14;

  <bb 2> :
  _1 = (int) instance_22(D);
  base_24 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_22(D);
  state_25 = Flexcan_Ip_apxState[_2];
  switch (intType_26(D)) <default: <L18> [INV], case 28: <L0> [INV], case 29: <L9> [INV], case 30: <L12> [INV], case 31: <L15> [INV]>

  <bb 3> :
<L0>:
  _3 ={v} state_25->enhancedFifoOutput.state;
  if (_3 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  _4 = state_25->enhancedFifoOutput.pMBmessage;
  if (_4 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  state_25->enhancedFifoOutput.pMBmessage = &data;

  <bb 6> :
  _5 = state_25->enhancedFifoOutput.pMBmessage;
  FlexCAN_ReadEnhancedRxFifo (base_24, _5);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_24, intType_26(D));
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_24, 29);
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_24, 30);
  state_25->enhancedFifoOutput.state ={v} 0;
  _6 = state_25->callback;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = state_25->callback;
  _7 (instance_22(D), 5, 255, state_25);

  <bb 8> :
  _8 ={v} state_25->enhancedFifoOutput.state;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  FlexCAN_CompleteRxMessageEnhancedFifoData (instance_22(D));

  <bb 10> :
  goto <bb 21>; [INV]

  <bb 11> :
<L9>:
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_24, intType_26(D));
  _9 = state_25->callback;
  if (_9 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _10 = state_25->callback;
  _10 (instance_22(D), 6, 255, state_25);

  <bb 13> :
  goto <bb 21>; [INV]

  <bb 14> :
<L12>:
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_24, intType_26(D));
  _11 = state_25->callback;
  if (_11 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _12 = state_25->callback;
  _12 (instance_22(D), 7, 255, state_25);

  <bb 16> :
  goto <bb 21>; [INV]

  <bb 17> :
<L15>:
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_24, intType_26(D));
  _13 = state_25->callback;
  if (_13 != 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  _14 = state_25->callback;
  _14 (instance_22(D), 8, 255, state_25);

  <bb 19> :
  goto <bb 21>; [INV]

  <bb 20> :
<L18>:

  <bb 21> :
  data ={v} {CLOBBER};
  return;

}


FlexCAN_ProcessIRQHandlerEnhancedRxFIFO (uint8 u8Instance, boolean bIsSpuriousIntPrevious)
{
  boolean bIsSpuriousInt;
  uint32 u32intType;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  boolean D.10915;
  int _1;
  int _2;
  unsigned char _3;
  unsigned char _4;
  _Bool _5;
  _Bool _6;
  boolean _20;

  <bb 2> :
  _1 = (int) u8Instance_12(D);
  base_14 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_12(D);
  state_15 = Flexcan_Ip_apxState[_2];
  u32intType_16 = 0;
  bIsSpuriousInt_18 = bIsSpuriousIntPrevious_17(D);
  u32intType_19 = 31;
  goto <bb 10>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetEnhancedRxFIFOStatusFlag (base_14, u32intType_7);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  _4 = FlexCAN_GetEnhancedRxFIFOIntStatusFlag (base_14, u32intType_7);
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_IRQHandlerEnhancedRxFIFO (u8Instance_12(D), u32intType_7);
  bIsSpuriousInt_25 = 0;
  goto <bb 9>; [INV]

  <bb 6> :
  if (bIsSpuriousInt_9 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _5 = state_15->enhancedFifoOutput.isPolling;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_ClearEnhancedRxFifoIntStatusFlag (base_14, u32intType_7);

  <bb 9> :
  # bIsSpuriousInt_8 = PHI <bIsSpuriousInt_9(3), bIsSpuriousInt_25(5), bIsSpuriousInt_9(6), bIsSpuriousInt_9(7), bIsSpuriousInt_9(8)>
  u32intType_26 = u32intType_7 + 4294967295;

  <bb 10> :
  # u32intType_7 = PHI <u32intType_19(2), u32intType_26(9)>
  # bIsSpuriousInt_9 = PHI <bIsSpuriousInt_18(2), bIsSpuriousInt_8(9)>
  if (u32intType_7 > 27)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _20 = bIsSpuriousInt_9;

  <bb 12> :
<L13>:
  return _20;

}


FlexCAN_ProcessSpuriousInterruptMB (uint8 instance, uint32 startMbIdx, uint32 endMbIdx)
{
  uint32 u32MbHandle;
  uint32 mb_idx;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  unsigned char _3;
  unsigned char _4;
  _Bool _5;
  _Bool _6;
  _Bool _7;
  <unnamed type> _8;

  <bb 2> :
  _1 = (int) instance_13(D);
  base_15 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_13(D);
  state_16 = Flexcan_Ip_apxState[_2];
  mb_idx_17 = 0;
  u32MbHandle_18 = 0;
  mb_idx_20 = startMbIdx_19(D);
  goto <bb 12>; [INV]

  <bb 3> :
  _3 = FlexCAN_GetBuffStatusFlag (base_15, mb_idx_9);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  _4 = FlexCAN_GetBuffStatusImask (base_15, mb_idx_9);
  if (_4 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  u32MbHandle_24 = mb_idx_9;
  _5 = state_16->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (mb_idx_9 <= 7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  u32MbHandle_25 = 0;

  <bb 8> :
  # u32MbHandle_10 = PHI <u32MbHandle_24(5), u32MbHandle_24(6), u32MbHandle_25(7)>
  _6 = state_16->mbs[u32MbHandle_10].isPolling;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  FlexCAN_ClearMsgBuffIntStatusFlag (base_15, mb_idx_9);
  _8 ={v} state_16->mbs[u32MbHandle_10].state;
  if (_8 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  state_16->mbs[u32MbHandle_10].state ={v} 0;
  state_16->mbs[u32MbHandle_10].isPolling = 1;

  <bb 11> :
  mb_idx_29 = mb_idx_9 + 1;

  <bb 12> :
  # mb_idx_9 = PHI <mb_idx_20(2), mb_idx_29(11)>
  if (mb_idx_9 <= endMbIdx_21(D))
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  return;

}


FlexCAN_IRQHandlerRxFIFO (uint8 instance, uint32 mb_idx)
{
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  struct Flexcan_Ip_MsgBuffType * _3;
  <unnamed type> _4;
  struct Flexcan_Ip_MsgBuffType * _5;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _6;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _7;
  <unnamed type> _8;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _9;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _10;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _11;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _12;

  <bb 2> :
  _1 = (int) instance_19(D);
  base_21 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_19(D);
  state_22 = Flexcan_Ip_apxState[_2];
  _3 = state_22->mbs[0].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state_22->mbs[0].pMBmessage = &data;

  <bb 4> :
  switch (mb_idx_24(D)) <default: <L15> [INV], case 5: <L2> [INV], case 6: <L9> [INV], case 7: <L12> [INV]>

  <bb 5> :
<L2>:
  _4 ={v} state_22->mbs[0].state;
  if (_4 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _5 = state_22->mbs[0].pMBmessage;
  FlexCAN_ReadRxFifo (base_21, _5);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_21, mb_idx_24(D));
  state_22->mbs[0].state ={v} 0;
  _6 = state_22->callback;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = state_22->callback;
  _7 (instance_19(D), 1, 0, state_22);

  <bb 8> :
  _8 ={v} state_22->mbs[0].state;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  state_22->mbs[0].isPolling = 1;
  FlexCAN_CompleteRxMessageFifoData (instance_19(D));

  <bb 10> :
  goto <bb 18>; [INV]

  <bb 11> :
<L9>:
  FlexCAN_ClearMsgBuffIntStatusFlag (base_21, mb_idx_24(D));
  _9 = state_22->callback;
  if (_9 != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _10 = state_22->callback;
  _10 (instance_19(D), 2, 0, state_22);

  <bb 13> :
  goto <bb 18>; [INV]

  <bb 14> :
<L12>:
  FlexCAN_ClearMsgBuffIntStatusFlag (base_21, mb_idx_24(D));
  _11 = state_22->callback;
  if (_11 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _12 = state_22->callback;
  _12 (instance_19(D), 3, 0, state_22);

  <bb 16> :
  goto <bb 18>; [INV]

  <bb 17> :
<L15>:

  <bb 18> :
  data ={v} {CLOBBER};
  return;

}


FlexCAN_IRQHandlerTxMB (uint8 u8Instance, uint32 u32MbIdx)
{
  struct Flexcan_Ip_MsgBuffType mb;
  struct Flexcan_Ip_StateType * pState;
  struct FLEXCAN_Type * pBase;
  int _1;
  int _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _9;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _10;
  <unnamed type> _11;
  _Bool _12;
  _Bool _13;
  _Bool _14;

  <bb 2> :
  _1 = (int) u8Instance_18(D);
  pBase_20 = Flexcan_Ip_apxBase[_1];
  _2 = (int) u8Instance_18(D);
  pState_21 = Flexcan_Ip_apxState[_2];
  _3 = pState_21->mbs[u32MbIdx_22(D)].isRemote;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  FlexCAN_LockRxMsgBuff (pBase_20, u32MbIdx_22(D));
  FlexCAN_GetMsgBuff (pBase_20, u32MbIdx_22(D), &mb);
  FlexCAN_UnlockRxMsgBuff (pBase_20);
  _4 = mb.time_stamp;
  pState_21->mbs[u32MbIdx_22(D)].time_stamp = _4;
  _5 = mb.cs;
  _6 = _5 >> 24;
  _7 = _6 & 15;
  if (_7 == 4)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_20, u32MbIdx_22(D));
  goto <bb 6>; [INV]

  <bb 5> :
  _8 = FlexCAN_GetMsgBuffTimestamp (pBase_20, u32MbIdx_22(D));
  pState_21->mbs[u32MbIdx_22(D)].time_stamp = _8;
  FlexCAN_UnlockRxMsgBuff (pBase_20);
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase_20, u32MbIdx_22(D));

  <bb 6> :
  pState_21->mbs[u32MbIdx_22(D)].state ={v} 0;
  _9 = pState_21->callback;
  if (_9 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _10 = pState_21->callback;
  _10 (u8Instance_18(D), 4, u32MbIdx_22(D), pState_21);

  <bb 8> :
  _11 ={v} pState_21->mbs[u32MbIdx_22(D)].state;
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  pState_21->mbs[u32MbIdx_22(D)].isPolling = 1;
  _12 = pState_21->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_20, u8Instance_18(D), u32MbIdx_22(D), 0, _12);
  goto <bb 12>; [INV]

  <bb 10> :
  _13 = pState_21->mbs[u32MbIdx_22(D)].isPolling;
  if (_13 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _14 = pState_21->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_20, u8Instance_18(D), u32MbIdx_22(D), 0, _14);

  <bb 12> :
  mb ={v} {CLOBBER};
  return;

}


FlexCAN_IRQHandlerRxMB (uint8 instance, uint32 mb_idx)
{
  boolean bCurrentIntStat;
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  struct Flexcan_Ip_MsgBuffType * _3;
  struct Flexcan_Ip_MsgBuffType * _4;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _5;
  void (*<T7dd>) (uint8, Flexcan_Ip_EventType, uint32, const struct FlexCANState *) _6;
  <unnamed type> _7;
  _Bool _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  _Bool _12;
  _Bool _13;

  <bb 2> :
  _1 = (int) instance_17(D);
  base_19 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_17(D);
  state_20 = Flexcan_Ip_apxState[_2];
  bCurrentIntStat_21 = 0;
  _3 = state_20->mbs[mb_idx_22(D)].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state_20->mbs[mb_idx_22(D)].pMBmessage = &data;

  <bb 4> :
  FlexCAN_LockRxMsgBuff (base_19, mb_idx_22(D));
  _4 = state_20->mbs[mb_idx_22(D)].pMBmessage;
  FlexCAN_GetMsgBuff (base_19, mb_idx_22(D), _4);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_19, mb_idx_22(D));
  FlexCAN_UnlockRxMsgBuff (base_19);
  state_20->mbs[mb_idx_22(D)].state ={v} 0;
  bCurrentIntStat_29 = state_20->mbs[mb_idx_22(D)].isPolling;
  _5 = state_20->callback;
  if (_5 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = state_20->callback;
  _6 (instance_17(D), 0, mb_idx_22(D), state_20);

  <bb 6> :
  _7 ={v} state_20->mbs[mb_idx_22(D)].state;
  if (_7 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _8 = state_20->mbs[mb_idx_22(D)].isPolling;
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  state_20->mbs[mb_idx_22(D)].isPolling = 1;
  _10 = state_20->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_19, instance_17(D), mb_idx_22(D), 0, _10);
  goto <bb 12>; [INV]

  <bb 9> :
  _11 = ~bCurrentIntStat_29;
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _12 = state_20->mbs[mb_idx_22(D)].isPolling;
  if (_12 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _13 = state_20->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_19, instance_17(D), mb_idx_22(D), 0, _13);

  <bb 12> :
  data ={v} {CLOBBER};
  return;

}


FlexCAN_StartRxMessageFifoData (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType eResult;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.10668;
  _Bool _1;
  int _2;
  int _3;
  _Bool _4;
  _Bool _5;
  <unnamed type> _6;
  <unnamed type> _7;
  <unnamed type> _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  Flexcan_Ip_StatusType _33;

  <bb 2> :
  base_15 = 0B;
  state_16 = 0B;
  eResult_17 = 0;
  _1 = instance_18(D) <= 5;
  DevAssert (_1);
  _2 = (int) instance_18(D);
  base_21 = Flexcan_Ip_apxBase[_2];
  _3 = (int) instance_18(D);
  state_22 = Flexcan_Ip_apxState[_3];
  _4 = state_22->bIsLegacyFifoEn;
  _5 = ~_4;
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_32 = 1;
  goto <bb 10>; [INV]

  <bb 4> :
  _6 ={v} state_22->mbs[0].state;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  eResult_31 = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  state_22->mbs[0].state ={v} 1;
  _7 = state_22->transferType;
  if (_7 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  state_22->mbs[0].isPolling = 1;

  <bb 8> :
  state_22->mbs[0].pMBmessage = data_25(D);
  _8 = state_22->transferType;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  state_22->mbs[0].isPolling = 0;
  _9 = state_22->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_21, instance_18(D), 6, 1, _9);
  _10 = state_22->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_21, instance_18(D), 7, 1, _10);
  _11 = state_22->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base_21, instance_18(D), 5, 1, _11);

  <bb 10> :
  # eResult_12 = PHI <eResult_32(3), eResult_31(5), eResult_17(8), eResult_17(9)>
  _33 = eResult_12;

  <bb 11> :
<L10>:
  return _33;

}


FlexCAN_StartSendData (uint8 Flexcan_Ip_u8Instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10655;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  unsigned char _6;
  long unsigned int _7;
  unsigned char _8;
  _Bool _9;
  _Bool _10;
  long unsigned int _11;
  _Bool _12;
  int _13;
  <unnamed type> _14;
  long unsigned int _15;
  int _16;
  int _17;
  int _18;
  _Bool _19;
  int _20;
  _Bool _21;
  long unsigned int _22;
  <unnamed type> _23;
  _Bool _24;
  unsigned char _25;
  _Bool _26;
  _Bool _27;
  long unsigned int _28;
  Flexcan_Ip_StatusType _64;

  <bb 2> :
  eResult_32 = 0;
  _1 = (int) Flexcan_Ip_u8Instance_33(D);
  state_35 = Flexcan_Ip_apxState[_1];
  _2 = (int) Flexcan_Ip_u8Instance_33(D);
  base_36 = Flexcan_Ip_apxBase[_2];
  pMbAddr_37 = 0B;
  _3 = Flexcan_Ip_u8Instance_33(D) <= 5;
  DevAssert (_3);
  _4 = tx_info_39(D) != 0B;
  DevAssert (_4);
  _5 = tx_info_39(D)->data_length;
  _6 = (unsigned char) _5;
  _7 = (long unsigned int) mb_idx_41(D);
  _8 = FlexCAN_GetMbPayloadSize (base_36, _7);
  _9 = _6 <= _8;
  DevAssert (_9);
  _10 = state_35->bIsLegacyFifoEn;
  _11 = state_35->u32MaxMbNum;
  _12 = FlexCAN_IsMbOutOfRange (base_36, mb_idx_41(D), _10, _11);
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_63 = 4;
  goto <bb 10>; [INV]

  <bb 4> :
  _13 = (int) mb_idx_41(D);
  _14 ={v} state_35->mbs[_13].state;
  if (_14 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  eResult_62 = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  _15 = (long unsigned int) mb_idx_41(D);
  FlexCAN_ClearMsgBuffIntStatusFlag (base_36, _15);
  _16 = (int) mb_idx_41(D);
  state_35->mbs[_16].state ={v} 2;
  _17 = (int) mb_idx_41(D);
  state_35->mbs[_17].time_stamp = 0;
  _18 = (int) mb_idx_41(D);
  _19 = tx_info_39(D)->is_polling;
  state_35->mbs[_18].isPolling = _19;
  _20 = (int) mb_idx_41(D);
  _21 = tx_info_39(D)->is_remote;
  state_35->mbs[_20].isRemote = _21;
  _22 = tx_info_39(D)->data_length;
  cs.dataLen = _22;
  _23 = tx_info_39(D)->msg_id_type;
  cs.msgIdType = _23;
  _24 = tx_info_39(D)->fd_enable;
  cs.fd_enable = _24;
  _25 = tx_info_39(D)->fd_padding;
  cs.fd_padding = _25;
  _26 = tx_info_39(D)->enable_brs;
  cs.enable_brs = _26;
  _27 = tx_info_39(D)->is_remote;
  if (_27 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  cs.code = 28;
  goto <bb 9>; [INV]

  <bb 8> :
  cs.code = 12;

  <bb 9> :
  _28 = (long unsigned int) mb_idx_41(D);
  pMbAddr_58 = FlexCAN_GetMsgBuffRegion (base_36, _28);
  FlexCAN_SetTxMsgBuff (pMbAddr_58, &cs, msg_id_59(D), mb_data_60(D), 0);

  <bb 10> :
  # eResult_29 = PHI <eResult_63(3), eResult_62(5), eResult_32(9)>
  _64 = eResult_29;
  cs ={v} {CLOBBER};

  <bb 11> :
<L10>:
  return _64;

}


FlexCAN_StartRxMessageBufferData (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.10644;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  long unsigned int _5;
  _Bool _6;
  int _7;
  <unnamed type> _8;
  int _9;
  int _10;
  int _11;
  Flexcan_Ip_StatusType _29;

  <bb 2> :
  result_14 = 0;
  _1 = (int) instance_15(D);
  base_17 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_15(D);
  state_18 = Flexcan_Ip_apxState[_2];
  _3 = instance_15(D) <= 5;
  DevAssert (_3);
  _4 = state_18->bIsLegacyFifoEn;
  _5 = state_18->u32MaxMbNum;
  _6 = FlexCAN_IsMbOutOfRange (base_17, mb_idx_20(D), _4, _5);
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  result_28 = 4;
  goto <bb 7>; [INV]

  <bb 4> :
  _7 = (int) mb_idx_20(D);
  _8 ={v} state_18->mbs[_7].state;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  result_27 = 2;
  goto <bb 7>; [INV]

  <bb 6> :
  _9 = (int) mb_idx_20(D);
  state_18->mbs[_9].state ={v} 1;
  _10 = (int) mb_idx_20(D);
  state_18->mbs[_10].pMBmessage = data_23(D);
  _11 = (int) mb_idx_20(D);
  state_18->mbs[_11].isPolling = isPolling_25(D);

  <bb 7> :
  # result_12 = PHI <result_28(3), result_27(5), result_14(6)>
  _29 = result_12;

  <bb 8> :
<L6>:
  return _29;

}


FlexCAN_ProccessLegacyRxFIFO (uint8 u8Instance, uint32 u32TimeoutMs)
{
  uint32 u32intType;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_StateType * pState;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10603;
  long unsigned int D.10596;
  int _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  <unnamed type> _5;
  unsigned char _6;
  <unnamed type> _7;
  <unnamed type> _8;
  _Bool _9;
  _Bool _10;
  _Bool _11;
  <unnamed type> _12;
  long unsigned int _42;
  Flexcan_Ip_StatusType _51;

  <bb 2> :
  eResult_24 = 0;
  _1 = (int) u8Instance_25(D);
  pState_27 = Flexcan_Ip_apxState[_1];
  _2 = (int) u8Instance_25(D);
  pBase_28 = Flexcan_Ip_apxBase[_2];
  timeStart = 0;
  timeElapsed_30 = 0;
  _3 = u32TimeoutMs_31(D) * 1000;
  mS2Ticks_33 = OsIf_MicrosToTicks (_3, 0);
  u32intType_34 = 0;
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 11>; [INV]

  <bb 3> :
  _5 = pState_27->transferType;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  u32intType_37 = 7;
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = FlexCAN_GetBuffStatusFlag (pBase_28, u32intType_16);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_IRQHandlerRxFIFO (u8Instance_25(D), u32intType_16);

  <bb 7> :
  u32intType_40 = u32intType_16 + 4294967295;

  <bb 8> :
  # u32intType_16 = PHI <u32intType_37(4), u32intType_40(7)>
  if (u32intType_16 > 4)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _42 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_43 = _42 + timeElapsed_15;
  if (timeElapsed_43 >= mS2Ticks_33)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  eResult_44 = 3;
  goto <bb 12>; [INV]

  <bb 11> :
  # timeElapsed_15 = PHI <timeElapsed_30(2), timeElapsed_43(9)>
  _7 ={v} pState_27->mbs[0].state;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # eResult_13 = PHI <eResult_44(10), eResult_24(11)>
  if (eResult_13 == 3)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _8 = pState_27->transferType;
  if (_8 != 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _9 = pState_27->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_28, u8Instance_25(D), 5, 0, _9);
  _10 = pState_27->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_28, u8Instance_25(D), 6, 0, _10);
  _11 = pState_27->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase_28, u8Instance_25(D), 7, 0, _11);

  <bb 15> :
  _12 ={v} pState_27->mbs[0].state;
  switch (_12) <default: <L18> [INV], case 0: <L17> [INV], case 1: <L16> [INV]>

  <bb 16> :
<L16>:
  pState_27->mbs[0].state ={v} 0;
  goto <bb 19>; [INV]

  <bb 17> :
<L17>:
  eResult_49 = 0;
  goto <bb 19>; [INV]

  <bb 18> :
<L18>:
  eResult_50 = 1;

  <bb 19> :
  # eResult_14 = PHI <eResult_13(16), eResult_49(17), eResult_50(18)>
  _51 = eResult_14;
  timeStart ={v} {CLOBBER};

  <bb 20> :
<L21>:
  return _51;

}


FlexCAN_ProccessEnhancedRxFifo (uint8 u8Instance, uint32 u32TimeoutMs)
{
  uint32 u32intType;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_StateType * pState;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10587;
  long unsigned int D.10580;
  int _1;
  int _2;
  long unsigned int _3;
  long unsigned int _4;
  <unnamed type> _5;
  unsigned char _6;
  <unnamed type> _7;
  <unnamed type> _8;
  <unnamed type> _9;
  long unsigned int _39;
  Flexcan_Ip_StatusType _46;

  <bb 2> :
  eResult_21 = 0;
  _1 = (int) u8Instance_22(D);
  pState_24 = Flexcan_Ip_apxState[_1];
  _2 = (int) u8Instance_22(D);
  pBase_25 = Flexcan_Ip_apxBase[_2];
  timeStart = 0;
  timeElapsed_27 = 0;
  _3 = u32TimeoutMs_28(D) * 1000;
  mS2Ticks_30 = OsIf_MicrosToTicks (_3, 0);
  u32intType_31 = 0;
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  goto <bb 11>; [INV]

  <bb 3> :
  _5 = pState_24->transferType;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  u32intType_34 = 31;
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = FlexCAN_GetEnhancedRxFIFOStatusFlag (pBase_25, u32intType_13);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_IRQHandlerEnhancedRxFIFO (u8Instance_22(D), u32intType_13);

  <bb 7> :
  u32intType_37 = u32intType_13 + 4294967295;

  <bb 8> :
  # u32intType_13 = PHI <u32intType_34(4), u32intType_37(7)>
  if (u32intType_13 > 27)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _39 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed_40 = _39 + timeElapsed_12;
  if (timeElapsed_40 >= mS2Ticks_30)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  eResult_41 = 3;
  goto <bb 12>; [INV]

  <bb 11> :
  # timeElapsed_12 = PHI <timeElapsed_27(2), timeElapsed_40(9)>
  _7 ={v} pState_24->enhancedFifoOutput.state;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # eResult_10 = PHI <eResult_41(10), eResult_21(11)>
  if (eResult_10 == 3)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _8 = pState_24->transferType;
  if (_8 != 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  FlexCAN_SetEnhancedRxFifoIntAll (pBase_25, 0);

  <bb 15> :
  _9 ={v} pState_24->enhancedFifoOutput.state;
  switch (_9) <default: <L18> [INV], case 0: <L17> [INV], case 1: <L16> [INV]>

  <bb 16> :
<L16>:
  pState_24->enhancedFifoOutput.state ={v} 0;
  goto <bb 19>; [INV]

  <bb 17> :
<L17>:
  eResult_44 = 0;
  goto <bb 19>; [INV]

  <bb 18> :
<L18>:
  eResult_45 = 1;

  <bb 19> :
  # eResult_11 = PHI <eResult_10(16), eResult_44(17), eResult_45(18)>
  _46 = eResult_11;
  timeStart ={v} {CLOBBER};

  <bb 20> :
<L21>:
  return _46;

}


FlexCAN_StartRxMessageEnhancedFifoData (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType eResult;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.10574;
  int _1;
  int _2;
  _Bool _3;
  <unnamed type> _4;
  <unnamed type> _5;
  _Bool _6;
  <unnamed type> _7;
  Flexcan_Ip_StatusType _24;

  <bb 2> :
  _1 = (int) instance_11(D);
  base_13 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_11(D);
  state_14 = Flexcan_Ip_apxState[_2];
  eResult_15 = 0;
  _3 = instance_11(D) <= 5;
  DevAssert (_3);
  _4 ={v} state_14->enhancedFifoOutput.state;
  if (_4 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  eResult_23 = 2;
  goto <bb 9>; [INV]

  <bb 4> :
  state_14->enhancedFifoOutput.state ={v} 1;
  state_14->enhancedFifoOutput.pMBmessage = data_18(D);
  _5 = state_14->transferType;
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  state_14->enhancedFifoOutput.isPolling = 0;
  _6 = state_14->isIntActive;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  FlexCAN_SetEnhancedRxFifoIntAll (base_13, 1);

  <bb 7> :
  _7 = state_14->transferType;
  if (_7 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  state_14->enhancedFifoOutput.isPolling = 1;

  <bb 9> :
  # eResult_8 = PHI <eResult_23(3), eResult_15(7), eResult_15(8)>
  _24 = eResult_8;

  <bb 10> :
<L9>:
  return _24;

}


FlexCAN_CompleteRxMessageEnhancedFifoData (uint8 instance)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  int _1;
  int _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;

  <bb 2> :
  _1 = (int) instance_8(D);
  base_10 = Flexcan_Ip_apxBase[_1];
  _2 = (int) instance_8(D);
  state_11 = Flexcan_Ip_apxState[_2];
  _3 = instance_8(D) <= 5;
  DevAssert (_3);
  _4 = FlexCAN_IsEnhancedRxFifoAvailable (base_10);
  DevAssert (_4);
  _5 = state_11->enhancedFifoOutput.isPolling;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  state_11->enhancedFifoOutput.isPolling = 1;
  FlexCAN_SetEnhancedRxFifoIntAll (base_10, 0);

  <bb 4> :
  state_11->enhancedFifoOutput.pMBmessage = 0B;
  state_11->enhancedFifoOutput.state ={v} 0;
  return;

}


FlexCAN_InitBaudrate (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  _Bool _1;
  _Bool _2;
  long unsigned int _3;
  long unsigned int _4;
  const struct Flexcan_Ip_TimeSegmentType * _5;
  _Bool _6;
  const struct Flexcan_Ip_TimeSegmentType * _7;
  long unsigned int _8;
  long unsigned int _9;
  _Bool _10;
  const struct Flexcan_Ip_TimeSegmentType * _11;
  const struct Flexcan_Ip_TimeSegmentType * _12;
  const struct Flexcan_Ip_TimeSegmentType * _13;

  <bb 2> :
  _1 = Flexcan_Ip_pData_16(D)->fd_enable;
  FlexCAN_EnableExtCbt (pBase_17(D), _1);
  _2 = Flexcan_Ip_pData_16(D)->enhCbtEnable;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _3 ={v} pBase_17(D)->CTRL2;
  _4 = _3 | 8192;
  pBase_17(D)->CTRL2 ={v} _4;
  _5 = &Flexcan_Ip_pData_16(D)->bitrate;
  FlexCAN_SetEnhancedNominalTimeSegments (pBase_17(D), _5);
  _6 = Flexcan_Ip_pData_16(D)->fd_enable;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _7 = &Flexcan_Ip_pData_16(D)->bitrate_cbt;
  FlexCAN_SetEnhancedDataTimeSegments (pBase_17(D), _7);
  goto <bb 8>; [INV]

  <bb 5> :
  _8 ={v} pBase_17(D)->CTRL2;
  _9 = _8 & 4294959103;
  pBase_17(D)->CTRL2 ={v} _9;
  _10 = Flexcan_Ip_pData_16(D)->fd_enable;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _11 = &Flexcan_Ip_pData_16(D)->bitrate;
  FlexCAN_SetExtendedTimeSegments (pBase_17(D), _11);
  _12 = &Flexcan_Ip_pData_16(D)->bitrate_cbt;
  FlexCAN_SetFDTimeSegments (pBase_17(D), _12);
  goto <bb 8>; [INV]

  <bb 7> :
  _13 = &Flexcan_Ip_pData_16(D)->bitrate;
  FlexCAN_SetTimeSegments (pBase_17(D), _13);

  <bb 8> :
  return;

}


FlexCAN_InitController (uint8 Instance, struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10533;
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  _Bool _4;
  _Bool _5;
  long unsigned int _6;
  Flexcan_Ip_StatusType _32;

  <bb 2> :
  eResult_11 = 0;
  _1 = FlexCAN_IsEnabled (pBase_13(D));
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  eResult_16 = FlexCAN_EnterFreezeMode (pBase_13(D));
  if (eResult_16 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  eResult_18 = FlexCAN_Disable (pBase_13(D));

  <bb 5> :
  # eResult_7 = PHI <eResult_11(2), eResult_16(3), eResult_18(4)>
  if (eResult_7 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _2 ={v} pBase_13(D)->MCR;
  _3 = _2 & 2147483647;
  pBase_13(D)->MCR ={v} _3;
  eResult_21 = FlexCAN_Init (pBase_13(D));
  if (eResult_21 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  FlexCAN_EnterFreezeMode (pBase_13(D));
  FlexCAN_Disable (pBase_13(D));
  goto <bb 9>; [INV]

  <bb 8> :
  FlexCAN_DisableMemErrorDetection (pBase_13(D));
  _4 = Flexcan_Ip_pData_23(D)->fd_enable;
  _5 = Flexcan_Ip_pData_23(D)->bitRateSwitch;
  FlexCAN_SetFDEnabled (pBase_13(D), _4, _5);
  _6 = Flexcan_Ip_pData_23(D)->ctrlOptions;
  FlexCAN_ConfigCtrlOptions (pBase_13(D), _6);
  FlexCAN_ResetImaskBuff (Instance_26(D));
  eResult_29 = FlexCAN_InitCtroll (pBase_13(D), Flexcan_Ip_pData_23(D));

  <bb 9> :
  # eResult_8 = PHI <eResult_7(5), eResult_21(7), eResult_29(8)>
  _32 = eResult_8;

  <bb 10> :
<L9>:
  return _32;

}


FlexCAN_InitCtroll (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10518;
  <unnamed type> _1;
  const struct Flexcan_Ip_PayloadSizeType * _2;
  long unsigned int _3;
  Flexcan_Ip_StatusType _21;

  <bb 2> :
  eResult_7 = 0;
  _1 = Flexcan_Ip_pData_9(D)->flexcanMode;
  if (_1 != 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  FlexCAN_SetSelfReception (pBase_10(D), 0);

  <bb 4> :
  eResult_13 = FlexCAN_InitRxFifo (pBase_10(D), Flexcan_Ip_pData_9(D));
  if (eResult_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  FlexCAN_EnterFreezeMode (pBase_10(D));
  FlexCAN_Disable (pBase_10(D));
  goto <bb 8>; [INV]

  <bb 6> :
  _2 = &Flexcan_Ip_pData_9(D)->payload;
  FlexCAN_SetPayloadSize (pBase_10(D), _2);
  _3 = Flexcan_Ip_pData_9(D)->max_num_mb;
  eResult_16 = FlexCAN_SetMaxMsgBuffNum (pBase_10(D), _3);
  if (eResult_16 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  FlexCAN_EnterFreezeMode (pBase_10(D));
  FlexCAN_Disable (pBase_10(D));

  <bb 8> :
  # eResult_4 = PHI <eResult_13(5), eResult_16(6), eResult_16(7)>
  _21 = eResult_4;

  <bb 9> :
<L7>:
  return _21;

}


FlexCAN_InitRxFifo (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.10509;
  _Bool _1;
  <unnamed type> _2;
  _Bool _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  Flexcan_Ip_StatusType _19;

  <bb 2> :
  eResult_11 = 0;
  _1 = Flexcan_Ip_pData_13(D)->is_rx_fifo_needed;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = Flexcan_Ip_pData_13(D)->num_id_filters;
  eResult_16 = FlexCAN_EnableRxFifo (pBase_14(D), _2);

  <bb 4> :
  # eResult_7 = PHI <eResult_11(2), eResult_16(3)>
  if (eResult_7 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _3 = Flexcan_Ip_pData_13(D)->is_enhanced_rx_fifo_needed;
  if (_3 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _4 = Flexcan_Ip_pData_13(D)->num_enhanced_std_id_filters;
  _5 = Flexcan_Ip_pData_13(D)->num_enhanced_ext_id_filters;
  _6 = Flexcan_Ip_pData_13(D)->num_enhanced_watermark;
  eResult_18 = FlexCAN_EnableEnhancedRxFifo (pBase_14(D), _4, _5, _6);

  <bb 7> :
  # eResult_8 = PHI <eResult_7(4), eResult_7(5), eResult_18(6)>
  _19 = eResult_8;

  <bb 8> :
<L6>:
  return _19;

}


FlexCAN_SetRegDefaultVal (struct FLEXCAN_Type * base)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;

  <bb 2> :
  _1 = FlexCAN_IsEnhancedRxFifoAvailable (base_16(D));
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base_16(D)->ERFSR ={v} 4160749568;
  base_16(D)->ERFIER ={v} 0;
  base_16(D)->ERFCR ={v} 0;

  <bb 4> :
  base_16(D)->FDCBT ={v} 0;
  base_16(D)->FDCTRL ={v} 2147500288;
  base_16(D)->ERRSR ={v} 851981;
  base_16(D)->ERRIPPR ={v} 0;
  base_16(D)->ERRIDPR ={v} 0;
  base_16(D)->ERRIAR ={v} 0;
  _2 ={v} base_16(D)->CTRL2;
  _3 = _2 | 536870912;
  base_16(D)->CTRL2 ={v} _3;
  _4 ={v} base_16(D)->MECR;
  _5 = _4 & 2147483647;
  base_16(D)->MECR ={v} _5;
  base_16(D)->MECR ={v} 786560;
  _6 ={v} base_16(D)->MECR;
  _7 = _6 | 2147483648;
  base_16(D)->MECR ={v} _7;
  _8 ={v} base_16(D)->CTRL2;
  _9 = _8 & 3758096383;
  base_16(D)->CTRL2 ={v} _9;
  _10 = FlexCAN_GetMaxMbNum (base_16(D));
  if (_10 > 64)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  base_16(D)->IFLAG3 ={v} 4294967295;
  base_16(D)->IMASK3 ={v} 0;

  <bb 6> :
  _11 = FlexCAN_GetMaxMbNum (base_16(D));
  if (_11 > 32)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  base_16(D)->IFLAG2 ={v} 4294967295;
  base_16(D)->IMASK2 ={v} 0;

  <bb 8> :
  base_16(D)->IFLAG1 ={v} 4294967295;
  base_16(D)->IMASK1 ={v} 0;
  base_16(D)->CBT ={v} 0;
  base_16(D)->CTRL2 ={v} 1048576;
  base_16(D)->ESR1 ={v} 241670;
  base_16(D)->ECR ={v} 0;
  base_16(D)->TIMER ={v} 0;
  base_16(D)->CTRL1 ={v} 0;
  base_16(D)->EPRS ={v} 0;
  base_16(D)->ENCBT ={v} 0;
  base_16(D)->EDCBT ={v} 0;
  base_16(D)->ETDC ={v} 0;
  base_16(D)->MCR ={v} 3633315855;
  return;

}


FlexCAN_GetEnhancedRxFIFOIntStatusFlag (const struct FLEXCAN_Type * base, uint32 intFlag)
{
  uint8 D.10917;
  long unsigned int _1;
  unsigned char _2;
  int _3;
  int _4;
  long unsigned int _5;
  long unsigned int _6;
  unsigned char _7;
  int _8;
  int _9;
  long unsigned int _10;
  uint8 _14;

  <bb 2> :
  _1 ={v} base_12(D)->ERFIER;
  _2 = (unsigned char) intFlag_13(D);
  _3 = (int) _2;
  _4 = _3 & 31;
  _5 = 1 << _4;
  _6 = _1 & _5;
  _7 = (unsigned char) intFlag_13(D);
  _8 = (int) _7;
  _9 = _8 & 31;
  _10 = _6 >> _9;
  _14 = (uint8) _10;

  <bb 3> :
<L0>:
  return _14;

}


FlexCAN_ClearEnhancedRxFifoIntStatusFlag (struct FLEXCAN_Type * base, uint32 intFlag)
{
  long unsigned int _1;

  <bb 2> :
  _1 = 1 << intFlag_2(D);
  base_4(D)->ERFSR ={v} _1;
  return;

}


FlexCAN_GetEnhancedRxFIFOStatusFlag (const struct FLEXCAN_Type * base, uint32 intFlag)
{
  uint8 D.10590;
  long unsigned int _1;
  unsigned char _2;
  int _3;
  int _4;
  long unsigned int _5;
  long unsigned int _6;
  unsigned char _7;
  int _8;
  int _9;
  long unsigned int _10;
  uint8 _14;

  <bb 2> :
  _1 ={v} base_12(D)->ERFSR;
  _2 = (unsigned char) intFlag_13(D);
  _3 = (int) _2;
  _4 = _3 & 31;
  _5 = 1 << _4;
  _6 = _1 & _5;
  _7 = (unsigned char) intFlag_13(D);
  _8 = (int) _7;
  _9 = _8 & 31;
  _10 = _6 >> _9;
  _14 = (uint8) _10;

  <bb 3> :
<L0>:
  return _14;

}


FlexCAN_SetEnhancedRxFifoIntAll (struct FLEXCAN_Type * base, boolean enable)
{
  <bb 2> :
  if (enable_2(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base_4(D)->ERFIER ={v} 4026531840;
  goto <bb 5>; [INV]

  <bb 4> :
  base_4(D)->ERFIER ={v} 0;

  <bb 5> :
  return;

}


FlexCAN_IsEnhancedRxFifoEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.10793;
  long unsigned int _1;
  signed int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->ERFCR;
  _2 = (signed int) _1;
  _5 = _2 < 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetRxMaskType (struct FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;

  <bb 2> :
  if (type_6(D) == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 ={v} base_8(D)->MCR;
  _2 = _1 & 4294901759;
  base_8(D)->MCR ={v} _2;
  goto <bb 5>; [INV]

  <bb 4> :
  _3 ={v} base_8(D)->MCR;
  _4 = _3 | 65536;
  base_8(D)->MCR ={v} _4;

  <bb 5> :
  return;

}


FlexCAN_SetTxArbitrationStartDelay (struct FLEXCAN_Type * base, uint8 tasd)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;

  <bb 2> :
  _1 ={v} base_8(D)->CTRL2;
  _2 = _1 & 4278714367;
  _3 = (long unsigned int) tasd_9(D);
  _4 = _3 << 19;
  _5 = _4 & 16252928;
  _6 = _2 | _5;
  base_8(D)->CTRL2 ={v} _6;
  return;

}


FlexCAN_IsFreezeMode (const struct FLEXCAN_Type * base)
{
  boolean D.10823;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->MCR;
  _2 = _1 & 16777216;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetRxIndividualMask (struct FLEXCAN_Type * base, uint32 msgBuffIdx, uint32 mask)
{
  <bb 2> :
  base_2(D)->RXIMR[msgBuffIdx_3(D)] ={v} mask_4(D);
  return;

}


FlexCAN_SetRxMsgBuffGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  base_2(D)->RXMGMASK ={v} Mask_3(D);
  return;

}


FlexCAN_GetMsgBuffIntStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 mask;
  uint8 flag;
  uint8 D.10903;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  unsigned char _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  unsigned char _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  unsigned char _15;
  uint8 _27;

  <bb 2> :
  flag_17 = 0;
  if (msgBuffIdx_18(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  mask_25 ={v} base_20(D)->IMASK1;
  _1 ={v} base_20(D)->IFLAG1;
  _2 = mask_25 & _1;
  _3 = msgBuffIdx_18(D) & 31;
  _4 = _2 >> _3;
  _5 = (unsigned char) _4;
  flag_26 = _5 & 1;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx_18(D) <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  mask_23 ={v} base_20(D)->IMASK2;
  _6 ={v} base_20(D)->IFLAG2;
  _7 = mask_23 & _6;
  _8 = msgBuffIdx_18(D) & 31;
  _9 = _7 >> _8;
  _10 = (unsigned char) _9;
  flag_24 = _10 & 1;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx_18(D) <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  mask_21 ={v} base_20(D)->IMASK3;
  _11 ={v} base_20(D)->IFLAG3;
  _12 = mask_21 & _11;
  _13 = msgBuffIdx_18(D) & 31;
  _14 = _12 >> _13;
  _15 = (unsigned char) _14;
  flag_22 = _15 & 1;

  <bb 8> :
  # flag_16 = PHI <flag_26(3), flag_24(5), flag_17(6), flag_22(7)>
  _27 = flag_16;

  <bb 9> :
<L9>:
  return _27;

}


RxFifoOcuppiedLastMsgBuff (uint32 x)
{
  uint32 D.10730;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  uint32 _5;

  <bb 2> :
  _1 = x_4(D) + 1;
  _2 = _1 * 8;
  _3 = _2 / 4;
  _5 = _3 + 5;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_IsListenOnlyModeEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.10744;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->CTRL1;
  _2 = _1 & 8;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_IsFDEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.11197;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} base_4(D)->MCR;
  _2 = _1 & 2048;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetSelfReception (struct FLEXCAN_Type * base, boolean enable)
{
  long unsigned int iftmp.0;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.0_4;
  long unsigned int iftmp.0_8;
  long unsigned int iftmp.0_9;

  <bb 2> :
  _1 ={v} base_6(D)->MCR;
  _2 = _1 & 4294836223;
  if (enable_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0_9 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0_8 = 131072;

  <bb 5> :
  # iftmp.0_4 = PHI <iftmp.0_9(3), iftmp.0_8(4)>
  _3 = iftmp.0_4 | _2;
  base_6(D)->MCR ={v} _3;
  return;

}


FlexCAN_EnableExtCbt (struct FLEXCAN_Type * base, boolean enableCBT)
{
  long unsigned int iftmp.3;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.3_4;
  long unsigned int iftmp.3_8;
  long unsigned int iftmp.3_9;

  <bb 2> :
  _1 ={v} base_6(D)->CBT;
  _2 = _1 & 2147483647;
  if (enableCBT_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.3_9 = 2147483648;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.3_8 = 0;

  <bb 5> :
  # iftmp.3_4 = PHI <iftmp.3_9(3), iftmp.3_8(4)>
  _3 = iftmp.3_4 | _2;
  base_6(D)->CBT ={v} _3;
  return;

}


FlexCAN_EnhCbtEnable (struct FLEXCAN_Type * base, boolean enableCBT)
{
  long unsigned int iftmp.8;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.8_4;
  long unsigned int iftmp.8_8;
  long unsigned int iftmp.8_9;

  <bb 2> :
  _1 ={v} base_6(D)->CTRL2;
  _2 = _1 & 4294959103;
  if (enableCBT_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.8_9 = 8192;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.8_8 = 0;

  <bb 5> :
  # iftmp.8_4 = PHI <iftmp.8_9(3), iftmp.8_8(4)>
  _3 = iftmp.8_4 | _2;
  base_6(D)->CTRL2 ={v} _3;
  return;

}


FlexCAN_IsEnhCbtEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.11165;
  long unsigned int _1;
  long unsigned int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} pBase_4(D)->CTRL2;
  _2 = _1 & 8192;
  _5 = _2 != 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_IsExCbtEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.11155;
  long unsigned int _1;
  signed int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} pBase_4(D)->CBT;
  _2 = (signed int) _1;
  _5 = _2 < 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_GetFDTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;

  <bb 2> :
  _1 ={v} base_16(D)->FDCBT;
  _2 = _1 >> 20;
  _3 = _2 & 1023;
  timeSeg_17(D)->preDivider = _3;
  _4 ={v} base_16(D)->FDCBT;
  _5 = _4 >> 10;
  _6 = _5 & 31;
  timeSeg_17(D)->propSeg = _6;
  _7 ={v} base_16(D)->FDCBT;
  _8 = _7 >> 5;
  _9 = _8 & 7;
  timeSeg_17(D)->phaseSeg1 = _9;
  _10 ={v} base_16(D)->FDCBT;
  _11 = _10 & 7;
  timeSeg_17(D)->phaseSeg2 = _11;
  _12 ={v} base_16(D)->FDCBT;
  _13 = _12 >> 16;
  _14 = _13 & 7;
  timeSeg_17(D)->rJumpwidth = _14;
  return;

}


FlexCAN_GetTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;

  <bb 2> :
  _1 ={v} base_16(D)->CTRL1;
  _2 = _1 >> 24;
  _3 = _2 & 255;
  timeSeg_17(D)->preDivider = _3;
  _4 ={v} base_16(D)->CTRL1;
  _5 = _4 & 7;
  timeSeg_17(D)->propSeg = _5;
  _6 ={v} base_16(D)->CTRL1;
  _7 = _6 >> 19;
  _8 = _7 & 7;
  timeSeg_17(D)->phaseSeg1 = _8;
  _9 ={v} base_16(D)->CTRL1;
  _10 = _9 >> 16;
  _11 = _10 & 7;
  timeSeg_17(D)->phaseSeg2 = _11;
  _12 ={v} base_16(D)->CTRL1;
  _13 = _12 >> 22;
  _14 = _13 & 3;
  timeSeg_17(D)->rJumpwidth = _14;
  return;

}


FlexCAN_GetExtendedTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;

  <bb 2> :
  _1 ={v} base_16(D)->CBT;
  _2 = _1 >> 21;
  _3 = _2 & 1023;
  timeSeg_17(D)->preDivider = _3;
  _4 ={v} base_16(D)->CBT;
  _5 = _4 >> 10;
  _6 = _5 & 63;
  timeSeg_17(D)->propSeg = _6;
  _7 ={v} base_16(D)->CBT;
  _8 = _7 >> 5;
  _9 = _8 & 31;
  timeSeg_17(D)->phaseSeg1 = _9;
  _10 ={v} base_16(D)->CBT;
  _11 = _10 & 31;
  timeSeg_17(D)->phaseSeg2 = _11;
  _12 ={v} base_16(D)->CBT;
  _13 = _12 >> 16;
  _14 = _13 & 31;
  timeSeg_17(D)->rJumpwidth = _14;
  return;

}


FlexCAN_GetEnhancedDataTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;

  <bb 2> :
  _1 = timeSeg_13(D) != 0B;
  DevAssert (_1);
  timeSeg_13(D)->propSeg = 0;
  _2 ={v} base_17(D)->EDCBT;
  _3 = _2 & 31;
  timeSeg_13(D)->phaseSeg1 = _3;
  _4 ={v} base_17(D)->EDCBT;
  _5 = _4 >> 12;
  _6 = _5 & 15;
  timeSeg_13(D)->phaseSeg2 = _6;
  _7 ={v} base_17(D)->EDCBT;
  _8 = _7 >> 22;
  _9 = _8 & 15;
  timeSeg_13(D)->rJumpwidth = _9;
  _10 ={v} base_17(D)->EPRS;
  _11 = _10 >> 16;
  _12 = _11 & 1023;
  timeSeg_13(D)->preDivider = _12;
  return;

}


FlexCAN_SetEnhancedDataTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;
  long unsigned int _24;

  <bb 2> :
  _1 = timeSeg_25(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_28(D)->EDCBT;
  _3 = _2 & 4231991264;
  base_28(D)->EDCBT ={v} _3;
  _4 ={v} base_28(D)->EDCBT;
  _5 = timeSeg_25(D)->phaseSeg1;
  _6 = timeSeg_25(D)->propSeg;
  _7 = _5 + _6;
  _8 = _7 & 31;
  _9 = timeSeg_25(D)->phaseSeg2;
  _10 = _9 << 12;
  _11 = _10 & 65535;
  _12 = _8 | _11;
  _13 = timeSeg_25(D)->rJumpwidth;
  _14 = _13 << 22;
  _15 = _14 & 62914560;
  _16 = _12 | _15;
  _17 = _4 | _16;
  base_28(D)->EDCBT ={v} _17;
  _18 ={v} base_28(D)->EPRS;
  _19 = _18 & 4227923967;
  base_28(D)->EPRS ={v} _19;
  _20 ={v} base_28(D)->EPRS;
  _21 = timeSeg_25(D)->preDivider;
  _22 = _21 << 16;
  _23 = _22 & 67043328;
  _24 = _20 | _23;
  base_28(D)->EPRS ={v} _24;
  return;

}


FlexCAN_GetEnhancedNominalTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;

  <bb 2> :
  timeSeg_12(D)->propSeg = 0;
  _1 ={v} base_14(D)->EPRS;
  _2 = _1 & 1023;
  timeSeg_12(D)->preDivider = _2;
  _3 ={v} base_14(D)->ENCBT;
  _4 = _3 & 255;
  timeSeg_12(D)->phaseSeg1 = _4;
  _5 ={v} base_14(D)->ENCBT;
  _6 = _5 >> 12;
  _7 = _6 & 127;
  timeSeg_12(D)->phaseSeg2 = _7;
  _8 ={v} base_14(D)->ENCBT;
  _9 = _8 >> 22;
  _10 = _9 & 127;
  timeSeg_12(D)->rJumpwidth = _10;
  return;

}


FlexCAN_SetEnhancedNominalTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;
  long unsigned int _24;

  <bb 2> :
  _1 = timeSeg_25(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_28(D)->ENCBT;
  _3 = _2 & 3761770240;
  base_28(D)->ENCBT ={v} _3;
  _4 ={v} base_28(D)->ENCBT;
  _5 = timeSeg_25(D)->phaseSeg1;
  _6 = timeSeg_25(D)->propSeg;
  _7 = _5 + _6;
  _8 = _7 + 1;
  _9 = _8 & 255;
  _10 = timeSeg_25(D)->phaseSeg2;
  _11 = _10 << 12;
  _12 = _11 & 520192;
  _13 = _9 | _12;
  _14 = timeSeg_25(D)->rJumpwidth;
  _15 = _14 << 22;
  _16 = _15 & 532676608;
  _17 = _13 | _16;
  _18 = _4 | _17;
  base_28(D)->ENCBT ={v} _18;
  _19 ={v} base_28(D)->EPRS;
  _20 = _19 & 4294966272;
  base_28(D)->EPRS ={v} _20;
  _21 ={v} base_28(D)->EPRS;
  _22 = timeSeg_25(D)->preDivider;
  _23 = _22 & 1023;
  _24 = _21 | _23;
  base_28(D)->EPRS ={v} _24;
  return;

}


FlexCAN_SetExtendedTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;

  <bb 2> :
  _1 = timeSeg_24(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_27(D)->CBT;
  _3 = _2 & 2147483648;
  base_27(D)->CBT ={v} _3;
  _4 ={v} base_27(D)->CBT;
  _5 = timeSeg_24(D)->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 65535;
  _8 = timeSeg_24(D)->phaseSeg2;
  _9 = _8 & 31;
  _10 = _7 | _9;
  _11 = timeSeg_24(D)->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 992;
  _14 = _10 | _13;
  _15 = timeSeg_24(D)->preDivider;
  _16 = _15 << 21;
  _17 = _16 & 2145386496;
  _18 = _14 | _17;
  _19 = timeSeg_24(D)->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 2031616;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base_27(D)->CBT ={v} _23;
  return;

}


FlexCAN_SetTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;

  <bb 2> :
  _1 = timeSeg_23(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_26(D)->CTRL1;
  _3 = _2 & 65528;
  base_26(D)->CTRL1 ={v} _3;
  _4 ={v} base_26(D)->CTRL1;
  _5 = timeSeg_23(D)->propSeg;
  _6 = _5 & 7;
  _7 = timeSeg_23(D)->phaseSeg2;
  _8 = _7 << 16;
  _9 = _8 & 458752;
  _10 = _6 | _9;
  _11 = timeSeg_23(D)->phaseSeg1;
  _12 = _11 << 19;
  _13 = _12 & 3670016;
  _14 = _10 | _13;
  _15 = timeSeg_23(D)->preDivider;
  _16 = _15 << 24;
  _17 = _14 | _16;
  _18 = timeSeg_23(D)->rJumpwidth;
  _19 = _18 << 22;
  _20 = _19 & 12582912;
  _21 = _17 | _20;
  _22 = _4 | _21;
  base_26(D)->CTRL1 ={v} _22;
  return;

}


FlexCAN_SetFDTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  _Bool _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;

  <bb 2> :
  _1 = timeSeg_24(D) != 0B;
  DevAssert (_1);
  _2 ={v} base_27(D)->FDCBT;
  _3 = _2 & 3221783320;
  base_27(D)->FDCBT ={v} _3;
  _4 ={v} base_27(D)->FDCBT;
  _5 = timeSeg_24(D)->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 31744;
  _8 = timeSeg_24(D)->phaseSeg2;
  _9 = _8 & 7;
  _10 = _7 | _9;
  _11 = timeSeg_24(D)->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 255;
  _14 = _10 | _13;
  _15 = timeSeg_24(D)->preDivider;
  _16 = _15 << 20;
  _17 = _16 & 1072693248;
  _18 = _14 | _17;
  _19 = timeSeg_24(D)->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 458752;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base_27(D)->FDCBT ={v} _23;
  return;

}


FlexCAN_GetBuffStatusImask (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 u32Imask;
  uint8 D.10940;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  uint8 _24;

  <bb 2> :
  u32Imask_17 = 0;
  if (msgBuffIdx_18(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 ={v} base_20(D)->IMASK1;
  _2 = msgBuffIdx_18(D) & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx_18(D) & 31;
  u32Imask_23 = _4 >> _5;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx_18(D) <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 ={v} base_20(D)->IMASK2;
  _7 = msgBuffIdx_18(D) & 31;
  _8 = 1 << _7;
  _9 = _6 & _8;
  _10 = msgBuffIdx_18(D) & 31;
  u32Imask_22 = _9 >> _10;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx_18(D) <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _11 ={v} base_20(D)->IMASK3;
  _12 = msgBuffIdx_18(D) & 31;
  _13 = 1 << _12;
  _14 = _11 & _13;
  _15 = msgBuffIdx_18(D) & 31;
  u32Imask_21 = _14 >> _15;

  <bb 8> :
  # u32Imask_16 = PHI <u32Imask_23(3), u32Imask_22(5), u32Imask_17(6), u32Imask_21(7)>
  _24 = (uint8) u32Imask_16;

  <bb 9> :
<L9>:
  return _24;

}


FlexCAN_GetBuffStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;
  uint8 D.10615;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  uint8 _24;

  <bb 2> :
  flag_17 = 0;
  if (msgBuffIdx_18(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 ={v} base_20(D)->IFLAG1;
  _2 = msgBuffIdx_18(D) & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx_18(D) & 31;
  flag_23 = _4 >> _5;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx_18(D) <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 ={v} base_20(D)->IFLAG2;
  _7 = msgBuffIdx_18(D) & 31;
  _8 = 1 << _7;
  _9 = _6 & _8;
  _10 = msgBuffIdx_18(D) & 31;
  flag_22 = _9 >> _10;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx_18(D) <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _11 ={v} base_20(D)->IFLAG3;
  _12 = msgBuffIdx_18(D) & 31;
  _13 = 1 << _12;
  _14 = _11 & _13;
  _15 = msgBuffIdx_18(D) & 31;
  flag_21 = _14 >> _15;

  <bb 8> :
  # flag_16 = PHI <flag_23(3), flag_22(5), flag_17(6), flag_21(7)>
  _24 = (uint8) flag_16;

  <bb 9> :
<L9>:
  return _24;

}


FlexCAN_ClearMsgBuffIntStatusFlag (struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;
  long unsigned int _1;

  <bb 2> :
  _1 = msgBuffIdx_3(D) & 31;
  flag_4 = 1 << _1;
  if (msgBuffIdx_3(D) <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  base_6(D)->IFLAG1 ={v} flag_4;
  goto <bb 8>; [INV]

  <bb 4> :
  if (msgBuffIdx_3(D) <= 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  base_6(D)->IFLAG2 ={v} flag_4;
  goto <bb 8>; [INV]

  <bb 6> :
  if (msgBuffIdx_3(D) <= 95)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  base_6(D)->IFLAG3 ={v} flag_4;

  <bb 8> :
  return;

}


FlexCAN_UnlockRxMsgBuff (const struct FLEXCAN_Type * base)
{
  long unsigned int vol.5;
  long unsigned int vol.5_3;

  <bb 2> :
  vol.5_3 ={v} base_2(D)->TIMER;
  return;

}


FlexCAN_SetListenOnlyMode (struct FLEXCAN_Type * base, boolean enableListenOnly)
{
  long unsigned int iftmp.10;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int iftmp.10_4;
  long unsigned int iftmp.10_8;
  long unsigned int iftmp.10_9;

  <bb 2> :
  _1 ={v} base_6(D)->CTRL1;
  _2 = _1 & 4294967287;
  if (enableListenOnly_7(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.10_9 = 8;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.10_8 = 0;

  <bb 5> :
  # iftmp.10_4 = PHI <iftmp.10_9(3), iftmp.10_8(4)>
  _3 = iftmp.10_4 | _2;
  base_6(D)->CTRL1 ={v} _3;
  return;

}


FlexCAN_SetFDEnabled (struct FLEXCAN_Type * base, boolean enableFD, boolean enableBRS)
{
  long unsigned int iftmp.2;
  long unsigned int iftmp.1;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int iftmp.1_9;
  long unsigned int iftmp.2_10;
  long unsigned int iftmp.1_14;
  long unsigned int iftmp.1_15;
  long unsigned int iftmp.2_18;
  long unsigned int iftmp.2_19;

  <bb 2> :
  _1 ={v} base_12(D)->MCR;
  _2 = _1 & 4294965247;
  if (enableFD_13(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1_15 = 2048;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1_14 = 0;

  <bb 5> :
  # iftmp.1_9 = PHI <iftmp.1_15(3), iftmp.1_14(4)>
  _3 = iftmp.1_9 | _2;
  base_12(D)->MCR ={v} _3;
  _4 ={v} base_12(D)->FDCTRL;
  _5 = _4 & 2147483647;
  if (enableBRS_17(D) != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  iftmp.2_19 = 2147483648;
  goto <bb 8>; [INV]

  <bb 7> :
  iftmp.2_18 = 0;

  <bb 8> :
  # iftmp.2_10 = PHI <iftmp.2_19(6), iftmp.2_18(7)>
  _6 = iftmp.2_10 | _5;
  base_12(D)->FDCTRL ={v} _6;
  _7 ={v} base_12(D)->FDCTRL;
  _8 = _7 & 4294926591;
  base_12(D)->FDCTRL ={v} _8;
  return;

}


FlexCAN_DisableMemErrorDetection (struct FLEXCAN_Type * base)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;

  <bb 2> :
  _1 ={v} base_8(D)->CTRL2;
  _2 = _1 | 536870912;
  base_8(D)->CTRL2 ={v} _2;
  base_8(D)->MECR ={v} 0;
  base_8(D)->MECR ={v} 0;
  _3 ={v} base_8(D)->MECR;
  _4 = _3 | 256;
  base_8(D)->MECR ={v} _4;
  _5 ={v} base_8(D)->CTRL2;
  _6 = _5 & 3758096383;
  base_8(D)->CTRL2 ={v} _6;
  return;

}


FlexCAN_IsEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.10535;
  long unsigned int _1;
  signed int _2;
  boolean _5;

  <bb 2> :
  _1 ={v} pBase_4(D)->MCR;
  _2 = (signed int) _1;
  _5 = _2 >= 0;

  <bb 3> :
<L0>:
  return _5;

}


FlexCAN_SetEnhancedTDCOffset (struct FLEXCAN_Type * base, boolean enable, uint8 offset)
{
  uint32 tmp;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;

  <bb 2> :
  tmp_7 ={v} base_6(D)->ETDC;
  tmp_8 = tmp_7 & 2139160575;
  if (enable_9(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  tmp_10 = tmp_8 | 2147483648;
  _1 = (long unsigned int) offset_11(D);
  _2 = _1 << 16;
  _3 = _2 & 8323072;
  tmp_12 = tmp_10 | _3;

  <bb 4> :
  # tmp_4 = PHI <tmp_8(2), tmp_12(3)>
  base_6(D)->ETDC ={v} tmp_4;
  return;

}


FlexCAN_SetTDCOffset (struct FLEXCAN_Type * base, boolean enable, uint8 offset)
{
  uint32 tmp;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;

  <bb 2> :
  tmp_7 ={v} base_6(D)->FDCTRL;
  tmp_8 = tmp_7 & 4294926591;
  if (enable_9(D) != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  tmp_10 = tmp_8 | 32768;
  _1 = (long unsigned int) offset_11(D);
  _2 = _1 << 8;
  _3 = _2 & 7936;
  tmp_12 = tmp_10 | _3;

  <bb 4> :
  # tmp_4 = PHI <tmp_8(2), tmp_12(3)>
  base_6(D)->FDCTRL ={v} tmp_4;
  return;

}


FlexCAN_SetRxFifoGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  base_2(D)->RXFGMASK ={v} Mask_3(D);
  return;

}


DevAssert (volatile boolean x)
{
  _Bool x.4_1;

  <bb 2> :
  x.4_1 ={v} x;
  if (x.4_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  __asm__ __volatile__("BKPT #0");
  goto <bb 3>; [INV]

  <bb 4> :
  return;

}


