Bctu_GetResolutionScaledResult (const uint8 AdcIdx, const uint32 RawResult)
{
  uint8 ResolutionBits;
  uint8 Resolution;
  static const uint8 ResolutionArray[4] = "\x0e\f\n\b";
  static const struct ADC_Type * const pAdcBaseTable[3] = {1074397184B, 1074413568B, 1074429952B};
  uint16 D.6801;

  <bb 2> :
  _1 = (int) AdcIdx;
  _2 = pAdcBaseTable[_1];
  _3 = _2->CALBISTREG;
  _4 = _3 >> 29;
  _5 = (unsigned char) _4;
  ResolutionBits = _5 & 3;
  _6 = (int) ResolutionBits;
  Resolution = ResolutionArray[_6];
  _7 = (unsigned int) Resolution;
  _8 = 15 - _7;
  _9 = RawResult >> _8;
  D.6801 = (uint16) _9;

  <bb 3> :
<L0>:
  return D.6801;

}


Bctu_ConfigAndUpdateFifoNotification (const uint32 Instance, const struct Bctu_Ip_FifoConfigType * const FifoConfigArray, const uint8 NumFifoConfigs)
{
  struct BCTU_Type * const BctuBasePtr;
  const struct Bctu_Ip_FifoConfigType * FifoConfig;
  uint32 Mask;
  uint8 Index;
  long unsigned int iftmp.11;
  long unsigned int iftmp.10;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  Index = 0;
  goto <bb 10>; [INV]

  <bb 3> :
  _1 = (unsigned int) Index;
  _2 = _1 * 28;
  FifoConfig = FifoConfigArray + _2;
  Mask = 0;
  _3 = FifoConfig->FifoDmaEnable;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _4 = FifoConfig->FifoIndex;
  _5 = (int) _4;
  iftmp.10 = 16777216 << _5;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.10 = 0;

  <bb 6> :
  Mask = iftmp.10 | Mask;
  _6 = FifoConfig->bEnNotif;
  if (_6 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = FifoConfig->FifoIndex;
  _8 = (int) _7;
  iftmp.11 = 65536 << _8;
  goto <bb 9>; [INV]

  <bb 8> :
  iftmp.11 = 0;

  <bb 9> :
  Mask = iftmp.11 | Mask;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65 ();
  _9 = BctuBasePtr->FIFOCR;
  _10 = ~Mask;
  _11 = _9 & _10;
  BctuBasePtr->FIFOCR = _11;
  _12 = BctuBasePtr->FIFOCR;
  _13 = Mask | _12;
  BctuBasePtr->FIFOCR = _13;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65 ();
  _14 = FifoConfig->FifoIndex;
  _15 = FifoConfig->WatermarkValue;
  Bctu_Ip_SetFifoWatermark (Instance, _14, _15);
  _16 = FifoConfig->FifoIndex;
  _17 = (int) _16;
  _18 = FifoConfig->WatermarkNotification;
  Bctu_Ip_axBctuState[Instance].FifoNotifications[_17].WatermarkNotification = _18;
  _19 = FifoConfig->FifoIndex;
  _20 = (int) _19;
  _21 = FifoConfig->UnderrunNotification;
  Bctu_Ip_axBctuState[Instance].FifoNotifications[_20].UnderrunNotification = _21;
  _22 = FifoConfig->FifoIndex;
  _23 = (int) _22;
  _24 = FifoConfig->OverrunNotification;
  Bctu_Ip_axBctuState[Instance].FifoNotifications[_23].OverrunNotification = _24;
  Index.12_25 = Index;
  Index = Index.12_25 + 1;

  <bb 10> :
  if (Index < NumFifoConfigs)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  return;

}


Bctu_Ip_IRQHandler (const uint32 Instance)
{
  const boolean CheckList;
  struct BCTU_Type * const BctuBasePtr;
  uint8 Index;
  long unsigned int vol.48;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  _1 = BctuBasePtr->MCR;
  _2 = _1 & 32;
  CheckList = _2 != 0;
  _3 = BctuBasePtr->MCR;
  _4 = _3 & 128;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = &BctuBasePtr->MSR;
  _6 = Bctu_Ip_axBctuState[Instance].TriggerNotification;
  Bctu_CheckAndCallNotification (Instance, _5, 32768, 2147483648, _6);

  <bb 4> :
  Index = 0;
  goto <bb 10>; [INV]

  <bb 5> :
  _7 = BctuBasePtr->MCR;
  _8 = (int) Index;
  _9 = _7 >> _8;
  _10 = _9 & 1;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _11 = &BctuBasePtr->MSR;
  _12 = (int) Index;
  _13 = 1 << _12;
  _14 = (int) Index;
  _15 = 65536 << _14;
  _16 = (int) Index;
  _17 = Bctu_Ip_axBctuState[Instance].AdcNotifications[_16].NewConvDataNotification;
  Bctu_CheckAndCallNotification (Instance, _11, _13, _15, _17);
  _18 = &BctuBasePtr->MSR;
  _19 = (int) Index;
  _20 = 16 << _19;
  _21 = (int) Index;
  _22 = 1048576 << _21;
  _23 = (int) Index;
  _24 = Bctu_Ip_axBctuState[Instance].AdcNotifications[_23].ConvDataOverrunNotification;
  Bctu_CheckAndCallNotification (Instance, _18, _20, _22, _24);

  <bb 7> :
  if (CheckList != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _25 = &BctuBasePtr->MSR;
  _26 = (int) Index;
  _27 = 256 << _26;
  _28 = (int) Index;
  _29 = 16777216 << _28;
  _30 = (int) Index;
  _31 = Bctu_Ip_axBctuState[Instance].AdcNotifications[_30].ListLastConversionNotification;
  Bctu_CheckAndCallNotification (Instance, _25, _27, _29, _31);

  <bb 9> :
  Index.47_32 = Index;
  Index = Index.47_32 + 1;

  <bb 10> :
  if (Index <= 2)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  vol.48 = BctuBasePtr->MSR;
  Index = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  Bctu_CheckAndCallFifoNotification (Instance, Index);
  Index.49_33 = Index;
  Index = Index.49_33 + 1;

  <bb 13> :
  if (Index <= 1)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  return;

}


Bctu_CheckAndCallFifoNotification (const uint32 Instance, const uint8 FifoIdx)
{
  uint32 FifoWatermarkMask;
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  _1 = BctuBasePtr->FIFOCR;
  _2 = (int) FifoIdx;
  _3 = 65536 << _2;
  _4 = _1 & _3;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  _5 = (int) FifoIdx;
  FifoWatermarkMask = 65536 << _5;
  _6 = BctuBasePtr->FIFOERR;
  _7 = FifoWatermarkMask & _6;
  if (_7 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _8 = Bctu_Ip_axBctuState[Instance].InitStatus;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _9 = (int) FifoIdx;
  _10 = Bctu_Ip_axBctuState[Instance].FifoNotifications[_9].WatermarkNotification;
  if (_10 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _11 = (int) FifoIdx;
  _12 = Bctu_Ip_axBctuState[Instance].FifoNotifications[_11].WatermarkNotification;
  _12 ();

  <bb 7> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69 ();
  _13 = BctuBasePtr->FIFOERR;
  _14 = FifoWatermarkMask | _13;
  BctuBasePtr->FIFOERR = _14;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69 ();

  <bb 8> :
  _15 = &BctuBasePtr->FIFOERR;
  _16 = (unsigned int) FifoIdx;
  _17 = _16 * 2;
  _18 = 16777216 << _17;
  _19 = (unsigned int) FifoIdx;
  _20 = _19 * 2;
  _21 = 16777216 << _20;
  _22 = (int) FifoIdx;
  _23 = Bctu_Ip_axBctuState[Instance].FifoNotifications[_22].OverrunNotification;
  Bctu_CheckAndCallNotification (Instance, _15, _18, _21, _23);
  _24 = &BctuBasePtr->FIFOERR;
  _25 = (unsigned int) FifoIdx;
  _26 = _25 * 2;
  _27 = 33554432 << _26;
  _28 = (unsigned int) FifoIdx;
  _29 = _28 * 2;
  _30 = 33554432 << _29;
  _31 = (int) FifoIdx;
  _32 = Bctu_Ip_axBctuState[Instance].FifoNotifications[_31].UnderrunNotification;
  Bctu_CheckAndCallNotification (Instance, _24, _27, _30, _32);

  <bb 9> :
  return;

}


Bctu_CheckAndCallNotification (const uint32 Instance, volatile uint32 * Reg, const uint32 Mask, const uint32 ClrMask, void (*<T51e>) (void) Callback)
{
  <bb 2> :
  _1 = *Reg;
  _2 = Mask & _1;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  *Reg = ClrMask;
  _3 = Bctu_Ip_axBctuState[Instance].InitStatus;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (Callback != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Callback ();

  <bb 6> :
  return;

}


Bctu_SetConvListLastElement (const uint32 Instance, const uint8 ElemIdx)
{
  uint8 ChanIdx;
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  ChanIdx = ElemIdx / 2;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68 ();
  _1 = ElemIdx & 1;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = (int) ChanIdx;
  _3 = BctuBasePtr->LISTCHR[_2];
  _4 = (int) ChanIdx;
  _5 = _3 | 2147483648;
  BctuBasePtr->LISTCHR[_4] = _5;
  goto <bb 5>; [INV]

  <bb 4> :
  _6 = (int) ChanIdx;
  _7 = BctuBasePtr->LISTCHR[_6];
  _8 = (int) ChanIdx;
  _9 = _7 | 32768;
  BctuBasePtr->LISTCHR[_8] = _9;

  <bb 5> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68 ();
  return;

}


Bctu_SetConvListElemWithTag (const uint32 Instance, const uint8 ElemIdx, const uint8 AdcChanNumbers, const boolean NextChanWaitOnTrig)
{
  uint32 u32TempListChr;
  uint8 ChanIdx;
  struct BCTU_Type * const BctuBasePtr;
  long unsigned int iftmp.9;
  long unsigned int iftmp.8;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  u32TempListChr = 0;
  ChanIdx = ElemIdx / 2;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67 ();
  _1 = (int) ChanIdx;
  u32TempListChr = BctuBasePtr->LISTCHR[_1];
  _2 = ElemIdx & 1;
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  u32TempListChr = u32TempListChr & 1065418751;
  _3 = (long unsigned int) AdcChanNumbers;
  _4 = _3 << 16;
  _5 = _4 & 8323072;
  u32TempListChr = u32TempListChr | _5;
  if (NextChanWaitOnTrig != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.8 = 1073741824;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.8 = 0;

  <bb 6> :
  u32TempListChr = iftmp.8 | u32TempListChr;
  goto <bb 11>; [INV]

  <bb 7> :
  u32TempListChr = u32TempListChr & 4294918016;
  _6 = (long unsigned int) AdcChanNumbers;
  _7 = _6 & 127;
  u32TempListChr = u32TempListChr | _7;
  if (NextChanWaitOnTrig != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  iftmp.9 = 16384;
  goto <bb 10>; [INV]

  <bb 9> :
  iftmp.9 = 0;

  <bb 10> :
  u32TempListChr = iftmp.9 | u32TempListChr;

  <bb 11> :
  _8 = (int) ChanIdx;
  BctuBasePtr->LISTCHR[_8] = u32TempListChr;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67 ();
  return;

}


Bctu_PrepareReconfigBlocking (struct BCTU_Type * const BctuBasePtr, const uint8 TrigIdx)
{
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  Bctu_Ip_StatusType Status;
  Bctu_Ip_StatusType D.6692;
  long unsigned int D.6687;

  <bb 2> :
  Status = 0;
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  ElapsedTicks = 0;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62 ();
  _2 = (int) TrigIdx;
  _3 = BctuBasePtr->TRGCFG[_2];
  _4 = (int) TrigIdx;
  _5 = _3 & 4294934527;
  BctuBasePtr->TRGCFG[_4] = _5;
  _6 = (int) TrigIdx;
  _7 = BctuBasePtr->TRGCFG[_6];
  _8 = (int) TrigIdx;
  _9 = _7 & 2147483647;
  BctuBasePtr->TRGCFG[_8] = _9;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62 ();
  goto <bb 4>; [INV]

  <bb 3> :
  D.6687 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.6687 + ElapsedTicks;

  <bb 4> :
  _10 = (int) TrigIdx;
  _11 = BctuBasePtr->TRGCFG[_10];
  _12 = _11 & 16384;
  if (_12 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Status = 2;
  goto <bb 9>; [INV]

  <bb 8> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62 ();
  _13 = (int) TrigIdx;
  _14 = BctuBasePtr->TRGCFG[_13];
  _15 = (int) TrigIdx;
  _16 = _14 | 16384;
  BctuBasePtr->TRGCFG[_15] = _16;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62 ();
  Status = 0;

  <bb 9> :
  D.6692 = Status;
  CurrentTicks = {CLOBBER};

  <bb 10> :
<L8>:
  return D.6692;

}


Bctu_PrepareReconfigNonBlocking (struct BCTU_Type * const BctuBasePtr, const uint8 TrigIdx)
{
  Bctu_Ip_StatusType Status;
  Bctu_Ip_StatusType D.6789;

  <bb 2> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61 ();
  _1 = (int) TrigIdx;
  _2 = BctuBasePtr->TRGCFG[_1];
  _3 = (int) TrigIdx;
  _4 = _2 & 4294934527;
  BctuBasePtr->TRGCFG[_3] = _4;
  _5 = (int) TrigIdx;
  _6 = BctuBasePtr->TRGCFG[_5];
  _7 = _6 & 16384;
  if (_7 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61 ();
  Status = 3;
  goto <bb 5>; [INV]

  <bb 4> :
  _8 = (int) TrigIdx;
  _9 = BctuBasePtr->TRGCFG[_8];
  _10 = (int) TrigIdx;
  _11 = _9 | 16384;
  BctuBasePtr->TRGCFG[_10] = _11;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61 ();
  Status = 0;

  <bb 5> :
  D.6789 = Status;

  <bb 6> :
<L3>:
  return D.6789;

}


Bctu_GetBitmask (const uint8 Pos)
{
  uint32 D.6653;

  <bb 2> :
  _1 = (int) Pos;
  D.6653 = 1 << _1;

  <bb 3> :
<L0>:
  return D.6653;

}


Bctu_CollectMcrMasks (const struct Bctu_Ip_ConfigType * const Config)
{
  uint8 Index;
  uint32 Mcr;
  uint32 D.6651;
  long unsigned int iftmp.5;
  long unsigned int iftmp.4;
  long unsigned int iftmp.3;
  long unsigned int iftmp.2;

  <bb 2> :
  Mcr = 0;
  _1 = Config->LowPowerModeEn;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.2 = 1073741824;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.2 = 0;

  <bb 5> :
  Mcr = iftmp.2 | Mcr;
  _2 = Config->GlobalHwTriggersEn;
  if (_2 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  iftmp.3 = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  iftmp.3 = 536870912;

  <bb 8> :
  Mcr = iftmp.3 | Mcr;
  Mcr = Mcr | 67108864;
  _3 = Config->TriggerNotification;
  if (_3 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  iftmp.4 = 128;
  goto <bb 11>; [INV]

  <bb 10> :
  iftmp.4 = 0;

  <bb 11> :
  Mcr = iftmp.4 | Mcr;
  Index = 0;
  goto <bb 21>; [INV]

  <bb 12> :
  _4 = (int) Index;
  _5 = Config->AdcNotifications[_4].NewConvDataNotification;
  if (_5 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  _6 = (int) Index;
  _7 = Config->AdcNotifications[_6].ConvDataOverrunNotification;
  if (_7 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _8 = (int) Index;
  _9 = 1 << _8;
  Mcr = Mcr | _9;

  <bb 15> :
  _10 = Config->NewDataDmaEnMask;
  _11 = (long unsigned int) _10;
  _12 = Bctu_GetBitmask (Index);
  _13 = _11 & _12;
  if (_13 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _14 = (int) Index;
  _15 = 65536 << _14;
  Mcr = Mcr | _15;

  <bb 17> :
  _16 = (int) Index;
  _17 = Config->AdcNotifications[_16].ListLastConversionNotification;
  if (_17 != 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  iftmp.5 = 32;
  goto <bb 20>; [INV]

  <bb 19> :
  iftmp.5 = 0;

  <bb 20> :
  Mcr = iftmp.5 | Mcr;
  Index.6_18 = Index;
  Index = Index.6_18 + 1;

  <bb 21> :
  if (Index <= 2)
    goto <bb 12>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 22> :
  D.6651 = Mcr;

  <bb 23> :
<L20>:
  return D.6651;

}


Bctu_Ip_GetFifoCount (const uint32 u32Instance, const uint8 u8FifoIdx)
{
  const struct BCTU_Type * const BctuBasePtr;
  uint8 Count;
  uint8 D.6805;

  <bb 2> :
  Count = 0;
  BctuBasePtr = 1074282496B;
  _1 = (int) u8FifoIdx;
  switch (_1) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  _2 = BctuBasePtr->FIFOCNTR;
  _3 = (unsigned char) _2;
  Count = _3 & 31;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  _4 = BctuBasePtr->FIFOCNTR;
  _5 = _4 >> 8;
  _6 = (unsigned char) _5;
  Count = _6 & 15;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  D.6805 = Count;

  <bb 7> :
<L4>:
  return D.6805;

}


Bctu_Ip_SetFifoWatermark (const uint32 u32Instance, const uint8 u8FifoIdx, const uint8 u8Watermark)
{
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66 ();
  _1 = (int) u8FifoIdx;
  switch (_1) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  _2 = BctuBasePtr->FIFOWM;
  _3 = _2 & 4294967280;
  BctuBasePtr->FIFOWM = _3;
  _4 = BctuBasePtr->FIFOWM;
  _5 = (long unsigned int) u8Watermark;
  _6 = _5 & 15;
  _7 = _4 | _6;
  BctuBasePtr->FIFOWM = _7;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  _8 = BctuBasePtr->FIFOWM;
  _9 = _8 & 4294965503;
  BctuBasePtr->FIFOWM = _9;
  _10 = BctuBasePtr->FIFOWM;
  _11 = (long unsigned int) u8Watermark;
  _12 = _11 << 8;
  _13 = _12 & 1792;
  _14 = _10 | _13;
  BctuBasePtr->FIFOWM = _14;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66 ();
  return;

}


Bctu_Ip_DisableNotifications (const uint32 u32Instance, const uint32 u32NotificationMask)
{
  struct BCTU_Type * const BctuBasePtr;
  uint32 Reg;

  <bb 2> :
  Reg = 0;
  BctuBasePtr = 1074282496B;
  _1 = u32NotificationMask >> 2;
  _2 = _1 & 1;
  Reg = Reg | _2;
  _3 = u32NotificationMask >> 2;
  _4 = _3 & 2;
  Reg = Reg | _4;
  _5 = u32NotificationMask >> 2;
  _6 = _5 & 4;
  Reg = Reg | _6;
  _7 = u32NotificationMask << 1;
  _8 = _7 & 128;
  Reg = Reg | _8;
  _9 = u32NotificationMask & 32;
  Reg = Reg | _9;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57 ();
  _10 = BctuBasePtr->MCR;
  _11 = ~Reg;
  _12 = _10 & _11;
  BctuBasePtr->MCR = _12;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57 ();
  Reg = 0;
  _13 = u32NotificationMask << 16;
  _14 = _13 & 65536;
  Reg = Reg | _14;
  _15 = u32NotificationMask << 16;
  _16 = _15 & 131072;
  Reg = Reg | _16;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64 ();
  _17 = BctuBasePtr->FIFOCR;
  _18 = ~Reg;
  _19 = _17 & _18;
  BctuBasePtr->FIFOCR = _19;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64 ();
  return;

}


Bctu_Ip_EnableNotifications (const uint32 u32Instance, const uint32 u32NotificationMask)
{
  struct BCTU_Type * const BctuBasePtr;
  uint32 Reg;

  <bb 2> :
  Reg = 0;
  BctuBasePtr = 1074282496B;
  _1 = u32NotificationMask >> 2;
  _2 = _1 & 1;
  Reg = Reg | _2;
  _3 = u32NotificationMask >> 2;
  _4 = _3 & 2;
  Reg = Reg | _4;
  _5 = u32NotificationMask >> 2;
  _6 = _5 & 4;
  Reg = Reg | _6;
  _7 = u32NotificationMask << 1;
  _8 = _7 & 128;
  Reg = Reg | _8;
  _9 = u32NotificationMask & 32;
  Reg = Reg | _9;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56 ();
  _10 = BctuBasePtr->MCR;
  _11 = Reg | _10;
  BctuBasePtr->MCR = _11;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56 ();
  Reg = 0;
  _12 = u32NotificationMask << 16;
  _13 = _12 & 65536;
  Reg = Reg | _13;
  _14 = u32NotificationMask << 16;
  _15 = _14 & 131072;
  Reg = Reg | _15;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63 ();
  _16 = BctuBasePtr->FIFOCR;
  _17 = Reg | _16;
  BctuBasePtr->FIFOCR = _17;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63 ();
  return;

}


Bctu_Ip_GetFifoResult (const uint32 u32Instance, const uint8 u8FifoIdx, struct Bctu_Ip_FifoResultType * const pResult)
{
  const struct BCTU_Type * const BctuBasePtr;
  uint32 TempResult;
  uint32 ResultFifo;

  <bb 2> :
  ResultFifo = 0;
  TempResult = 0;
  BctuBasePtr = 1074282496B;
  _1 = (int) u8FifoIdx;
  switch (_1) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  ResultFifo = BctuBasePtr->FIFO1DR;
  TempResult = ResultFifo & 32767;
  _2 = ResultFifo >> 25;
  _3 = (unsigned char) _2;
  pResult->TriggerIdx = _3;
  _4 = ResultFifo >> 18;
  _5 = (unsigned char) _4;
  _6 = _5 & 127;
  pResult->ChanIdx = _6;
  _7 = ResultFifo >> 16;
  _8 = (unsigned char) _7;
  _9 = _8 & 3;
  pResult->AdcNum = _9;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  ResultFifo = BctuBasePtr->FIFO2DR;
  TempResult = ResultFifo & 32767;
  _10 = ResultFifo >> 25;
  _11 = (unsigned char) _10;
  pResult->TriggerIdx = _11;
  _12 = ResultFifo >> 18;
  _13 = (unsigned char) _12;
  _14 = _13 & 127;
  pResult->ChanIdx = _14;
  _15 = ResultFifo >> 16;
  _16 = (unsigned char) _15;
  _17 = _16 & 3;
  pResult->AdcNum = _17;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  _18 = pResult->AdcNum;
  _19 = Bctu_GetResolutionScaledResult (_18, TempResult);
  pResult->AdcData = _19;
  return;

}


Bctu_Ip_GetFifoData (const uint32 u32Instance, const uint8 u8FifoIdx)
{
  const struct BCTU_Type * const BctuBasePtr;
  uint8 AdcIdx;
  uint32 ResultFifo;
  uint32 Data;
  uint16 D.6803;

  <bb 2> :
  Data = 0;
  ResultFifo = 0;
  AdcIdx = 0;
  BctuBasePtr = 1074282496B;
  _1 = (int) u8FifoIdx;
  switch (_1) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  ResultFifo = BctuBasePtr->FIFO1DR;
  _2 = ResultFifo >> 16;
  _3 = (unsigned char) _2;
  AdcIdx = _3 & 3;
  Data = ResultFifo & 32767;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  ResultFifo = BctuBasePtr->FIFO2DR;
  _4 = ResultFifo >> 16;
  _5 = (unsigned char) _4;
  AdcIdx = _5 & 3;
  Data = ResultFifo & 32767;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  D.6803 = Bctu_GetResolutionScaledResult (AdcIdx, Data);

  <bb 7> :
<L4>:
  return D.6803;

}


Bctu_Ip_GetConvResult (const uint32 u32Instance, const uint8 u8AdcIdx, struct Bctu_Ip_ResultType * const pResult)
{
  const struct BCTU_Type * const BctuBasePtr;
  uint32 dr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  _1 = (int) u8AdcIdx;
  dr = BctuBasePtr->ADCDR[_1];
  _2 = dr & 32767;
  _3 = Bctu_GetResolutionScaledResult (u8AdcIdx, _2);
  pResult->AdcData = _3;
  _4 = dr >> 18;
  _5 = (unsigned char) _4;
  _6 = _5 & 127;
  pResult->ChanIdx = _6;
  _7 = dr >> 25;
  _8 = (unsigned char) _7;
  pResult->TriggerIdx = _8;
  _9 = dr >> 16;
  _10 = (int) _9;
  _11 = _10 & 1;
  _12 = _11 != 0;
  pResult->LastFlag = _12;
  _13 = dr >> 17;
  _14 = (int) _13;
  _15 = _14 & 1;
  _16 = _15 != 0;
  pResult->ListFlag = _16;
  return;

}


Bctu_Ip_GetConvData (const uint32 u32Instance, const uint8 u8AdcIdx)
{
  const struct BCTU_Type * const BctuBasePtr;
  uint32 Data;
  uint16 D.6799;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  _1 = (int) u8AdcIdx;
  _2 = BctuBasePtr->ADCDR[_1];
  Data = _2 & 32767;
  D.6799 = Bctu_GetResolutionScaledResult (u8AdcIdx, Data);

  <bb 3> :
<L0>:
  return D.6799;

}


Bctu_Ip_SwTriggerConversion (const uint32 u32Instance, const uint8 u8TrigIdx)
{
  struct BCTU_Type * const BctuBasePtr;
  uint32 Bitmask;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  BctuBasePtr->WRPROT = 9;
  _1 = u8TrigIdx & 31;
  Bitmask = Bctu_GetBitmask (_1);
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71 ();
  _2 = u8TrigIdx / 32;
  _3 = (unsigned int) _2;
  switch (_3) <default: <L3> [INV], case 0: <L0> [INV], case 1: <L1> [INV], case 2: <L2> [INV]>

  <bb 3> :
<L0>:
  _4 = BctuBasePtr->SFTRGR1;
  _5 = Bitmask | _4;
  BctuBasePtr->SFTRGR1 = _5;
  goto <bb 7>; [INV]

  <bb 4> :
<L1>:
  _6 = BctuBasePtr->SFTRGR2;
  _7 = Bitmask | _6;
  BctuBasePtr->SFTRGR2 = _7;
  goto <bb 7>; [INV]

  <bb 5> :
<L2>:
  _8 = BctuBasePtr->SFTRGR3;
  _9 = Bitmask | _8;
  BctuBasePtr->SFTRGR3 = _9;
  goto <bb 7>; [INV]

  <bb 6> :
<L3>:

  <bb 7> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71 ();
  return;

}


Bctu_ConfigMultiAdcSubLists (const uint32 Instance, const struct Bctu_Ip_ListItemConfigType * const AdcCmdArray, const uint8 NumCmds)
{
  uint8 Index;

  <bb 2> :
  Index = 0;
  Index = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = Index & 31;
  _2 = (unsigned int) Index;
  _3 = _2 * 3;
  _4 = AdcCmdArray + _3;
  _5 = _4->AdcChanIndex;
  _6 = (unsigned int) Index;
  _7 = _6 * 3;
  _8 = AdcCmdArray + _7;
  _9 = _8->NextChanWaitOnTrig;
  Bctu_SetConvListElemWithTag (Instance, _1, _5, _9);
  _10 = (unsigned int) Index;
  _11 = _10 * 3;
  _12 = AdcCmdArray + _11;
  _13 = _12->LastChanInList;
  if (_13 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _14 = Index & 31;
  Bctu_SetConvListLastElement (Instance, _14);

  <bb 5> :
  Index.7_15 = Index;
  Index = Index.7_15 + 1;

  <bb 6> :
  if (Index < NumCmds)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}


Bctu_Ip_ConfigChanListSimple (const uint32 u32Instance, const uint8 u8StartListElemIdx, const uint8 * const pConvListItems, const uint8 u8NumItems)
{
  uint8 Index;

  <bb 2> :
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = Index + u8StartListElemIdx;
  _2 = _1 & 31;
  _3 = (sizetype) Index;
  _4 = pConvListItems + _3;
  _5 = *_4;
  Bctu_SetConvListElemWithTag (u32Instance, _2, _5, 0);
  Index.46_6 = Index;
  Index = Index.46_6 + 1;

  <bb 4> :
  if (Index < u8NumItems)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _7 = u8NumItems + u8StartListElemIdx;
  _8 = _7 + 255;
  _9 = _8 & 31;
  Bctu_SetConvListLastElement (u32Instance, _9);
  return;

}


Bctu_Ip_ConfigChanList (const uint32 u32Instance, const uint8 u8StartListElemIdx, const struct Bctu_Ip_ListItemType * const pConvListItems, const uint8 u8NumItems)
{
  uint8 Index;

  <bb 2> :
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = Index + u8StartListElemIdx;
  _2 = _1 & 31;
  _3 = (unsigned int) Index;
  _4 = _3 * 2;
  _5 = pConvListItems + _4;
  _6 = _5->AdcChanIndex;
  _7 = (unsigned int) Index;
  _8 = _7 * 2;
  _9 = pConvListItems + _8;
  _10 = _9->NextChanWaitOnTrig;
  Bctu_SetConvListElemWithTag (u32Instance, _2, _6, _10);
  Index.45_11 = Index;
  Index = Index.45_11 + 1;

  <bb 4> :
  if (Index < u8NumItems)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _12 = u8NumItems + u8StartListElemIdx;
  _13 = _12 + 255;
  _14 = _13 & 31;
  Bctu_SetConvListLastElement (u32Instance, _14);
  return;

}


Bctu_Ip_StopLoopConversions (const uint32 u32Instance, const uint8 u8TrigIdx)
{
  struct BCTU_Type * const BctuBasePtr;
  uint32 LoopBitmask;

  <bb 2> :
  LoopBitmask = 0;
  BctuBasePtr = 1074282496B;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60 ();
  _1 = (int) u8TrigIdx;
  _2 = BctuBasePtr->TRGCFG[_1];
  LoopBitmask = _2 & 2147483648;
  _3 = (int) u8TrigIdx;
  _4 = BctuBasePtr->TRGCFG[_3];
  _5 = (int) u8TrigIdx;
  _6 = _4 & 2147483647;
  BctuBasePtr->TRGCFG[_5] = _6;
  _7 = (int) u8TrigIdx;
  _8 = BctuBasePtr->TRGCFG[_7];
  _9 = LoopBitmask & 2147483648;
  _10 = (int) u8TrigIdx;
  _11 = _8 | _9;
  BctuBasePtr->TRGCFG[_10] = _11;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60 ();
  return;

}


Bctu_Ip_DisableHwTrigger (const uint32 u32Instance, const uint8 u8TrigIdx)
{
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59 ();
  _1 = (int) u8TrigIdx;
  _2 = BctuBasePtr->TRGCFG[_1];
  _3 = (int) u8TrigIdx;
  _4 = _2 & 4294934527;
  BctuBasePtr->TRGCFG[_3] = _4;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59 ();
  return;

}


Bctu_Ip_EnableHwTrigger (const uint32 u32Instance, const uint8 u8TrigIdx)
{
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58 ();
  _1 = (int) u8TrigIdx;
  _2 = BctuBasePtr->TRGCFG[_1];
  _3 = (int) u8TrigIdx;
  _4 = _2 | 16384;
  BctuBasePtr->TRGCFG[_3] = _4;
  _5 = (int) u8TrigIdx;
  _6 = BctuBasePtr->TRGCFG[_5];
  _7 = (int) u8TrigIdx;
  _8 = _6 | 32768;
  BctuBasePtr->TRGCFG[_7] = _8;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58 ();
  return;

}


Bctu_Ip_SetTriggerChnListAddr (const uint32 u32Instance, const uint8 u8TrigIdx, const boolean bList, const uint8 u8ChnOrListAddr)
{
  struct BCTU_Type * const BctuBasePtr;
  Bctu_Ip_StatusType Status;
  uint32 Trgcfg;
  Bctu_Ip_StatusType D.6797;
  long unsigned int iftmp.44;

  <bb 2> :
  Trgcfg = 0;
  BctuBasePtr = 1074282496B;
  Status = Bctu_PrepareReconfigNonBlocking (BctuBasePtr, u8TrigIdx);
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _1 = (int) u8TrigIdx;
  _2 = BctuBasePtr->TRGCFG[_1];
  _3 = (int) u8TrigIdx;
  _4 = _2 & 4294958976;
  BctuBasePtr->TRGCFG[_3] = _4;
  if (bList != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.44 = 8192;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.44 = 0;

  <bb 6> :
  Trgcfg = iftmp.44 | Trgcfg;
  _5 = (long unsigned int) u8ChnOrListAddr;
  _6 = _5 & 127;
  Trgcfg = Trgcfg | _6;
  _7 = (int) u8TrigIdx;
  _8 = BctuBasePtr->TRGCFG[_7];
  _9 = (int) u8TrigIdx;
  _10 = Trgcfg | _8;
  BctuBasePtr->TRGCFG[_9] = _10;

  <bb 7> :
  D.6797 = Status;

  <bb 8> :
<L5>:
  return D.6797;

}


Bctu_Ip_ConfigTrigger (const uint32 u32Instance, const struct Bctu_Ip_TrigConfigType * const pTrigConfig)
{
  struct BCTU_Type * const BctuBasePtr;
  Bctu_Ip_StatusType Status;
  uint8 Idx;
  uint32 Trgcfg;
  Bctu_Ip_StatusType D.6784;
  long unsigned int iftmp.42;
  long unsigned int iftmp.41;
  long unsigned int iftmp.40;
  long unsigned int iftmp.39;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  _1 = pTrigConfig->TrigIndex;
  Status = Bctu_PrepareReconfigNonBlocking (BctuBasePtr, _1);
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 3> :
  Trgcfg = 0;
  _2 = pTrigConfig->LoopEn;
  if (_2 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.39 = 2147483648;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.39 = 0;

  <bb 6> :
  Trgcfg = iftmp.39 | Trgcfg;
  _3 = pTrigConfig->HwTriggersEn;
  if (_3 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  iftmp.40 = 32768;
  goto <bb 9>; [INV]

  <bb 8> :
  iftmp.40 = 0;

  <bb 9> :
  Trgcfg = iftmp.40 | Trgcfg;
  _4 = pTrigConfig->DataDest;
  _5 = _4 << 28;
  _6 = _5 & 1879048192;
  Trgcfg = Trgcfg | _6;
  _7 = pTrigConfig->TrigType;
  _8 = _7 << 13;
  _9 = _8 & 8192;
  Trgcfg = Trgcfg | _9;
  _10 = pTrigConfig->AdcChanOrListStart;
  _11 = (long unsigned int) _10;
  _12 = _11 & 127;
  Trgcfg = Trgcfg | _12;
  _13 = pTrigConfig->AdcTargetMask;
  _14 = (int) _13;
  switch (_14) <default: <L10> [INV], case 1: <L7> [INV], case 2: <L8> [INV], case 4: <L9> [INV]>

  <bb 10> :
<L7>:
  Trgcfg = Trgcfg | 256;
  goto <bb 21>; [INV]

  <bb 11> :
<L8>:
  Trgcfg = Trgcfg | 512;
  goto <bb 21>; [INV]

  <bb 12> :
<L9>:
  Trgcfg = Trgcfg | 1024;
  goto <bb 21>; [INV]

  <bb 13> :
<L10>:
  _15 = pTrigConfig->TrigType;
  if (_15 == 1)
    goto <bb 14>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 14> :
  Idx = 0;
  goto <bb 19>; [INV]

  <bb 15> :
  _16 = pTrigConfig->AdcTargetMask;
  _17 = (long unsigned int) _16;
  _18 = Bctu_GetBitmask (Idx);
  _19 = _17 & _18;
  if (_19 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _20 = (int) Idx;
  iftmp.41 = 256 << _20;
  goto <bb 18>; [INV]

  <bb 17> :
  iftmp.41 = 0;

  <bb 18> :
  iftmp.42 = iftmp.41;
  Trgcfg = iftmp.42 | Trgcfg;
  Idx.43_21 = Idx;
  Idx = Idx.43_21 + 1;

  <bb 19> :
  if (Idx <= 2)
    goto <bb 15>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :

  <bb 21> :
  _22 = pTrigConfig->TrigIndex;
  _23 = (int) _22;
  BctuBasePtr->TRGCFG[_23] = Trgcfg;

  <bb 22> :
  D.6784 = Status;

  <bb 23> :
<L22>:
  return D.6784;

}


Bctu_Ip_ClearStatusFlags (const uint32 u32Instance, const uint32 u32Mask)
{
  struct BCTU_Type * const BctuBasePtr;
  uint8 Index;
  uint32 ClrMask;
  long unsigned int vol.38;
  long unsigned int iftmp.36;
  long unsigned int iftmp.35;
  long unsigned int iftmp.34;
  long unsigned int vol.33;
  long unsigned int iftmp.32;
  long unsigned int iftmp.30;
  long unsigned int iftmp.29;
  long unsigned int iftmp.28;

  <bb 2> :
  ClrMask = 0;
  BctuBasePtr = 1074282496B;
  Index = 0;
  goto <bb 13>; [INV]

  <bb 3> :
  _1 = (int) Index;
  _2 = 32768 << _1;
  _3 = u32Mask & _2;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _4 = (int) Index;
  iftmp.28 = 65536 << _4;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.28 = 0;

  <bb 6> :
  ClrMask = iftmp.28 | ClrMask;
  _5 = (int) Index;
  _6 = 262144 << _5;
  _7 = u32Mask & _6;
  if (_7 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _8 = (int) Index;
  iftmp.29 = 1048576 << _8;
  goto <bb 9>; [INV]

  <bb 8> :
  iftmp.29 = 0;

  <bb 9> :
  ClrMask = iftmp.29 | ClrMask;
  _9 = (int) Index;
  _10 = 2097152 << _9;
  _11 = u32Mask & _10;
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _12 = (int) Index;
  iftmp.30 = 16777216 << _12;
  goto <bb 12>; [INV]

  <bb 11> :
  iftmp.30 = 0;

  <bb 12> :
  ClrMask = iftmp.30 | ClrMask;
  Index.31_13 = Index;
  Index = Index.31_13 + 1;

  <bb 13> :
  if (Index <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = (int) Index;
  _15 = 64 << _14;
  _16 = u32Mask & _15;
  if (_16 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _17 = (int) Index;
  iftmp.32 = 2147483648 << _17;
  goto <bb 17>; [INV]

  <bb 16> :
  iftmp.32 = 0;

  <bb 17> :
  ClrMask = iftmp.32 | ClrMask;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70 ();
  _18 = BctuBasePtr->MSR;
  _19 = ClrMask | _18;
  BctuBasePtr->MSR = _19;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70 ();
  vol.33 = BctuBasePtr->MSR;
  ClrMask = 0;
  Index = 0;
  goto <bb 28>; [INV]

  <bb 18> :
  _20 = (int) Index;
  _21 = 512 << _20;
  _22 = u32Mask & _21;
  if (_22 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _23 = (int) Index;
  iftmp.34 = 65536 << _23;
  goto <bb 21>; [INV]

  <bb 20> :
  iftmp.34 = 0;

  <bb 21> :
  ClrMask = iftmp.34 | ClrMask;
  _24 = (unsigned int) Index;
  _25 = _24 * 2;
  _26 = 2048 << _25;
  _27 = u32Mask & _26;
  if (_27 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _28 = (int) Index;
  iftmp.35 = 16777216 << _28;
  goto <bb 24>; [INV]

  <bb 23> :
  iftmp.35 = 0;

  <bb 24> :
  ClrMask = iftmp.35 | ClrMask;
  _29 = (unsigned int) Index;
  _30 = _29 * 2;
  _31 = 8192 << _30;
  _32 = u32Mask & _31;
  if (_32 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  _33 = (int) Index;
  iftmp.36 = 33554432 << _33;
  goto <bb 27>; [INV]

  <bb 26> :
  iftmp.36 = 0;

  <bb 27> :
  ClrMask = iftmp.36 | ClrMask;
  Index.37_34 = Index;
  Index = Index.37_34 + 1;

  <bb 28> :
  if (Index <= 1)
    goto <bb 18>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 29> :
  BctuBasePtr->FIFOERR = ClrMask;
  vol.38 = BctuBasePtr->FIFOERR;
  return;

}


Bctu_Ip_GetStatusFlags (const uint32 u32Instance)
{
  const struct BCTU_Type * const BctuBasePtr;
  uint8 Index;
  uint32 Mask;
  uint32 Reg;
  uint32 D.6734;
  long unsigned int iftmp.26;
  long unsigned int iftmp.25;
  long unsigned int iftmp.24;
  long unsigned int iftmp.23;
  long unsigned int iftmp.22;
  long unsigned int iftmp.21;
  long unsigned int iftmp.19;
  long unsigned int iftmp.18;
  long unsigned int iftmp.17;

  <bb 2> :
  Mask = 0;
  BctuBasePtr = 1074282496B;
  Reg = BctuBasePtr->MSR;
  Index = 0;
  goto <bb 13>; [INV]

  <bb 3> :
  _1 = (int) Index;
  _2 = Reg >> _1;
  _3 = _2 & 1;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _4 = (int) Index;
  iftmp.17 = 32768 << _4;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.17 = 0;

  <bb 6> :
  Mask = iftmp.17 | Mask;
  _5 = (int) Index;
  _6 = 16 << _5;
  _7 = Reg & _6;
  if (_7 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _8 = (int) Index;
  iftmp.18 = 262144 << _8;
  goto <bb 9>; [INV]

  <bb 8> :
  iftmp.18 = 0;

  <bb 9> :
  Mask = iftmp.18 | Mask;
  _9 = (int) Index;
  _10 = 256 << _9;
  _11 = Reg & _10;
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _12 = (int) Index;
  iftmp.19 = 2097152 << _12;
  goto <bb 12>; [INV]

  <bb 11> :
  iftmp.19 = 0;

  <bb 12> :
  Mask = iftmp.19 | Mask;
  Index.20_13 = Index;
  Index = Index.20_13 + 1;

  <bb 13> :
  if (Index <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = (int) Index;
  _15 = 32768 << _14;
  _16 = Reg & _15;
  if (_16 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _17 = (int) Index;
  iftmp.21 = 64 << _17;
  goto <bb 17>; [INV]

  <bb 16> :
  iftmp.21 = 0;

  <bb 17> :
  Mask = iftmp.21 | Mask;
  Reg = BctuBasePtr->FIFOERR;
  Index = 0;
  goto <bb 31>; [INV]

  <bb 18> :
  _18 = BctuBasePtr->FIFOSR;
  _19 = (int) Index;
  _20 = _18 >> _19;
  _21 = _20 & 1;
  if (_21 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _22 = (int) Index;
  iftmp.22 = 128 << _22;
  goto <bb 21>; [INV]

  <bb 20> :
  iftmp.22 = 0;

  <bb 21> :
  iftmp.23 = iftmp.22;
  Mask = iftmp.23 | Mask;
  _23 = (int) Index;
  _24 = 65536 << _23;
  _25 = Reg & _24;
  if (_25 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _26 = (int) Index;
  iftmp.24 = 512 << _26;
  goto <bb 24>; [INV]

  <bb 23> :
  iftmp.24 = 0;

  <bb 24> :
  Mask = iftmp.24 | Mask;
  _27 = (unsigned int) Index;
  _28 = _27 * 2;
  _29 = 16777216 << _28;
  _30 = Reg & _29;
  if (_30 != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  _31 = (int) Index;
  iftmp.25 = 2048 << _31;
  goto <bb 27>; [INV]

  <bb 26> :
  iftmp.25 = 0;

  <bb 27> :
  Mask = iftmp.25 | Mask;
  _32 = (unsigned int) Index;
  _33 = _32 * 2;
  _34 = 33554432 << _33;
  _35 = Reg & _34;
  if (_35 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  _36 = (int) Index;
  iftmp.26 = 8192 << _36;
  goto <bb 30>; [INV]

  <bb 29> :
  iftmp.26 = 0;

  <bb 30> :
  Mask = iftmp.26 | Mask;
  Index.27_37 = Index;
  Index = Index.27_37 + 1;

  <bb 31> :
  if (Index <= 1)
    goto <bb 18>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 32> :
  D.6734 = Mask;

  <bb 33> :
<L30>:
  return D.6734;

}


Bctu_Ip_SetLowPowerMode (const uint32 u32Instance, const boolean bState)
{
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  if (bState != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55 ();
  _1 = BctuBasePtr->MCR;
  _2 = _1 | 1073741824;
  BctuBasePtr->MCR = _2;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55 ();
  goto <bb 5>; [INV]

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55 ();
  _3 = BctuBasePtr->MCR;
  _4 = _3 & 3221225471;
  BctuBasePtr->MCR = _4;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55 ();

  <bb 5> :
  return;

}


Bctu_Ip_SetGlobalTriggerEn (const uint32 u32Instance, const boolean bState)
{
  struct BCTU_Type * const BctuBasePtr;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  if (bState != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54 ();
  _1 = BctuBasePtr->MCR;
  _2 = _1 | 67108864;
  BctuBasePtr->MCR = _2;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54 ();
  goto <bb 5>; [INV]

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54 ();
  _3 = BctuBasePtr->MCR;
  _4 = _3 & 4227858431;
  BctuBasePtr->MCR = _4;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54 ();

  <bb 5> :
  return;

}


Bctu_Ip_Deinit (const uint32 u32Instance)
{
  struct BCTU_Type * const BctuBasePtr;
  Bctu_Ip_StatusType Status;
  uint8 Index;
  struct Bctu_Ip_ConfigType DefaultConfig;
  Bctu_Ip_StatusType D.6684;

  <bb 2> :
  Status = 0;
  BctuBasePtr = 1074282496B;
  _1 = BctuBasePtr->MCR;
  _2 = _1 & 4227858431;
  BctuBasePtr->MCR = _2;
  DefaultConfig.LowPowerModeEn = 0;
  DefaultConfig.GlobalHwTriggersEn = 0;
  DefaultConfig.NewDataDmaEnMask = 0;
  DefaultConfig.TriggerNotification = 0B;
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _3 = (int) Index;
  DefaultConfig.AdcNotifications[_3].NewConvDataNotification = 0B;
  _4 = (int) Index;
  DefaultConfig.AdcNotifications[_4].ConvDataOverrunNotification = 0B;
  _5 = (int) Index;
  DefaultConfig.AdcNotifications[_5].ListLastConversionNotification = 0B;
  Index.13_6 = Index;
  Index = Index.13_6 + 1;

  <bb 4> :
  if (Index <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  DefaultConfig.NumFifoConfigs = 0;
  DefaultConfig.FifoConfigs = 0B;
  DefaultConfig.NumTrigConfigs = 0;
  DefaultConfig.TrigConfigs = 0B;
  DefaultConfig.NumListItems = 0;
  DefaultConfig.ListItemConfigs = 0B;
  Bctu_Ip_Init (u32Instance, &DefaultConfig);
  Index = 0;
  goto <bb 10>; [INV]

  <bb 6> :
  _7 = Bctu_PrepareReconfigBlocking (BctuBasePtr, Index);
  if (_7 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _8 = (int) Index;
  BctuBasePtr->TRGCFG[_8] = 0;
  Status = 0;
  goto <bb 9>; [INV]

  <bb 8> :
  Status = 2;
  goto <bb 11>; [INV]

  <bb 9> :
  Index.14_9 = Index;
  Index = Index.14_9 + 1;

  <bb 10> :
  if (Index <= 71)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  if (Status == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 12> :
  Index = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  _10 = (int) Index;
  BctuBasePtr->LISTCHR[_10] = 0;
  Index.15_11 = Index;
  Index = Index.15_11 + 1;

  <bb 14> :
  if (Index <= 15)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  Index = 0;
  goto <bb 17>; [INV]

  <bb 16> :
  Bctu_Ip_SetFifoWatermark (u32Instance, Index, 0);
  Index.16_12 = Index;
  Index = Index.16_12 + 1;

  <bb 17> :
  if (Index <= 1)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  BctuBasePtr->FIFOCR = 0;
  Bctu_Ip_ClearStatusFlags (u32Instance, 16776768);
  Bctu_Ip_axBctuState[u32Instance].InitStatus = 0;

  <bb 19> :
  D.6684 = Status;
  DefaultConfig = {CLOBBER};

  <bb 20> :
<L18>:
  return D.6684;

}


Bctu_Ip_Init (const uint32 u32Instance, const struct Bctu_Ip_ConfigType * const pConfig)
{
  struct BCTU_Type * const BctuBasePtr;
  uint8 Index;

  <bb 2> :
  BctuBasePtr = 1074282496B;
  _1 = Bctu_CollectMcrMasks (pConfig);
  BctuBasePtr->MCR = _1;
  _2 = pConfig->TrigConfigs;
  if (_2 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _3 = pConfig->NumTrigConfigs;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  Index = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  _4 = pConfig->TrigConfigs;
  _5 = (unsigned int) Index;
  _6 = _5 * 20;
  _7 = _4 + _6;
  Bctu_Ip_ConfigTrigger (u32Instance, _7);
  Index.0_8 = Index;
  Index = Index.0_8 + 1;

  <bb 6> :
  _9 = pConfig->NumTrigConfigs;
  if (Index < _9)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _10 = pConfig->ListItemConfigs;
  if (_10 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _11 = pConfig->ListItemConfigs;
  _12 = pConfig->NumListItems;
  Bctu_ConfigMultiAdcSubLists (u32Instance, _11, _12);

  <bb 9> :
  _13 = pConfig->FifoConfigs;
  if (_13 != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _14 = pConfig->FifoConfigs;
  _15 = pConfig->NumFifoConfigs;
  Bctu_ConfigAndUpdateFifoNotification (u32Instance, _14, _15);

  <bb 11> :
  _16 = pConfig->TriggerNotification;
  Bctu_Ip_axBctuState[u32Instance].TriggerNotification = _16;
  Index = 0;
  goto <bb 13>; [INV]

  <bb 12> :
  _17 = (int) Index;
  _18 = (int) Index;
  _19 = pConfig->AdcNotifications[_17].NewConvDataNotification;
  Bctu_Ip_axBctuState[u32Instance].AdcNotifications[_18].NewConvDataNotification = _19;
  _20 = (int) Index;
  _21 = (int) Index;
  _22 = pConfig->AdcNotifications[_20].ConvDataOverrunNotification;
  Bctu_Ip_axBctuState[u32Instance].AdcNotifications[_21].ConvDataOverrunNotification = _22;
  _23 = (int) Index;
  _24 = (int) Index;
  _25 = pConfig->AdcNotifications[_23].ListLastConversionNotification;
  Bctu_Ip_axBctuState[u32Instance].AdcNotifications[_24].ListLastConversionNotification = _25;
  Index.1_26 = Index;
  Index = Index.1_26 + 1;

  <bb 13> :
  if (Index <= 2)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  Bctu_Ip_axBctuState[u32Instance].InitStatus = 1;
  return;

}


