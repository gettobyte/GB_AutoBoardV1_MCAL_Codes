Adc_Sar_Ip_GetDataAddress (uint32 u32Instance, uint32 u32ChannelIndex)
{
  uint32 D.7159;

  <bb 2> :
  _1 = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _2 = &_1->PCDR[0];
  _3 = u32ChannelIndex * 4;
  _4 = _2 + _3;
  D.7159 = (uint32) _4;

  <bb 3> :
<L0>:
  return D.7159;

}


Adc_Sar_Ip_SetExternalTrigger (const uint32 u32Instance, const Adc_Sar_Ip_ExtTriggerEdgeType eTriggerEdge, const Adc_Sar_Ip_ExtTriggerSourceType eTrggerSrc)
{
  <bb 2> :
  switch (eTrggerSrc) <default: <L4> [INV], case 0: <L0> [INV], case 1: <L1> [INV], case 2: <L2> [INV], case 3: <L3> [INV]>

  <bb 3> :
<L0>:
  Adc_Sar_ConfigExternalTrigger (u32Instance, eTriggerEdge, 67108864, 0, 134217728);
  goto <bb 8>; [INV]

  <bb 4> :
<L1>:
  Adc_Sar_ConfigExternalTrigger (u32Instance, eTriggerEdge, 67108864, 0, 33554432);
  goto <bb 8>; [INV]

  <bb 5> :
<L2>:
  Adc_Sar_ConfigExternalTrigger (u32Instance, eTriggerEdge, 67108864, 67108864, 167772160);
  goto <bb 8>; [INV]

  <bb 6> :
<L3>:
  Adc_Sar_ConfigExternalTrigger (u32Instance, eTriggerEdge, 2097152, 2097152, 4194304);
  goto <bb 8>; [INV]

  <bb 7> :
<L4>:

  <bb 8> :
  return;

}


Adc_Sar_Ip_SetCtuMode (const uint32 u32Instance, const Adc_Sar_Ip_CtuModeType eCtuMode)
{
  struct ADC_Type * const AdcBasePtr;
  Adc_Sar_Ip_StatusType Status;
  Adc_Sar_Ip_StatusType D.7157;

  <bb 2> :
  Status = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20 ();
  _1 = AdcBasePtr->MCR;
  _2 = _1 & 4294836223;
  AdcBasePtr->MCR = _2;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20 ();
  Status = Adc_Sar_Ip_Powerdown (u32Instance);
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  _3 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _4 = _3 & 4;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20 ();
  switch (eCtuMode) <default: <L5> [INV], case 0: <L4> [INV], case 1: <L2> [INV], case 2: <L3> [INV]>

  <bb 5> :
<L2>:
  _5 = AdcBasePtr->MCR;
  _6 = _5 & 4294901759;
  AdcBasePtr->MCR = _6;
  _7 = AdcBasePtr->MCR;
  _8 = _7 | 131072;
  AdcBasePtr->MCR = _8;
  goto <bb 9>; [INV]

  <bb 6> :
<L3>:
  _9 = AdcBasePtr->MCR;
  _10 = _9 | 196608;
  AdcBasePtr->MCR = _10;
  goto <bb 9>; [INV]

  <bb 7> :
<L4>:
  _11 = AdcBasePtr->MCR;
  _12 = _11 & 4294770687;
  AdcBasePtr->MCR = _12;
  goto <bb 9>; [INV]

  <bb 8> :
<L5>:

  <bb 9> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20 ();

  <bb 10> :
  Status = Adc_Sar_Ip_Powerup (u32Instance);

  <bb 11> :
  D.7157 = Status;

  <bb 12> :
<L9>:
  return D.7157;

}


Adc_Sar_Ip_SetConversionMode (const uint32 u32Instance, const Adc_Sar_Ip_ConvModeType eConvMode)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19 ();
  switch (eConvMode) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  _1 = AdcBasePtr->MCR;
  _2 = _1 & 3758096383;
  AdcBasePtr->MCR = _2;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  _3 = AdcBasePtr->MCR;
  _4 = _3 | 536870912;
  AdcBasePtr->MCR = _4;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19 ();
  return;

}


Adc_Sar_Ip_SetDmaClearSource (const uint32 u32Instance, const Adc_Sar_Ip_ClearSourceType pDmaClear)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45 ();
  _1 = AdcBasePtr->DMAE;
  _2 = _1 & 4294967293;
  AdcBasePtr->DMAE = _2;
  _3 = AdcBasePtr->DMAE;
  _4 = pDmaClear << 1;
  _5 = _4 & 2;
  _6 = _3 | _5;
  AdcBasePtr->DMAE = _6;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45 ();
  return;

}


Adc_Sar_Ip_DisableChannelDmaAll (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;
  uint8 Index;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48 ();
  _1 = &AdcBasePtr->DMAR0;
  _2 = (unsigned int) Index;
  _3 = _2 * 4;
  _4 = _1 + _3;
  _5 = MEM[(volatile uint32 *)_4];
  _6 = (int) Index;
  _7 = Adc_Sar_Ip_au32AdcChanBitmap[u32Instance][_6];
  _8 = ~_7;
  _9 = &AdcBasePtr->DMAR0;
  _10 = (unsigned int) Index;
  _11 = _10 * 4;
  _12 = _9 + _11;
  _13 = _5 & _8;
  MEM[(volatile uint32 *)_12] = _13;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48 ();
  Index.17_14 = Index;
  Index = Index.17_14 + 1;

  <bb 4> :
  _15 = Adc_Sar_Ip_au8AdcGroupCount[u32Instance];
  if (Index < _15)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Adc_Sar_Ip_DisableChannelDma (const uint32 u32Instance, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47 ();
  _1 = &AdcBasePtr->DMAR0;
  _2 = VectAdr * 4;
  _3 = _1 + _2;
  _4 = MEM[(volatile uint32 *)_3];
  _5 = 1 << VectBit;
  _6 = ~_5;
  _7 = &AdcBasePtr->DMAR0;
  _8 = VectAdr * 4;
  _9 = _7 + _8;
  _10 = _4 & _6;
  MEM[(volatile uint32 *)_9] = _10;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47 ();
  return;

}


Adc_Sar_Ip_EnableChannelDma (const uint32 u32Instance, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46 ();
  _1 = &AdcBasePtr->DMAR0;
  _2 = VectAdr * 4;
  _3 = _1 + _2;
  _4 = MEM[(volatile uint32 *)_3];
  _5 = 1 << VectBit;
  _6 = &AdcBasePtr->DMAR0;
  _7 = VectAdr * 4;
  _8 = _6 + _7;
  _9 = _4 | _5;
  MEM[(volatile uint32 *)_8] = _9;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46 ();
  return;

}


Adc_Sar_Ip_DisableDma (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44 ();
  _1 = AdcBasePtr->DMAE;
  _2 = _1 & 4294967294;
  AdcBasePtr->DMAE = _2;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44 ();
  return;

}


Adc_Sar_Ip_EnableDma (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43 ();
  _1 = AdcBasePtr->DMAE;
  _2 = _1 | 1;
  AdcBasePtr->DMAE = _2;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43 ();
  return;

}


Adc_Sar_Ip_DisablePresampleConversion (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  _1 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _2 = _1 & 2;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40 ();
  _3 = AdcBasePtr->PSCR;
  _4 = _3 & 4294967294;
  AdcBasePtr->PSCR = _4;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40 ();

  <bb 4> :
  return;

}


Adc_Sar_Ip_EnablePresampleConversion (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  _1 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _2 = _1 & 2;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39 ();
  _3 = AdcBasePtr->PSCR;
  _4 = _3 | 1;
  AdcBasePtr->PSCR = _4;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39 ();

  <bb 4> :
  return;

}


Adc_Sar_Ip_DisableChannelPresampling (const uint32 u32Instance, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  _1 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _2 = _1 & 2;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42 ();
  _3 = &AdcBasePtr->PSR0;
  _4 = VectAdr * 4;
  _5 = _3 + _4;
  _6 = MEM[(volatile uint32 *)_5];
  _7 = 1 << VectBit;
  _8 = ~_7;
  _9 = &AdcBasePtr->PSR0;
  _10 = VectAdr * 4;
  _11 = _9 + _10;
  _12 = _6 & _8;
  MEM[(volatile uint32 *)_11] = _12;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42 ();

  <bb 4> :
  return;

}


Adc_Sar_Ip_EnableChannelPresampling (const uint32 u32Instance, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  _1 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _2 = _1 & 2;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41 ();
  _3 = &AdcBasePtr->PSR0;
  _4 = VectAdr * 4;
  _5 = _3 + _4;
  _6 = MEM[(volatile uint32 *)_5];
  _7 = 1 << VectBit;
  _8 = &AdcBasePtr->PSR0;
  _9 = VectAdr * 4;
  _10 = _8 + _9;
  _11 = _6 | _7;
  MEM[(volatile uint32 *)_10] = _11;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41 ();

  <bb 4> :
  return;

}


Adc_Sar_Ip_SetPresamplingSource (const uint32 u32Instance, const Adc_Sar_Ip_ChanGroupType pChanGroup, const Adc_Sar_Ip_PresamplingSourceType pPresampleSource)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 Pscr;

  <bb 2> :
  _1 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _2 = _1 & 2;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38 ();
  Pscr = AdcBasePtr->PSCR;
  switch (pChanGroup) <default: <L4> [INV], case 0: <L1> [INV], case 1: <L2> [INV], case 2: <L3> [INV]>

  <bb 4> :
<L1>:
  Pscr = Pscr & 4294967293;
  _3 = pPresampleSource << 1;
  _4 = _3 & 2;
  Pscr = Pscr | _4;
  goto <bb 8>; [INV]

  <bb 5> :
<L2>:
  Pscr = Pscr & 4294967287;
  _5 = pPresampleSource << 3;
  _6 = _5 & 8;
  Pscr = Pscr | _6;
  goto <bb 8>; [INV]

  <bb 6> :
<L3>:
  Pscr = Pscr & 4294967263;
  _7 = pPresampleSource << 5;
  _8 = _7 & 32;
  Pscr = Pscr | _8;
  goto <bb 8>; [INV]

  <bb 7> :
<L4>:

  <bb 8> :
  AdcBasePtr->PSCR = Pscr;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38 ();

  <bb 9> :
  return;

}


Adc_Sar_Ip_AbortChain (const uint32 u32Instance, const boolean bBlocking, const boolean bAllowRestart)
{
  struct ADC_Type * const AdcBasePtr;
  Adc_Sar_Ip_StatusType ReturnStatus;
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  uint32 MsrStatus;
  Adc_Sar_Ip_StatusType D.7140;
  long unsigned int D.7136;

  <bb 2> :
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  ElapsedTicks = 0;
  ReturnStatus = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18 ();
  _2 = ~bAllowRestart;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = AdcBasePtr->MCR;
  _4 = _3 & 4278190079;
  AdcBasePtr->MCR = _4;

  <bb 4> :
  _5 = AdcBasePtr->MCR;
  _6 = _5 | 128;
  AdcBasePtr->MCR = _6;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18 ();
  if (bBlocking != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  _7 = AdcBasePtr->MSR;
  MsrStatus = _7 & 16777216;
  goto <bb 7>; [INV]

  <bb 6> :
  _8 = AdcBasePtr->MSR;
  MsrStatus = _8 & 16777216;
  D.7136 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7136 + ElapsedTicks;

  <bb 7> :
  if (MsrStatus == 16777216)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  ReturnStatus = 2;

  <bb 11> :
  D.7140 = ReturnStatus;
  CurrentTicks = {CLOBBER};

  <bb 12> :
<L11>:
  return D.7140;

}


Adc_Sar_Ip_AbortConversion (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17 ();
  _1 = AdcBasePtr->MCR;
  _2 = _1 | 64;
  AdcBasePtr->MCR = _2;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17 ();
  return;

}


Adc_Sar_Ip_SetAveraging (const uint32 u32Instance, const boolean bAvgEn, const Adc_Sar_Ip_AvgSelectType eAvgSel)
{
  struct ADC_Type * const AdcBasePtr;
  long unsigned int iftmp.16;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16 ();
  _1 = AdcBasePtr->MCR;
  _2 = _1 & 4294963711;
  AdcBasePtr->MCR = _2;
  _3 = AdcBasePtr->MCR;
  if (bAvgEn != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.16 = 2048;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.16 = 0;

  <bb 5> :
  _4 = eAvgSel << 9;
  _5 = _4 & 1536;
  _6 = iftmp.16 | _5;
  _7 = _3 | _6;
  AdcBasePtr->MCR = _7;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16 ();
  return;

}


Adc_Sar_Ip_SetSampleTimes (const uint32 u32Instance, const uint8 * const aSampleTimes)
{
  uint8 Index;
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (sizetype) Index;
  _2 = aSampleTimes + _1;
  _3 = *_2;
  _4 = &AdcBasePtr->CTR0;
  _5 = (unsigned int) Index;
  _6 = _5 * 4;
  _7 = _4 + _6;
  _8 = (long unsigned int) _3;
  MEM[(volatile uint32 *)_7] = _8;
  Index.15_9 = Index;
  Index = Index.15_9 + 1;

  <bb 4> :
  _10 = Adc_Sar_Ip_au8AdcGroupCount[u32Instance];
  if (Index < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Adc_Sar_Ip_SetClockMode (const uint32 u32Instance, const struct Adc_Sar_Ip_ClockConfigType * const pConfig)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 Mcr;
  Adc_Sar_Ip_StatusType Status;
  Adc_Sar_Ip_StatusType D.7126;
  long unsigned int D.7121;

  <bb 2> :
  Status = 0;
  Mcr = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _1 = pConfig->ClkSelect;
  D.7121 = Adc_Sar_GetADCLKSELValue (_1);
  Mcr = D.7121 | Mcr;
  Status = Adc_Sar_Ip_Powerdown (u32Instance);
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15 ();
  _2 = AdcBasePtr->MCR;
  _3 = _2 & 4294967289;
  _4 = Mcr | _3;
  AdcBasePtr->MCR = _4;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15 ();
  Status = Adc_Sar_Ip_Powerup (u32Instance);
  if (Status == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51 ();
  _5 = pConfig->HighSpeedConvEn;
  Adc_Sar_EnableHighSpeed (AdcBasePtr, _5);
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51 ();
  _6 = pConfig->AvgEn;
  _7 = pConfig->AvgSel;
  Adc_Sar_Ip_SetAveraging (u32Instance, _6, _7);
  _8 = pConfig->PowerDownDelay;
  _9 = (long unsigned int) _8;
  AdcBasePtr->PDEDR = _9;
  _10 = &pConfig->SampleTimeArr;
  Adc_Sar_Ip_SetSampleTimes (u32Instance, _10);

  <bb 5> :
  D.7126 = Status;

  <bb 6> :
<L4>:
  return D.7126;

}


Adc_Sar_Ip_DisableNotifications (const uint32 u32Instance, const uint32 u32NotificationMask)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 ImrFlags;

  <bb 2> :
  ImrFlags = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _1 = u32NotificationMask & 1;
  ImrFlags = ImrFlags | _1;
  _2 = u32NotificationMask & 4;
  ImrFlags = ImrFlags | _2;
  _3 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _4 = _3 & 4;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = u32NotificationMask & 16;
  ImrFlags = ImrFlags | _5;

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34 ();
  _6 = AdcBasePtr->IMR;
  _7 = ~ImrFlags;
  _8 = _6 & _7;
  AdcBasePtr->IMR = _8;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34 ();
  return;

}


Adc_Sar_Ip_EnableNotifications (const uint32 u32Instance, const uint32 u32NotificationMask)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 ImrFlags;

  <bb 2> :
  ImrFlags = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _1 = u32NotificationMask & 1;
  ImrFlags = ImrFlags | _1;
  _2 = u32NotificationMask & 4;
  ImrFlags = ImrFlags | _2;
  _3 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _4 = _3 & 4;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = u32NotificationMask & 16;
  ImrFlags = ImrFlags | _5;

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33 ();
  _6 = AdcBasePtr->IMR;
  _7 = ImrFlags | _6;
  AdcBasePtr->IMR = _7;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33 ();
  return;

}


Adc_Sar_Ip_Powerdown (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  uint32 MsrStatus;
  uint32 ExpectedStatus;
  Adc_Sar_Ip_StatusType ReturnStatus;
  Adc_Sar_Ip_StatusType D.7114;
  long unsigned int D.7110;

  <bb 2> :
  ReturnStatus = 0;
  ExpectedStatus = 1;
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  ElapsedTicks = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _2 = AdcBasePtr->MSR;
  MsrStatus = _2 & 7;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14 ();
  Adc_Sar_Powerdown (AdcBasePtr);
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14 ();
  goto <bb 4>; [INV]

  <bb 3> :
  _3 = AdcBasePtr->MSR;
  MsrStatus = _3 & 7;
  D.7110 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7110 + ElapsedTicks;

  <bb 4> :
  if (MsrStatus != ExpectedStatus)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  ReturnStatus = 2;

  <bb 8> :
  D.7114 = ReturnStatus;
  CurrentTicks = {CLOBBER};

  <bb 9> :
<L7>:
  return D.7114;

}


Adc_Sar_Ip_Powerup (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  uint32 MsrStatus;
  uint32 ExpectedStatus;
  Adc_Sar_Ip_StatusType ReturnStatus;
  Adc_Sar_Ip_StatusType D.7107;
  long unsigned int D.7103;

  <bb 2> :
  ReturnStatus = 0;
  ExpectedStatus = 0;
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  ElapsedTicks = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _2 = AdcBasePtr->MSR;
  MsrStatus = _2 & 7;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13 ();
  Adc_Sar_Powerup (AdcBasePtr);
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13 ();
  goto <bb 4>; [INV]

  <bb 3> :
  _3 = AdcBasePtr->MSR;
  MsrStatus = _3 & 7;
  D.7103 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7103 + ElapsedTicks;

  <bb 4> :
  if (MsrStatus != ExpectedStatus)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  ReturnStatus = 2;

  <bb 8> :
  D.7107 = ReturnStatus;
  CurrentTicks = {CLOBBER};

  <bb 9> :
<L7>:
  return D.7107;

}


Adc_Sar_Ip_DoCalibration (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 Calbistreg;
  uint32 Mcr;
  uint32 AdcClkSel;
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  Adc_Sar_Ip_StatusType CalStatus;
  Adc_Sar_Ip_StatusType Status;
  Adc_Sar_Ip_StatusType D.7100;
  long unsigned int D.7088;
  long unsigned int D.7085;

  <bb 2> :
  Status = 0;
  CalStatus = 0;
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  ElapsedTicks = 0;
  AdcClkSel = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  Status = Adc_Sar_Ip_Powerdown (u32Instance);
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 3> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12 ();
  Mcr = AdcBasePtr->MCR;
  AdcClkSel = Mcr & 6;
  Mcr = Mcr & 4294967289;
  _2 = Adc_Sar_Ip_axAdcSarState[u32Instance].CalibrationClkSelect;
  D.7085 = Adc_Sar_GetADCLKSELValue (_2);
  Mcr = D.7085 | Mcr;
  AdcBasePtr->MCR = Mcr;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12 ();
  Status = Adc_Sar_Ip_Powerup (u32Instance);
  if (Status == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 4> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36 ();
  Calbistreg = AdcBasePtr->CALBISTREG;
  Calbistreg = Calbistreg & 3892313998;
  Calbistreg = Calbistreg | 112;
  AdcBasePtr->CALBISTREG = Calbistreg;
  _3 = AdcBasePtr->CALBISTREG;
  _4 = _3 | 8;
  AdcBasePtr->CALBISTREG = _4;
  _5 = AdcBasePtr->CALBISTREG;
  _6 = _5 | 1;
  AdcBasePtr->CALBISTREG = _6;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36 ();
  ElapsedTicks = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  D.7088 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7088 + ElapsedTicks;

  <bb 6> :
  _7 = AdcBasePtr->CALBISTREG;
  _8 = _7 & 32768;
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  CalStatus = 2;
  goto <bb 12>; [INV]

  <bb 10> :
  _9 = AdcBasePtr->CALBISTREG;
  _10 = _9 & 8;
  if (_10 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  CalStatus = 1;

  <bb 12> :
  Status = Adc_Sar_Ip_Powerdown (u32Instance);

  <bb 13> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12 ();
  Mcr = AdcBasePtr->MCR;
  Mcr = Mcr & 4294967289;
  Mcr = Mcr | AdcClkSel;
  AdcBasePtr->MCR = Mcr;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12 ();
  if (Status == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  Status = Adc_Sar_Ip_Powerup (u32Instance);
  if (CalStatus != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  Status = CalStatus;

  <bb 16> :
  D.7100 = Status;
  CurrentTicks = {CLOBBER};

  <bb 17> :
<L19>:
  return D.7100;

}


Adc_Sar_Ip_GetConvResult (const uint32 u32Instance, const uint32 u32ChnIdx, const Adc_Sar_Ip_ConvChainType pChainType, struct Adc_Sar_Ip_ChanResultType * const pResult)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 Cdr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  pResult->ConvData = 0;
  _1 = (unsigned char) u32ChnIdx;
  pResult->AdcChnIdx = _1;
  pResult->ValidFlag = 0;
  pResult->OverWrittenFlag = 0;
  _2 = &AdcBasePtr->PCDR[0];
  _3 = u32ChnIdx * 4;
  _4 = _2 + _3;
  Cdr = MEM[(const uint32 *)_4];
  _5 = pChainType << 16;
  _6 = Cdr ^ _5;
  _7 = _6 & 196608;
  if (_7 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _8 = Cdr >> 19;
  _9 = (int) _8;
  _10 = _9 & 1;
  _11 = _10 != 0;
  pResult->ValidFlag = _11;
  _12 = Cdr & 262144;
  _13 = _12 != 0;
  pResult->OverWrittenFlag = _13;
  _14 = Adc_Sar_GetMaskedResult (u32Instance, Cdr);
  pResult->ConvData = _14;

  <bb 4> :
  _15 = &AdcBasePtr->CEOCFR0;
  _16 = VectAdr * 4;
  _17 = _15 + _16;
  _18 = 1 << VectBit;
  MEM[(volatile uint32 *)_17] = _18;
  return;

}


Adc_Sar_Ip_GetConvData (const uint32 u32Instance, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 Cdr;
  uint32 VectBit;
  uint32 VectAdr;
  uint16 Result;
  uint16 D.7079;

  <bb 2> :
  Result = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  _1 = &AdcBasePtr->PCDR[0];
  _2 = u32ChnIdx * 4;
  _3 = _1 + _2;
  Cdr = MEM[(const uint32 *)_3];
  _4 = Cdr & 524288;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Result = Adc_Sar_GetMaskedResult (u32Instance, Cdr);
  _5 = &AdcBasePtr->CEOCFR0;
  _6 = VectAdr * 4;
  _7 = _5 + _6;
  _8 = 1 << VectBit;
  MEM[(volatile uint32 *)_7] = _8;

  <bb 4> :
  D.7079 = Result;

  <bb 5> :
<L2>:
  return D.7079;

}


Adc_Sar_Ip_GetConvResultsToArray (const uint32 u32Instance, const Adc_Sar_Ip_ConvChainType pChainType, const uint32 u32Length, struct Adc_Sar_Ip_ChanResultType * const pResults)
{
  uint32 D.7075;

  <bb 2> :
  D.7075 = Adc_Sar_GetConvResults (u32Instance, pChainType, 0B, pResults, u32Length);

  <bb 3> :
<L0>:
  return D.7075;

}


Adc_Sar_Ip_GetConvDataToArray (const uint32 u32Instance, const Adc_Sar_Ip_ConvChainType pChainType, const uint32 u32Length, uint16 * const pResults)
{
  uint32 D.7073;

  <bb 2> :
  D.7073 = Adc_Sar_GetConvResults (u32Instance, pChainType, pResults, 0B, u32Length);

  <bb 3> :
<L0>:
  return D.7073;

}


Adc_Sar_Ip_SelfTest (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  uint32 MsrStatus;
  uint32 Reg;
  Adc_Sar_Ip_StatusType Status;
  Adc_Sar_Ip_StatusType D.7051;
  long unsigned int D.7047;

  <bb 2> :
  Status = 0;
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  ElapsedTicks = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25 ();
  _2 = &AdcBasePtr->NCMR0;
  _3 = MEM[(volatile uint32 *)_2];
  _4 = &AdcBasePtr->NCMR0;
  _5 = _3 | 1;
  MEM[(volatile uint32 *)_4] = _5;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25 ();
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11 ();
  _6 = AdcBasePtr->MCR;
  _7 = _6 & 4294836223;
  AdcBasePtr->MCR = _7;
  _8 = AdcBasePtr->MCR;
  _9 = _8 | 536870912;
  AdcBasePtr->MCR = _9;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11 ();
  Reg = 0;
  Reg = Reg | 268439552;
  AdcBasePtr->STCR1 = Reg;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35 ();
  _10 = AdcBasePtr->STCR3;
  _11 = _10 | 768;
  AdcBasePtr->STCR3 = _11;
  _12 = AdcBasePtr->STCR2;
  _13 = _12 | 128;
  AdcBasePtr->STCR2 = _13;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35 ();
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11 ();
  _14 = AdcBasePtr->MCR;
  _15 = _14 | 16777216;
  AdcBasePtr->MCR = _15;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11 ();
  Status = Adc_Sar_CheckSelfTestProgress (u32Instance);
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11 ();
  _16 = AdcBasePtr->MCR;
  _17 = _16 & 4278190079;
  AdcBasePtr->MCR = _17;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11 ();
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _18 = AdcBasePtr->MSR;
  MsrStatus = _18 & 7;
  ElapsedTicks = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  _19 = AdcBasePtr->MSR;
  MsrStatus = _19 & 7;
  D.7047 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7047 + ElapsedTicks;

  <bb 5> :
  if (MsrStatus != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35 ();
  _20 = AdcBasePtr->STCR2;
  _21 = _20 & 4294967167;
  AdcBasePtr->STCR2 = _21;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35 ();
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Status = 2;

  <bb 9> :
  D.7051 = Status;
  CurrentTicks = {CLOBBER};

  <bb 10> :
<L9>:
  return D.7051;

}


Adc_Sar_Ip_ClearStatusFlags (const uint32 u32Instance, const uint32 u32Mask)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 IsrFlags;

  <bb 2> :
  IsrFlags = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  _1 = u32Mask & 2;
  IsrFlags = IsrFlags | _1;
  _2 = u32Mask & 1;
  IsrFlags = IsrFlags | _2;
  _3 = u32Mask & 8;
  IsrFlags = IsrFlags | _3;
  _4 = u32Mask & 4;
  IsrFlags = IsrFlags | _4;
  _5 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _6 = _5 & 4;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _7 = u32Mask & 16;
  IsrFlags = IsrFlags | _7;

  <bb 4> :
  AdcBasePtr->ISR = IsrFlags;
  return;

}


Adc_Sar_Ip_GetStatusFlags (const uint32 u32Instance)
{
  uint32 Flags;
  uint32 D.7033;
  long unsigned int D.7032;
  long unsigned int D.7031;

  <bb 2> :
  Flags = 0;
  D.7031 = Adc_Sar_GetMsrFlags (u32Instance);
  Flags = D.7031 | Flags;
  D.7032 = Adc_Sar_GetIsrFlags (u32Instance);
  Flags = D.7032 | Flags;
  D.7033 = Flags;

  <bb 3> :
<L0>:
  return D.7033;

}


Adc_Sar_Ip_StartConversion (const uint32 u32Instance, const Adc_Sar_Ip_ConvChainType pChainType)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10 ();
  switch (pChainType) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  _1 = AdcBasePtr->MCR;
  _2 = _1 | 16777216;
  AdcBasePtr->MCR = _2;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  _3 = AdcBasePtr->MCR;
  _4 = _3 | 1048576;
  AdcBasePtr->MCR = _4;
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10 ();
  return;

}


Adc_Sar_Ip_SetResolution (const uint32 u32Instance, const Adc_Sar_Ip_Resolution eResolution)
{
  uint32 Calbistreg;
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37 ();
  Calbistreg = AdcBasePtr->CALBISTREG;
  Calbistreg = Calbistreg & 536870911;
  _1 = eResolution << 29;
  Calbistreg = Calbistreg | _1;
  AdcBasePtr->CALBISTREG = Calbistreg;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37 ();
  return;

}


Adc_Sar_Ip_DisableChannel (const uint32 u32Instance, const Adc_Sar_Ip_ConvChainType pChainType, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  switch (pChainType) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24 ();
  _1 = &AdcBasePtr->NCMR0;
  _2 = VectAdr * 4;
  _3 = _1 + _2;
  _4 = MEM[(volatile uint32 *)_3];
  _5 = 1 << VectBit;
  _6 = ~_5;
  _7 = &AdcBasePtr->NCMR0;
  _8 = VectAdr * 4;
  _9 = _7 + _8;
  _10 = _4 & _6;
  MEM[(volatile uint32 *)_9] = _10;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24 ();
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27 ();
  _11 = &AdcBasePtr->JCMR0;
  _12 = VectAdr * 4;
  _13 = _11 + _12;
  _14 = MEM[(volatile uint32 *)_13];
  _15 = 1 << VectBit;
  _16 = ~_15;
  _17 = &AdcBasePtr->JCMR0;
  _18 = VectAdr * 4;
  _19 = _17 + _18;
  _20 = _14 & _16;
  MEM[(volatile uint32 *)_19] = _20;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27 ();
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  return;

}


Adc_Sar_Ip_EnableChannel (const uint32 u32Instance, const Adc_Sar_Ip_ConvChainType pChainType, const uint32 u32ChnIdx)
{
  struct ADC_Type * const AdcBasePtr;
  uint32 VectBit;
  uint32 VectAdr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  VectAdr = u32ChnIdx / 32;
  VectBit = u32ChnIdx & 31;
  switch (pChainType) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23 ();
  _1 = &AdcBasePtr->NCMR0;
  _2 = VectAdr * 4;
  _3 = _1 + _2;
  _4 = MEM[(volatile uint32 *)_3];
  _5 = 1 << VectBit;
  _6 = &AdcBasePtr->NCMR0;
  _7 = VectAdr * 4;
  _8 = _6 + _7;
  _9 = _4 | _5;
  MEM[(volatile uint32 *)_8] = _9;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23 ();
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26 ();
  _10 = &AdcBasePtr->JCMR0;
  _11 = VectAdr * 4;
  _12 = _10 + _11;
  _13 = MEM[(volatile uint32 *)_12];
  _14 = 1 << VectBit;
  _15 = &AdcBasePtr->JCMR0;
  _16 = VectAdr * 4;
  _17 = _15 + _16;
  _18 = _13 | _14;
  MEM[(volatile uint32 *)_17] = _18;
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26 ();
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  return;

}


Adc_Sar_Ip_ChainConfig (const uint32 u32Instance, const struct Adc_Sar_Ip_ChansIdxMaskType * const pChansIdxMask, const Adc_Sar_Ip_ConvChainType pChainType)
{
  <bb 2> :
  switch (pChainType) <default: <L2> [INV], case 0: <L0> [INV], case 1: <L1> [INV]>

  <bb 3> :
<L0>:
  _1 = &pChansIdxMask->ChanMaskArr;
  Adc_Sar_SetNormalChain (u32Instance, _1);
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  _2 = &pChansIdxMask->ChanMaskArr;
  Adc_Sar_SetInjectedChain (u32Instance, _2);
  goto <bb 6>; [INV]

  <bb 5> :
<L2>:

  <bb 6> :
  return;

}


Adc_Sar_Ip_Deinit (const uint32 u32Instance)
{
  struct ADC_Type * const AdcBasePtr;
  Adc_Sar_Ip_StatusType Status;
  struct Adc_Sar_Ip_ConfigType DefaultConfig;
  uint32 Index;
  Adc_Sar_Ip_StatusType D.7028;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  DefaultConfig.ConvMode = 0;
  DefaultConfig.ClkSelect = 0;
  DefaultConfig.CalibrationClkSelect = 1;
  DefaultConfig.HighSpeedConvEn = 0;
  DefaultConfig.CtuMode = 0;
  DefaultConfig.InjectedEdge = 0;
  DefaultConfig.ExtTrigger = 0;
  DefaultConfig.NormalExtTrgEn = 0;
  DefaultConfig.NormalAuxExtTrgEn = 0;
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  DefaultConfig.SampleTimeArr[Index] = 22;
  DefaultConfig.PresamplingSourceArr[Index] = 0;
  Index = Index + 1;

  <bb 4> :
  _1 = Adc_Sar_Ip_au8AdcGroupCount[u32Instance];
  _2 = (long unsigned int) _1;
  if (Index < _2)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  DefaultConfig.BypassSampling = 0;
  DefaultConfig.AutoClockOff = 0;
  DefaultConfig.OverwriteEnable = 0;
  DefaultConfig.DataAlign = 0;
  DefaultConfig.DecodeDelay = 0;
  DefaultConfig.PowerDownDelay = 0;
  DefaultConfig.AvgEn = 0;
  DefaultConfig.AvgSel = 0;
  DefaultConfig.UsrOffset = 0;
  DefaultConfig.UsrGain = 0;
  DefaultConfig.DmaEnable = 0;
  DefaultConfig.DmaClearSource = 0;
  DefaultConfig.NumChannels = 0;
  DefaultConfig.ChannelConfigsPtr = 0B;
  DefaultConfig.EndOfNormalChainNotification = 0B;
  DefaultConfig.EndOfInjectedChainNotification = 0B;
  DefaultConfig.EndOfCtuConversionNotification = 0B;
  Status = Adc_Sar_Ip_Init (u32Instance, &DefaultConfig);
  if (Status == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  Index = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _3 = &AdcBasePtr->CIMR0;
  _4 = Index * 4;
  _5 = _3 + _4;
  MEM[(volatile uint32 *)_5] = 0;
  _6 = &AdcBasePtr->CEOCFR0;
  _7 = Index * 4;
  _8 = _6 + _7;
  MEM[(volatile uint32 *)_8] = 4294967295;
  _9 = &AdcBasePtr->DMAR0;
  _10 = Index * 4;
  _11 = _9 + _10;
  MEM[(volatile uint32 *)_11] = 0;
  _12 = &AdcBasePtr->PSR0;
  _13 = Index * 4;
  _14 = _12 + _13;
  MEM[(volatile uint32 *)_14] = 0;
  Index = Index + 1;

  <bb 8> :
  _15 = Adc_Sar_Ip_au8AdcGroupCount[u32Instance];
  _16 = (long unsigned int) _15;
  if (Index < _16)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  Adc_Sar_ResetWdog (u32Instance);
  AdcBasePtr->WTIMR = 0;
  Adc_Sar_Ip_ClearStatusFlags (u32Instance, 31);
  Adc_Sar_Ip_SetResolution (u32Instance, 1);
  Adc_Sar_Ip_axAdcSarState[u32Instance].InitStatus = 0;
  Status = Adc_Sar_Ip_Powerdown (u32Instance);

  <bb 10> :
  D.7028 = Status;
  DefaultConfig = {CLOBBER};

  <bb 11> :
<L9>:
  return D.7028;

}


Adc_Sar_Ip_Init (const uint32 u32Instance, const struct Adc_Sar_Ip_ConfigType * const pConfig)
{
  struct ADC_Type * const AdcBasePtr;
  Adc_Sar_Ip_StatusType Status;
  Adc_Sar_Ip_StatusType D.6994;
  long unsigned int iftmp.4;

  <bb 2> :
  Status = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[u32Instance];
  Adc_Sar_Ip_AbortChain (u32Instance, 1, 0);
  _1 = AdcBasePtr->MCR;
  _2 = _1 & 4294836223;
  AdcBasePtr->MCR = _2;
  Status = Adc_Sar_Ip_Powerdown (u32Instance);
  if (Status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 3> :
  _3 = AdcBasePtr->MCR;
  _4 = Adc_Sar_CollectMcrMasks (u32Instance, pConfig, _3);
  AdcBasePtr->MCR = _4;
  _5 = pConfig->DataAlign;
  Adc_Sar_Ip_axAdcSarState[u32Instance].DataAlign = _5;
  Status = Adc_Sar_Ip_Powerup (u32Instance);
  if (Status == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 4> :
  _6 = pConfig->CtuMode;
  if (_6 == 2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _7 = AdcBasePtr->MCR;
  _8 = _7 | 65536;
  AdcBasePtr->MCR = _8;

  <bb 6> :
  _9 = pConfig->HighSpeedConvEn;
  Adc_Sar_EnableHighSpeed (AdcBasePtr, _9);
  _10 = &pConfig->SampleTimeArr;
  Adc_Sar_Ip_SetSampleTimes (u32Instance, _10);
  _11 = pConfig->PowerDownDelay;
  _12 = (long unsigned int) _11;
  AdcBasePtr->PDEDR = _12;
  _13 = Adc_Sar_Ip_au32AdcFeatureBitmap[u32Instance];
  _14 = _13 & 1;
  if (_14 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _15 = pConfig->DecodeDelay;
  _16 = (long unsigned int) _15;
  AdcBasePtr->DSDR = _16;

  <bb 8> :
  _17 = &pConfig->ChanMaskNormal;
  Adc_Sar_SetNormalChain (u32Instance, _17);
  _18 = &pConfig->ChanMaskInjected;
  Adc_Sar_SetInjectedChain (u32Instance, _18);
  _19 = pConfig->AdcResolution;
  Adc_Sar_Ip_SetResolution (u32Instance, _19);
  _20 = AdcBasePtr->DMAE;
  _21 = _20 & 4294967292;
  AdcBasePtr->DMAE = _21;
  _22 = pConfig->DmaEnable;
  if (_22 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _23 = AdcBasePtr->DMAE;
  _24 = pConfig->DmaClearSource;
  _25 = _24 << 1;
  _26 = _25 & 2;
  _27 = _23 | _26;
  _28 = _27 | 1;
  AdcBasePtr->DMAE = _28;

  <bb 10> :
  _29 = pConfig->ChannelConfigsPtr;
  if (_29 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 11> :
  _30 = pConfig->NumChannels;
  if (_30 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _31 = pConfig->ChannelConfigsPtr;
  _32 = pConfig->NumChannels;
  Adc_Sar_ConfigChannels (u32Instance, _31, _32);

  <bb 13> :
  _33 = AdcBasePtr->PSCR;
  _34 = _33 & 4294967294;
  AdcBasePtr->PSCR = _34;
  _35 = AdcBasePtr->PSCR;
  _36 = pConfig->BypassSampling;
  if (_36 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  iftmp.4 = 1;
  goto <bb 16>; [INV]

  <bb 15> :
  iftmp.4 = 0;

  <bb 16> :
  _37 = iftmp.4 | _35;
  AdcBasePtr->PSCR = _37;
  _38 = pConfig->PresamplingSourceArr[0];
  Adc_Sar_Ip_SetPresamplingSource (u32Instance, 0, _38);
  _39 = pConfig->PresamplingSourceArr[1];
  Adc_Sar_Ip_SetPresamplingSource (u32Instance, 1, _39);
  _40 = pConfig->PresamplingSourceArr[2];
  Adc_Sar_Ip_SetPresamplingSource (u32Instance, 2, _40);
  _41 = pConfig->EndOfNormalChainNotification;
  Adc_Sar_Ip_axAdcSarState[u32Instance].EndOfNormalChainNotification = _41;
  _42 = pConfig->EndOfInjectedChainNotification;
  Adc_Sar_Ip_axAdcSarState[u32Instance].EndOfInjectedChainNotification = _42;
  _43 = pConfig->EndOfCtuConversionNotification;
  Adc_Sar_Ip_axAdcSarState[u32Instance].EndOfCtuConversionNotification = _43;
  _44 = pConfig->BypassResolution;
  Adc_Sar_Ip_axAdcSarState[u32Instance].BypassResolution = _44;
  _45 = pConfig->CalibrationClkSelect;
  Adc_Sar_Ip_axAdcSarState[u32Instance].CalibrationClkSelect = _45;
  _46 = pConfig->UsrOffset;
  _47 = (long unsigned int) _46;
  _48 = pConfig->UsrGain;
  _49 = (long unsigned int) _48;
  _50 = _49 << 16;
  _51 = _50 & 67043328;
  _52 = _47 | _51;
  AdcBasePtr->OFSGNUSR = _52;
  Adc_Sar_Ip_axAdcSarState[u32Instance].InitStatus = 1;

  <bb 17> :
  D.6994 = Status;

  <bb 18> :
<L17>:
  return D.6994;

}


Adc_Sar_GetValueFromBool (const boolean bVal, const uint32 TrueVal, const uint32 FalseVal)
{
  uint32 iftmp.6;
  uint32 D.7014;

  <bb 2> :
  if (bVal != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.6 = TrueVal;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.6 = FalseVal;

  <bb 5> :
  D.7014 = iftmp.6;

  <bb 6> :
<L3>:
  return D.7014;

}


Adc_Sar_SetInjectedChain (const uint32 Instance, const uint32 * const Mask)
{
  uint8 Index;
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (unsigned int) Index;
  _2 = _1 * 4;
  _3 = Mask + _2;
  _4 = &AdcBasePtr->JCMR0;
  _5 = (unsigned int) Index;
  _6 = _5 * 4;
  _7 = _4 + _6;
  _8 = *_3;
  MEM[(volatile uint32 *)_7] = _8;
  Index.9_9 = Index;
  Index = Index.9_9 + 1;

  <bb 4> :
  _10 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  if (Index < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Adc_Sar_SetNormalChain (const uint32 Instance, const uint32 * const Mask)
{
  uint8 Index;
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (unsigned int) Index;
  _2 = _1 * 4;
  _3 = Mask + _2;
  _4 = &AdcBasePtr->NCMR0;
  _5 = (unsigned int) Index;
  _6 = _5 * 4;
  _7 = _4 + _6;
  _8 = *_3;
  MEM[(volatile uint32 *)_7] = _8;
  Index.8_9 = Index;
  Index = Index.8_9 + 1;

  <bb 4> :
  _10 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  if (Index < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Adc_Sar_Ip_IRQHandler (const uint32 Instance)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  _1 = AdcBasePtr->ISR;
  _2 = _1 & 16;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  AdcBasePtr->ISR = 16;
  _3 = AdcBasePtr->IMR;
  _4 = _3 & 16;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _5 = Adc_Sar_Ip_axAdcSarState[Instance].EndOfCtuConversionNotification;
  Adc_Sar_CheckAndCallNotification (Instance, _5);

  <bb 5> :
  _6 = AdcBasePtr->ISR;
  _7 = _6 & 1;
  if (_7 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  AdcBasePtr->ISR = 1;
  _8 = AdcBasePtr->IMR;
  _9 = _8 & 1;
  if (_9 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _10 = Adc_Sar_Ip_axAdcSarState[Instance].EndOfNormalChainNotification;
  Adc_Sar_CheckAndCallNotification (Instance, _10);

  <bb 8> :
  _11 = AdcBasePtr->ISR;
  _12 = _11 & 4;
  if (_12 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  AdcBasePtr->ISR = 4;
  _13 = AdcBasePtr->IMR;
  _14 = _13 & 4;
  if (_14 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _15 = Adc_Sar_Ip_axAdcSarState[Instance].EndOfInjectedChainNotification;
  Adc_Sar_CheckAndCallNotification (Instance, _15);

  <bb 11> :
  _16 = AdcBasePtr->ISR;
  _17 = _16 & 2;
  if (_17 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  AdcBasePtr->ISR = 2;

  <bb 13> :
  _18 = AdcBasePtr->ISR;
  _19 = _18 & 8;
  if (_19 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  AdcBasePtr->ISR = 8;

  <bb 15> :
  Adc_CheckAndCallAllChannelNotification (Instance);
  AdcBasePtr->WTISR = 4294967295;
  return;

}


Adc_Sar_ConfigExternalTrigger (const uint32 Instance, const Adc_Sar_Ip_ExtTriggerEdgeType TriggerEdge, const uint32 TrgEdgeSetMask, const uint32 TrgEdgeClrMask, const uint32 TrigSrcMask)
{
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21 ();
  switch (TriggerEdge) <default: <L3> [INV], case 0: <L2> [INV], case 1: <L0> [INV], case 2: <L1> [INV]>

  <bb 3> :
<L0>:
  _1 = AdcBasePtr->MCR;
  _2 = ~TrgEdgeSetMask;
  _3 = _1 & _2;
  AdcBasePtr->MCR = _3;
  _4 = AdcBasePtr->MCR;
  _5 = TrigSrcMask | _4;
  AdcBasePtr->MCR = _5;
  goto <bb 7>; [INV]

  <bb 4> :
<L1>:
  _6 = AdcBasePtr->MCR;
  _7 = TrgEdgeSetMask | TrigSrcMask;
  _8 = _6 | _7;
  AdcBasePtr->MCR = _8;
  goto <bb 7>; [INV]

  <bb 5> :
<L2>:
  _9 = AdcBasePtr->MCR;
  _10 = TrgEdgeClrMask | TrigSrcMask;
  _11 = ~_10;
  _12 = _9 & _11;
  AdcBasePtr->MCR = _12;
  goto <bb 7>; [INV]

  <bb 6> :
<L3>:

  <bb 7> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21 ();
  return;

}


Adc_CheckAndCallAllChannelNotification (const uint32 Instance)
{
  uint32 TempValue;
  struct ADC_Type * const AdcBasePtr;
  uint16 VectAdr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  VectAdr = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = &AdcBasePtr->CEOCFR0;
  _2 = (unsigned int) VectAdr;
  _3 = _2 * 4;
  _4 = _1 + _3;
  TempValue = MEM[(volatile uint32 *)_4];
  if (TempValue != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _5 = &AdcBasePtr->CEOCFR0;
  _6 = (unsigned int) VectAdr;
  _7 = _6 * 4;
  _8 = _5 + _7;
  MEM[(volatile uint32 *)_8] = TempValue;

  <bb 5> :
  VectAdr.3_9 = VectAdr;
  VectAdr = VectAdr.3_9 + 1;

  <bb 6> :
  _10 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  _11 = (short unsigned int) _10;
  if (VectAdr < _11)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}


Adc_Sar_CheckAndCallNotification (const uint32 Instance, void (*<T532>) (void) Callback)
{
  <bb 2> :
  if (Callback != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _1 = Adc_Sar_Ip_axAdcSarState[Instance].InitStatus;
  if (_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Callback ();

  <bb 5> :
  return;

}


Adc_Sar_ResetWdog (const uint32 Instance)
{
  uint8 Index;
  struct ADC_Type * const AdcBasePtr;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = &AdcBasePtr->CWENR0;
  _2 = (unsigned int) Index;
  _3 = _2 * 4;
  _4 = _1 + _3;
  MEM[(volatile uint32 *)_4] = 0;
  _5 = &AdcBasePtr->AWORR0;
  _6 = (unsigned int) Index;
  _7 = _6 * 4;
  _8 = _5 + _7;
  MEM[(volatile uint32 *)_8] = 4294967295;
  Index.0_9 = Index;
  Index = Index.0_9 + 1;

  <bb 4> :
  _10 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  if (Index < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  Index = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  Adc_Sar_WriteThresholds (AdcBasePtr, Index, 65535, 0);
  Index.1_11 = Index;
  Index = Index.1_11 + 1;

  <bb 7> :
  if (Index <= 3)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  Index = 0;
  goto <bb 13>; [INV]

  <bb 9> :
  _12 = Index / 4;
  _13 = (unsigned int) _12;
  _14 = Adc_Sar_Ip_au32AdcChanBitmap[Instance][_13];
  _15 = (unsigned int) Index;
  _16 = _15 & 3;
  _17 = _16 * 8;
  _18 = 255 << _17;
  _19 = _14 & _18;
  if (_19 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by continue predictor.
  goto <bb 12>; [INV]

  <bb 11> :
  Adc_Sar_ResetWdogCWSELR (AdcBasePtr, Index);

  <bb 12> :
  Index.2_20 = Index;
  Index = Index.2_20 + 1;

  <bb 13> :
  if (Index <= 2)
    goto <bb 9>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  return;

}


Adc_Sar_GetConvResults (const uint32 Instance, const Adc_Sar_Ip_ConvChainType ChainType, uint16 * const ResultsRaw, struct Adc_Sar_Ip_ChanResultType * const ResultsStruct, const uint32 Length)
{
  const uint16 AdcChanCount[3][3];
  uint32 Cdr;
  uint8 ChnIdx;
  uint32 VectBit;
  uint32 VectAdr;
  struct ADC_Type * const AdcBasePtr;
  boolean LengthExceeded;
  uint32 Index;
  uint32 D.6939;

  <bb 2> :
  Index = 0;
  LengthExceeded = 0;
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  AdcChanCount = *.LC0;
  VectAdr = 0;
  goto <bb 18>; [INV]

  <bb 3> :
  VectBit = 0;
  goto <bb 14>; [INV]

  <bb 4> :
  _1 = (unsigned char) VectAdr;
  _2 = _1 * 32;
  _3 = (unsigned char) VectBit;
  ChnIdx = _2 + _3;
  _4 = ChnIdx / 32;
  _5 = (unsigned int) _4;
  _6 = Adc_Sar_Ip_au32AdcChanBitmap[Instance][_5];
  _7 = (unsigned int) ChnIdx;
  _8 = _7 & 31;
  _9 = _6 >> _8;
  _10 = _9 & 1;
  if (_10 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by continue predictor.
  goto <bb 13>; [INV]

  <bb 6> :
  _11 = &AdcBasePtr->PCDR[0];
  _12 = (unsigned int) ChnIdx;
  _13 = _12 * 4;
  _14 = _11 + _13;
  Cdr = MEM[(const uint32 *)_14];
  _15 = ChainType << 16;
  _16 = _15 & 196608;
  _17 = _16 | 524288;
  _18 = Cdr & 720896;
  if (_17 == _18)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 7> :
  if (ResultsRaw != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _19 = Index * 2;
  _20 = ResultsRaw + _19;
  _21 = Adc_Sar_GetMaskedResult (Instance, Cdr);
  *_20 = _21;

  <bb 9> :
  if (ResultsStruct != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _22 = Index * 6;
  _23 = ResultsStruct + _22;
  _24 = Adc_Sar_GetMaskedResult (Instance, Cdr);
  _23->ConvData = _24;
  _25 = Index * 6;
  _26 = ResultsStruct + _25;
  _26->AdcChnIdx = ChnIdx;
  _27 = Cdr >> 19;
  _28 = (int) _27;
  _29 = _28 & 1;
  _30 = Index * 6;
  _31 = ResultsStruct + _30;
  _32 = _29 != 0;
  _31->ValidFlag = _32;
  _33 = Cdr >> 18;
  _34 = (int) _33;
  _35 = _34 & 1;
  _36 = Index * 6;
  _37 = ResultsStruct + _36;
  _38 = _35 != 0;
  _37->OverWrittenFlag = _38;

  <bb 11> :
  _39 = &AdcBasePtr->CEOCFR0;
  _40 = VectAdr * 4;
  _41 = _39 + _40;
  _42 = 1 << VectBit;
  MEM[(volatile uint32 *)_41] = _42;
  Index = Index + 1;
  if (Index >= Length)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  LengthExceeded = 1;
  goto <bb 15>; [INV]

  <bb 13> :
  VectBit = VectBit + 1;

  <bb 14> :
  _43 = AdcChanCount[Instance][VectAdr];
  _44 = (long unsigned int) _43;
  if (VectBit < _44)
    goto <bb 4>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  if (LengthExceeded != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  goto <bb 19>; [INV]

  <bb 17> :
  VectAdr = VectAdr + 1;

  <bb 18> :
  _45 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  _46 = (long unsigned int) _45;
  if (VectAdr < _46)
    goto <bb 3>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  D.6939 = Index;
  AdcChanCount = {CLOBBER};

  <bb 20> :
<L20>:
  return D.6939;

}


Adc_Sar_CheckSelfTestProgress (const uint32 Instance)
{
  uint8 Index;
  uint32 ElapsedTicks;
  uint32 CurrentTicks;
  uint32 TimeoutTicks;
  uint32 Reg;
  Adc_Sar_Ip_StatusType Status;
  const struct ADC_Type * const AdcBasePtr;
  Adc_Sar_Ip_StatusType D.7070;
  long unsigned int D.7060;
  long unsigned int D.7054;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Status = 0;
  Reg = 0;
  TimeoutTicks = OsIf_MicrosToTicks (3000, 0);
  _1 = OsIf_GetCounter (0);
  CurrentTicks = _1;
  Index = 0;
  goto <bb 19>; [INV]

  <bb 3> :
  ElapsedTicks = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  D.7054 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7054 + ElapsedTicks;

  <bb 5> :
  _2 = AdcBasePtr->MSR;
  _3 = _2 & 262144;
  if (_3 != 262144)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Status = 2;

  <bb 9> :
  if (Status == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 10> :
  ElapsedTicks = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  D.7060 = OsIf_GetElapsed (&CurrentTicks, 0);
  ElapsedTicks = D.7060 + ElapsedTicks;

  <bb 12> :
  _4 = AdcBasePtr->MSR;
  _5 = _4 & 262144;
  if (_5 == 262144)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  if (ElapsedTicks < TimeoutTicks)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  if (ElapsedTicks >= TimeoutTicks)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  Status = 2;

  <bb 16> :
  if (Status == 2)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  goto <bb 20>; [INV]

  <bb 18> :
  Index.14_6 = Index;
  Index = Index.14_6 + 1;

  <bb 19> :
  if (Index <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  if (Status != 2)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 21> :
  Reg = Reg | 47104;
  _7 = AdcBasePtr->STSR1;
  _8 = Reg & _7;
  if (_8 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  Status = 1;

  <bb 23> :
  D.7070 = Status;
  CurrentTicks = {CLOBBER};

  <bb 24> :
<L24>:
  return D.7070;

}


Adc_Sar_ConfigChannels (const uint32 Instance, const struct Adc_Sar_Ip_ChanConfigType * ChannelConfigsPtr, uint8 NumChannels)
{
  const struct Adc_Sar_Ip_ChanConfigType * ChnConfig;
  uint32 PsrMask[3];
  uint32 DmarMask[3];
  uint32 CwenrMask[3];
  uint32 CimrMask[3];
  uint32 VectBit;
  uint32 VectAdr;
  uint8 Index;
  struct ADC_Type * const AdcBasePtr;
  long unsigned int D.7025;
  long unsigned int D.7024;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Index = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (int) Index;
  CimrMask[_1] = 0;
  _2 = (int) Index;
  CwenrMask[_2] = 0;
  _3 = (int) Index;
  DmarMask[_3] = 0;
  _4 = (int) Index;
  PsrMask[_4] = 0;
  Index.10_5 = Index;
  Index = Index.10_5 + 1;

  <bb 4> :
  _6 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  if (Index < _6)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  Index = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  _7 = (unsigned int) Index;
  _8 = _7 * 3;
  ChnConfig = ChannelConfigsPtr + _8;
  _9 = ChnConfig->ChanIndex;
  _10 = _9 / 32;
  VectAdr = (uint32) _10;
  _11 = ChnConfig->ChanIndex;
  _12 = (long unsigned int) _11;
  VectBit = _12 & 31;
  _13 = ChnConfig->EndOfConvDmaEnable;
  _14 = 1 << VectBit;
  D.7024 = Adc_Sar_GetValueFromBool (_13, _14, 0);
  _15 = DmarMask[VectAdr];
  _16 = D.7024 | _15;
  DmarMask[VectAdr] = _16;
  _17 = ChnConfig->PresamplingEnable;
  _18 = 1 << VectBit;
  D.7025 = Adc_Sar_GetValueFromBool (_17, _18, 0);
  _19 = PsrMask[VectAdr];
  _20 = D.7025 | _19;
  PsrMask[VectAdr] = _20;
  Index.11_21 = Index;
  Index = Index.11_21 + 1;

  <bb 7> :
  if (Index < NumChannels)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  Index = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  _22 = (int) Index;
  _23 = &AdcBasePtr->CIMR0;
  _24 = (unsigned int) Index;
  _25 = _24 * 4;
  _26 = _23 + _25;
  _27 = CimrMask[_22];
  MEM[(volatile uint32 *)_26] = _27;
  _28 = (int) Index;
  _29 = &AdcBasePtr->CWENR0;
  _30 = (unsigned int) Index;
  _31 = _30 * 4;
  _32 = _29 + _31;
  _33 = CwenrMask[_28];
  MEM[(volatile uint32 *)_32] = _33;
  _34 = (int) Index;
  _35 = &AdcBasePtr->DMAR0;
  _36 = (unsigned int) Index;
  _37 = _36 * 4;
  _38 = _35 + _37;
  _39 = DmarMask[_34];
  MEM[(volatile uint32 *)_38] = _39;
  _40 = (int) Index;
  _41 = &AdcBasePtr->PSR0;
  _42 = (unsigned int) Index;
  _43 = _42 * 4;
  _44 = _41 + _43;
  _45 = PsrMask[_40];
  MEM[(volatile uint32 *)_44] = _45;
  Index.12_46 = Index;
  Index = Index.12_46 + 1;

  <bb 10> :
  _47 = Adc_Sar_Ip_au8AdcGroupCount[Instance];
  if (Index < _47)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  CimrMask = {CLOBBER};
  CwenrMask = {CLOBBER};
  DmarMask = {CLOBBER};
  PsrMask = {CLOBBER};
  return;

}


Adc_Sar_CollectMcrMasks (const uint32 Instance, const struct Adc_Sar_Ip_ConfigType * const Config, uint32 InitialMcr)
{
  uint32 Mcr;
  uint32 D.7010;
  long unsigned int D.7009;
  long unsigned int D.7008;
  long unsigned int D.7007;
  long unsigned int iftmp.5;
  long unsigned int D.6998;
  long unsigned int D.6997;
  long unsigned int D.6996;

  <bb 2> :
  Mcr = InitialMcr;
  Mcr = Mcr & 3758096383;
  _1 = Config->ConvMode;
  _2 = _1 << 29;
  _3 = _2 & 536870912;
  Mcr = Mcr | _3;
  Mcr = Mcr & 4294967289;
  _4 = Config->ClkSelect;
  D.6996 = Adc_Sar_GetADCLKSELValue (_4);
  Mcr = D.6996 | Mcr;
  Mcr = Mcr & 4294967263;
  _5 = Config->AutoClockOff;
  D.6997 = Adc_Sar_GetValueFromBool (_5, 32, 0);
  Mcr = D.6997 | Mcr;
  Mcr = Mcr & 2147483647;
  _6 = Config->OverwriteEnable;
  D.6998 = Adc_Sar_GetValueFromBool (_6, 2147483648, 0);
  Mcr = D.6998 | Mcr;
  Mcr = Mcr & 3221225471;
  _7 = Config->DataAlign;
  _8 = _7 << 30;
  _9 = _8 & 1073741824;
  Mcr = Mcr | _9;
  _10 = Adc_Sar_Ip_au32AdcFeatureBitmap[Instance];
  _11 = _10 & 4;
  if (_11 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _12 = Config->CtuMode;
  switch (_12) <default: <L3> [INV], case 1: <L1> [INV], case 2: <L2> [INV]>

  <bb 4> :
<L1>:
  Mcr = Mcr & 4294836223;
  Mcr = Mcr | 131072;
  goto <bb 7>; [INV]

  <bb 5> :
<L2>:
  Mcr = Mcr & 4294770687;
  Mcr = Mcr | 65536;
  Mcr = Mcr | 131072;
  goto <bb 7>; [INV]

  <bb 6> :
<L3>:

  <bb 7> :
  _13 = Config->InjectedEdge;
  switch (_13) <default: <L9> [INV], case 1: <L7> [INV], case 2: <L8> [INV]>

  <bb 8> :
<L7>:
  Mcr = Mcr & 4290772991;
  Mcr = Mcr | 4194304;
  goto <bb 11>; [INV]

  <bb 9> :
<L8>:
  Mcr = Mcr & 4288675839;
  Mcr = Mcr | 6291456;
  goto <bb 11>; [INV]

  <bb 10> :
<L9>:

  <bb 11> :
  Mcr = Mcr & 4227858431;
  _14 = Config->ExtTrigger;
  if (_14 == 2)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  iftmp.5 = 67108864;
  goto <bb 14>; [INV]

  <bb 13> :
  iftmp.5 = 0;

  <bb 14> :
  Mcr = iftmp.5 | Mcr;
  _15 = Config->ExtTrigger;
  if (_15 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  Mcr = Mcr & 4160749567;
  _16 = Config->NormalExtTrgEn;
  D.7007 = Adc_Sar_GetValueFromBool (_16, 134217728, 0);
  Mcr = D.7007 | Mcr;
  Mcr = Mcr & 4261412863;
  _17 = Config->NormalAuxExtTrgEn;
  D.7008 = Adc_Sar_GetValueFromBool (_17, 33554432, 0);
  Mcr = D.7008 | Mcr;

  <bb 16> :
  Mcr = Mcr & 4294965247;
  _18 = Config->AvgEn;
  D.7009 = Adc_Sar_GetValueFromBool (_18, 2048, 0);
  Mcr = D.7009 | Mcr;
  Mcr = Mcr & 4294965759;
  _19 = Config->AvgSel;
  _20 = _19 << 9;
  _21 = _20 & 1536;
  Mcr = Mcr | _21;
  D.7010 = Mcr;

  <bb 17> :
<L17>:
  return D.7010;

}


Adc_Sar_GetADCLKSELValue (Adc_Sar_Ip_ClockSelType ClockSel)
{
  uint32 D.7012;

  <bb 2> :
  _1 = ClockSel << 1;
  D.7012 = _1 & 6;

  <bb 3> :
<L0>:
  return D.7012;

}


Adc_Sar_GetIsrFlags (const uint32 Instance)
{
  uint32 Flags;
  uint32 Isr;
  const struct ADC_Type * const AdcBasePtr;
  uint32 D.7041;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Isr = AdcBasePtr->ISR;
  Flags = 0;
  _1 = Isr & 2;
  Flags = Flags | _1;
  _2 = Isr & 1;
  Flags = Flags | _2;
  _3 = Isr & 8;
  Flags = Flags | _3;
  _4 = Isr & 4;
  Flags = Flags | _4;
  _5 = Adc_Sar_Ip_au32AdcFeatureBitmap[Instance];
  _6 = _5 & 4;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _7 = Isr & 16;
  Flags = Flags | _7;

  <bb 4> :
  D.7041 = Flags;

  <bb 5> :
<L2>:
  return D.7041;

}


Adc_Sar_GetMsrFlags (const uint32 Instance)
{
  uint32 Flags;
  uint32 Msr;
  const struct ADC_Type * const AdcBasePtr;
  uint32 D.7037;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Msr = AdcBasePtr->MSR;
  Flags = 0;
  Msr.13_1 = (signed int) Msr;
  _2 = Msr.13_1 >> 26;
  _3 = (long unsigned int) _2;
  _4 = _3 & 32;
  Flags = Flags | _4;
  _5 = Msr >> 18;
  _6 = _5 & 64;
  Flags = Flags | _6;
  _7 = Msr >> 15;
  _8 = _7 & 256;
  Flags = Flags | _8;
  _9 = Msr >> 13;
  _10 = _9 & 128;
  Flags = Flags | _10;
  _11 = Adc_Sar_Ip_au32AdcFeatureBitmap[Instance];
  _12 = _11 & 4;
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _13 = Msr >> 7;
  _14 = _13 & 512;
  Flags = Flags | _14;

  <bb 4> :
  _15 = Msr << 5;
  _16 = _15 & 1024;
  Flags = Flags | _16;
  D.7037 = Flags;

  <bb 5> :
<L2>:
  return D.7037;

}


Adc_Sar_GetMaskedResult (const uint32 Instance, const uint32 Cdr)
{
  uint8 Resolution;
  uint16 Result;
  uint32 CdrMask;
  uint16 D.6948;

  <bb 2> :
  CdrMask = 65535;
  _1 = Adc_Sar_Ip_axAdcSarState[Instance].BypassResolution;
  _2 = ~_1;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Resolution = Adc_Sar_GetResolution (Instance);
  goto <bb 5>; [INV]

  <bb 4> :
  Resolution = 15;

  <bb 5> :
  _3 = Adc_Sar_Ip_axAdcSarState[Instance].DataAlign;
  if (_3 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _4 = (unsigned int) Resolution;
  _5 = 16 - _4;
  CdrMask = 65535 << _5;
  _6 = (short unsigned int) Cdr;
  _7 = (short unsigned int) CdrMask;
  Result = _6 & _7;
  goto <bb 8>; [INV]

  <bb 7> :
  _8 = (unsigned int) Resolution;
  _9 = 15 - _8;
  _10 = 65535 << _9;
  CdrMask = _10 & 32767;
  _11 = (short unsigned int) Cdr;
  _12 = (short unsigned int) CdrMask;
  _13 = _11 & _12;
  _14 = (int) _13;
  _15 = (unsigned int) Resolution;
  _16 = 15 - _15;
  _17 = _14 >> _16;
  Result = (uint16) _17;

  <bb 8> :
  D.6948 = Result;

  <bb 9> :
<L6>:
  return D.6948;

}


Adc_Sar_GetResolution (const uint32 Instance)
{
  uint8 ResolutionBits;
  uint32 Calbistreg;
  const struct ADC_Type * const AdcBasePtr;
  static const uint8 ResolutionArray[4] = "\x0e\f\n\b";
  uint8 Resolution;
  uint8 D.6950;

  <bb 2> :
  AdcBasePtr = Adc_Sar_Ip_apxAdcBase[Instance];
  Calbistreg = AdcBasePtr->CALBISTREG;
  _1 = Calbistreg >> 29;
  _2 = (unsigned char) _1;
  ResolutionBits = _2 & 3;
  _3 = (int) ResolutionBits;
  Resolution = ResolutionArray[_3];
  D.6950 = Resolution;

  <bb 3> :
<L0>:
  return D.6950;

}


Adc_Sar_ResetWdogCWSELR (struct ADC_Type * const Base, const uint8 RegisterNumber)
{
  <bb 2> :
  _1 = &Base->CWSELRPI[0];
  _2 = (unsigned int) RegisterNumber;
  _3 = _2 * 4;
  _4 = _1 + _3;
  MEM[(volatile uint32 *)_4] = 0;
  return;

}


Adc_Sar_WriteThresholds (struct ADC_Type * const Base, const uint8 RegisterNumber, const uint16 HighThreshold, const uint16 LowThreshold)
{
  uint32 Value;

  <bb 2> :
  _1 = (long unsigned int) HighThreshold;
  _2 = _1 << 16;
  _3 = _2 & 2147418112;
  _4 = (long unsigned int) LowThreshold;
  _5 = _4 & 32767;
  Value = _3 | _5;
  _6 = (int) RegisterNumber;
  Base->THRHLR[_6] = Value;
  return;

}


Adc_Sar_EnableHighSpeed (struct ADC_Type * const Base, boolean Enable)
{
  uint32 Amsio;
  long unsigned int iftmp.7;

  <bb 2> :
  Amsio = Base->AMSIO;
  Amsio = Amsio & 4294574079;
  if (Enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.7 = 393216;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.7 = 0;

  <bb 5> :
  Amsio = iftmp.7 | Amsio;
  Base->AMSIO = Amsio;
  return;

}


Adc_Sar_Powerdown (struct ADC_Type * const Base)
{
  <bb 2> :
  _1 = Base->MCR;
  _2 = _1 | 1;
  Base->MCR = _2;
  return;

}


Adc_Sar_Powerup (struct ADC_Type * const Base)
{
  <bb 2> :
  _1 = Base->MCR;
  _2 = _1 & 4294967294;
  Base->MCR = _2;
  return;

}


